<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CBDC系列（3） - Jura项目浅析(批发型CBDC跨境支付实验项目)</title>
    <url>//articles/jura-project/</url>
    <content><![CDATA[<p>Jura项目是BIS创新中心，Bank of France，Swiss National Bank合作实验项目，意在研究批发型CBDC在跨境结算中发挥的作用。具体参见BIS的项目介绍<a href="https://www.bis.org/publ/othp44.htm">Project Jura - Cross-border settlement using wholesale CBDC</a>。</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p><img src="/images/jura-project/architecture.png" alt=""></p>
<p>项目的主要技术服务商是R3，技术架构就采用了Corda。这个是wholesale CBDC的场景，Corda的性能和设计理念也算比较契合。</p>
<ol>
<li>资产代币化asset tokenize。商业票据Comercial Paper（CP）由DAR生成数字资产，通过Gateway（也就是图中的NATIXIS）mirror映射到平台上，同时赋予了所有者等属性。对应到Corda里的概念，就是state，可关联到实际环境中的资产和条款等。Corda的这种设计，将wCBDC和CP在技术逻辑上一致，使得这个SDX测试平台可以用相似的逻辑去支持PvP和DvP交易。</li>
<li>发行/赎回。SDX平台有几类节点，Notary node, Issuer node, Monitor/Observer node监管节点, Bank node。其中，Issuer node跟RTGS完成传统账户体系的兑换。在白皮书里提到 “In Project Jura, EUR and CHF wCBDC and the NEU CP token on the SDX test platform had no legal force, meaning that the wCBDCs did not represent a direct central bank liability.” 这点感觉更多的是强调<strong>非直接央行负债</strong>，实际上是明确了issuer居中转换的必要地位。</li>
<li>不同的资产类型通常属于司法管辖区，由不同的notary公证人节点，通常由该资产管理员角色来承担，例如商行，或者授权的管理者。由于Corda的无需全局广播共识的设计，因此单个种类资产的交易情况，只需要该资产的notary进行签署，保证了账本或者资产管辖的独立性隔离性。由于notary节点通常只是技术意义上的，不授权查看具体的交易内容，通常引入监管节点来监控具体的交易（一种办法是只需在交易规则上配置有效的交易需要监管节点签名）。</li>
<li>子网划分。各个央行可以独立划分和管理子网，允许商行节点接入子网进行业务，实际上就是实现了对其管辖货币的准入机制，只有接入该子网的商行节点才能执行该种资产的业务。在本次实验的拓扑中，银行节点是物理网络联通的，这在实际情况中由于网络策略管控，特别是随着银行借点数量增加，往往是不可全联通的。一种替代方案是参考DAR的类似做法，通过每个央行子网引入Operator Node（可以是逻辑的，与其他角色的node，例如Observer Node共用）作为Gateway，同时不同子网Gatewa互联，本国的商行只与本国的Gateway联通，把全网变成雪花拓扑结构。跨司法领域的，例如外币兑换等，就需要通过Gateway与他国商行交互，这种路由方式可以由全局的网络地图服务提供。这种方式，使得每笔交易都经过了交易双方央行及交易货币对的所属央行，满足监管需要。</li>
<li>DvP,PvP的交易，涉及两种资产在两个子网的处置，需要两种资产的notary的签名赋予有效性。为保证交易的原子性，引入了R3的dual-notary signing机制，类似于哈希时间锁算法，常用的跨链方案。</li>
</ol>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>R3 Corda概念理解</title>
    <url>//articles/understanding-corda/</url>
    <content><![CDATA[<h3 id="Corda的设计理念"><a href="#Corda的设计理念" class="headerlink" title="Corda的设计理念"></a>Corda的设计理念</h3><blockquote>
<p><a href="https://www.finyear.com/R3-Corda-A-Distributed-Ledger-Designed-for-Financial-Services_a35855.html">R3 Corda: A Distributed Ledger Designed for Financial Services</a> : R3 CTO在2016年设计之初分享的设计理念及心路历程</p>
</blockquote>
<ol>
<li>专门针对金融场景开发，而非通用区块链。受区块链思想的影响，在很多设计理念上考虑了当前金融领域的特点和经典场景。<ul>
<li>交易不再全局广播，只在相关方可见；</li>
<li>引入可信公证人机制；</li>
<li>没有经典的区块&amp;全局一条链的设计等等；</li>
</ul>
</li>
<li>借鉴了区块链经典思想，回归到本质：共识，有效性，唯一性，不可篡改性，可验证性。<ul>
<li>使用公证人机制防止双花；</li>
<li>UTXO模型，从单纯的资产扩展到状态；</li>
<li>签名放篡改抵赖；</li>
</ul>
</li>
</ol>
<p><em>无链之链，非链之链</em>。更恰当应该叫分布式账本DLT。基于金融领域真实存在的一些假设和前提（例如存在可信公证人），更像是借鉴区块链思想去解决金融领域的实际问题，提升效率。</p>
<span id="more"></span>
<h3 id="Concept-amp-Model"><a href="#Concept-amp-Model" class="headerlink" title="Concept &amp; Model"></a>Concept &amp; Model</h3><h4 id="1-P2P-Network-Component"><a href="#1-P2P-Network-Component" class="headerlink" title="1. P2P Network Component"></a>1. P2P Network Component</h4><blockquote>
<p>• <strong><em>Nodes</em></strong>, communicating using AMQP/1.0 over TLS. Nodes use a relational database for data storage.<br>• A <strong><em>permissioning service</em></strong> that automates the process of provisioning TLS certificates.<br>• A <strong><em>network map service</em></strong> that publishes information about nodes on the network.<br>• One or more <strong><em>notary services</em></strong>. A notary may itself be distributed over multiple nodes.<br>• Zero or more <strong><em>oracle services</em></strong>. An oracle is a well known service that signs transactions if they state a fact and that fact is considered to be true. They may also optionally also provide the facts. This is how the ledger can be connected to the real world, despite being fully deterministic.</p>
</blockquote>
<ol>
<li><code>Network Map Service</code>网络地图服务，发布每个节点的IP地址，证书及提供服务接口等。节点可以订阅网络地图变更事件，启动时主动注册。节点可以本地缓存地图，收到其他节点连接时基于地图校验以及身份体系服务作校验。</li>
</ol>
<h4 id="2-Data-Model"><a href="#2-Data-Model" class="headerlink" title="2. Data Model"></a>2. Data Model</h4><blockquote>
<p>• <strong><em>State</em></strong> objects, representing an agreement between two or more parties, governed by machine-readable Contract Code. This code references, and is intended to implement, portions of human-readable Legal Prose.<br>• <strong><em>Transactions</em></strong>, which transition state objects through a lifecycle.<br>• A <strong><em>Flow</em></strong> Framework, which enables parties to coordinate actions without a central controller.</p>
</blockquote>
<ol>
<li>节点存储的<code>State</code>可以是任意格式，不限定于KV结构。丰富了其在金融领域的实际表达能力，可以是包含真实的合同文件等。Corda关注的是状态转移，所以除了最开始的发行外，所有的后续的状态转移都必然有输入输出。</li>
</ol>
<h4 id="3-Transaction-Model"><a href="#3-Transaction-Model" class="headerlink" title="3. Transaction Model"></a>3. Transaction Model</h4><blockquote>
<p>• <strong><em>Input references</em></strong> : These are (hash, output index) pairs that point to the states a transaction is consuming.<br>• <strong><em>Output states</em></strong> : Each state specifies the notary for the new state, the contract(s) that define its allowed transition functions and finally the data itself.<br>• <strong><em>Attachments</em></strong> : Transactions specify an ordered list of zip file hashes. Each zip file may contain code, data, certificates or supporting documentation for the transaction. Contract code has access to the contents of the attachments when checking the transaction for validity.<br>• <strong><em>Commands</em></strong> : There may be multiple allowed output states from any given input state. For instance an asset can be moved to a new owner on the ledger, or issued, or exited from the ledger if the asset has been redeemed by the owner and no longer needs to be tracked. A command is essentially a parameter to the contract that specifies more information than is obtainable from examination of the states by themselves (e.g. data from an oracle service). Each command has an associated list of public keys. Like states, commands are object graphs.<br>• <strong><em>Signatures</em></strong> : The set of required signatures is equal to the union of the commands’ public keys.<br>• <strong><em>Type</em></strong> : Transactions can either be normal or notary-changing. The validation rules for each are different.<br>• <strong><em>Timestamp</em></strong> : When present, a timestamp defines a time range in which the transaction is considered to have occurrred.<br>• <strong><em>Summaries</em></strong> : Textual summaries of what the transaction does, checked by the involved smart contracts. This field is useful for secure signing devices.</p>
</blockquote>
<h3 id="Corda流程"><a href="#Corda流程" class="headerlink" title="Corda流程"></a>Corda流程</h3><p><img src="/images/understanding-corda/tx-flow.png" alt=""></p>
<ol>
<li>节点只需要存储跟自己相关的信息，而且也只能看到跟自己相关的，任何普通参与方都没有全局账本，只有跟自己相关的局部账本。相对于传统区块链的共享数据，更关注于保护隐私。节点B需要验证A的porposal，验证输入有效性，例如说转让资产的场景，A当前所持有资产是第三方C在之前的交易里转给A的。B需要一直回溯和验证状态转移链路，一直到最开始发行的起始。从这个意义上，这是状态转移链。<code>Identity &amp; Permission Service</code>解决了交易链路上各个涉及方的身份认证问题。Corda规定了propasal的发起方需要存有这些历史记录供对手方查询，解决了数据来源的问题。在类似于零售交易的场景下，回溯链路可能会很长，可以通过<code>State re-issuance</code>剪枝等方式来解决。</li>
<li><code>Notary Pool</code>公证人池，共识算法可插拔式，可以是BFT，也可以是raft等。按照最基本的定义，公证人可仅作为消除交易并行冲突，防止双花，保证唯一性这个基本职能，不作为具体交易的验证节点，因此就不需要看到交易的具体内容。</li>
<li>交易签名的机制是定义在flow里，可以配置AND/OR等多种组合阈值规则（复合签名）。每个state都指向某个notary，单个交易里不允许消费由不同notary控制的多个state，因此单个交易就没有必要协调多个notary来达到原子性。</li>
</ol>
<h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><ol>
<li>Corda设计的初衷就是针对银行场景，可信公证人身份很容易在现实中找到对应的角色，例如央行，监管机构等。同时，交易的合法/签名规则是最开始定义在flow里的，因此除了交易方，公证人之外很容易引入其他角色。例如规定一笔交易必须经过监管节点签名等等，现实中的合规检查和监管都容易实现。但同时这种星型拓扑给公证人和监管角色节点的性能及安全都提出了更高的要求，技术处理不好可能会成为整个网络的单点故障。</li>
<li>目前看Corda专注和适用的场景还是偏向低频的批发型B2B业务。如果将其作为零售性CBDC的技术方案，性能是否能满足有待验证。类似于之前分析的<a href="https://simplexity.cn/articles/open-cbdc/">OpenCBDC方案</a>，货币发行当局作为公证人验证交易的合法性，存在性，唯一性，与Corda的设计有相似之处。但正如在之前文章分析的，UTXO模型的固有局限性可能还是一个制约。</li>
<li>Corda跟传统区块链的形态差别还是很大的，针对金融场景设计意味着同时放弃了对通用场景的支持。但是这种借鉴技术又不拘泥的做法还是值得学习的，毕竟技术最终也是为业务而服务的。正如R3的CTO所说，“Every successful project I’ve worked on started with the requirements, not some cool piece of technology, and I was determined to bring that discipline into our work at R3.”</li>
</ol>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h3><blockquote>
<p><a href="https://corda.net/wp-content/uploads/2021/11/corda-platform-whitepaper.pdf">官方文档: corda-platform-whitepaper</a><br><a href="https://corda.net/wp-content/uploads/2021/11/corda-technical-whitepaper.pdf">官方文档: corda-technical-whitepaper</a>  </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>失败任务重试策略</title>
    <url>//articles/retry-strategy/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="49acb2b8329e9f71626f8b3229696a5a84b95f535593c712a167dd6d415e4158">3175488eedc729df0c7d358c640da99e5db97a13f852973918f00ac21570e613bba0328fd65f8fc7a42e01e09b17f1c39751aa1558cda6efd11e5e96f3e1ba4bffc6e6523141a7fa348e1e936df5affe94aee38d3d5738e873b420baa60209d1b3699d1eb361d664fda238523bf2c92485a2f179e6dd8399649faf5aa13ea7eaba37307fd1743d91dc143e27430b947b1b60a15056a051702ac4a3ef8886c2afc9534517e399fe10ccacf7635fbaf7a10cd0961d40a9a839ac4293035e0cecb13190196d56ed2f3c66298bd4ab3367efce8aa6f26f70aefb286ae992851d9e7922322efdd6ebddcd9ed7f7ae6a8c2e1eac14f564797c07c516e7f97be7ac86d79387c06928bf5b5378167e9e644cbf30f667a31768bd26d0244e1c1b17e0839ea6ce3cde42c7b5dccae239eeb4acb88a60e45c05a6fecd9d15aebce0b758f45a8989cb89051617d22e2c82f64336b26ec5b1478c4f4c26824f25004e40b9335d519969ec0566d579cb39b5d6e076ba2f7022377c0c18ee301980cc0919269f2539c6e8710ebd43c76dc7ec9e7b5627742466c61ca5c1686044a02d9b5a5864c587c425f7d788966cf945819a76e11bf068378af83a2b3efa2d6149786784790e9ad463705b913a35a6291052e5346333005213f8086090036cbffbb57ad0af433ff432c1d9c1c63ff31c7ad8883636801f989449e7d4c139daa64e544e18e88b4c8565aa43b71e2721e214152aecc1e9fab6483fd4f09377b1fb4c5db29ea6306214535fa03cf3aae4617ca4915a43173459daa6db0ecc4b163fc3f8d3d528f6b9f6889bbc17824a47a51e2a3a21a0cf4cb3594fea9b3694a46fd1dff59ebd12a9bd57bb09271ff0334ff4f95d2f69c1e8680981c195a4cc8de9ff255ac111f6998229df2fe0f572e0692c78934bc67a221dd71c14360ee7bd5a186ba72bffe4a271a577b7d40ee2d53b4907aea341175d567d98d62b25bbf04e547b9466489129808f821c6543ebea707b22fc9a6d0f2144e50126763cbcb3e8d81abb3bc56cab22f9e1896545a43198822dd87ca1191fba888d34359a33e8b8d09b8753eb3bb5878e58b12cbd9cada0f9a0b4367822097f4995ca6e1cd5040d5d9f0c6b9819151bf759990825d5d32e7116574cd5778d1ed3fbb328a878984d399c8c7a2b94e73782a7d5a9a88900a4b94dd9ef5330a1dcc928752b990c6375812203f3c4c07528e58194de4b4c51c3028a997e69072f652f84f3672bd2cf8fc191d4255a5d443adfc86b1e6090213e97f1353c967646265a9faf2e193a7f016a85e4b48f9a0180e3dc74a787586875ce42ccbcded95364d487d7927ae4b98f0cfa8086b03756e2dadfbede43204d6dae690637dfe24adca1fd575bbdf330bc3f51dfa17250da09736da6205eb47c93d7273b709e38642ad1a49b1544da27ff2dab9cb480137fbf7962cc74ad26c86500133d199af4dec4cbe08e6af2893fa05883dc5fb490e55d7fcca6ca06582dabe321e759a1d66f5692075c737609e716b10a9d43a6c42ba0016be4012a1ab050d682108e8e860d27562418e6ec1d17ea7c2a53e87dd55503da81a1f6b54c4968a92670f57de64d80b56d8fa5bf1e723c171b10476347235015af9140c34b659eaebab0412abae27c448fa5558d2d44a05ddddebf1dd37c6bd6976db8c4e4b79fc187ec2c4accc03fd5d995318e1c32d8c3fd261d57a9ade04d34b2b404767381d61380aea1cf8fea23dbcfddf6877ce7488ab889313d2c9673dd50affa1487562b690b0f5011ef570c2da0889cdb2751c16e9a227b3d78c8f891261bc2a2dfa60fedc408bf6db79adb7ebe3ac3f22ff5e26bfba4dc68d822983042bc88a92f7bcf087d396d88e0de18c0dd655fb172772e0150fde0cd5362664889204b5759348df617d1b31cbafaf77fa52942294c9f11f32782cd73c8c07ea8913a1c66518c2b76f7fd84cfc23f774dc04a7f390dc2f7518d8b1ee74045b5ec17ad453a2b1129c93645c33b1ccc2bd42cc201bce0e4d72fc58f8565757df191cdc0847fd5420283dcf2c661af3784be5f3d969e89fd14bfce51cab38e7b7db1e8b60b155913f4cdf3ea2cc07a694052fd345b7d08f529b0d6093fd06cfecfacc300c73a3326273657e30b2f48503d7999462faa233d40b8b33f40176d7b59c580e44ec72515935918425cbe04f49ff4993491c5ff324170143c1dde550862958ad57dec7d45e5e4e50b1959305ff6390298be9a6d80886d3cbf2a540b797c6a4ff16a527fc5dcb720f511db3036fa668de4a73b52396e4b74250f412819a8934fee543a3cebd0974db4efa4847d764f06dc98f01bca650db0019263f562c171652a918f89b7d69166cdb1b72232f238a5420a948eef0b9cffa854ab1c3a08e8b84c6963c83bbe799c985da7feee8ce3b2cbc90b091f1d7286840dff5824695447d92ba50b6bcfed0c222b1f6a5a8e46c77aeb99f7a76ec1e3c1115c05b27b4f66dbd80484aa7b99dec149015da84ba3dcc8dcc5ca0b7f6cc88ae0a74e21bab8b300edc9a1ea89c3d1a6d7fec1eab5eeadd839e4c87b2fd26de8d06130f4aa7f891cf7e9d6db0874b98eda81eae9763ab5bcae606a02e2e0e6373439ed8c4dbfaf81d78c30f313734a0dd3ccd0e35599fcbedd8b84659bea3d881b5b5f48e9f65d53a57bca61c3e31ed0ca274618b9fdcb4c786079ea680fc8890cbcfb341094cbe57ca0f84a72a0ad3663614a80ac216ed1ebeb2bc7e8c69e23380d4fce031b44a06054df7c2f5086890e665f1f4ce6f1c4f210e8b8ea31ac42c1dabfdc709eac5cc7d7dd38ed8472fbe4608806be51bef8f841e3035fa485229275707cb3c99ebabfc0713147703257594d9a9309967cad30c794a7c92410829dda8a9b339a956b52ec14e51e095229a67784ac9684605c2b234ed1c2182dce9b585e2990afedbc94f14757b77e788a0e1b23d829408b68259c1ef6442f98cfd1dac2716b2971ab608d69101d3a015ea12c83603d3c74560feef9729a7fec2c5cb38f9a029d8b047c8404bf292df856bd534ffc6bfb7caab6f6b2246932dc014a79d0570784c58403bc31a78c4b69cb31c7b7e7693636e491cfa821feea0b4fff81fe000bdbf91ea219dc65e3a1b43fde974c682b0cf8a7d7841774fcae2fab8f0b8259b445d0cf16a81fc2c33c929b6692c1b5ba2baa68140b1340687cf0c5271f3ab6391b2f49032c7123b5b14c1e4b0082b81ad2caea9878d38248896026273946b03b287fce8c9fc68de6f23ecc33ad92fb479eaafa7e3a32386b5386bdf200b655a48e26634b0bab5c119158ec39637d607af47f21054cc8626a3b0471e1862647bfcf8d90faf7487e96562d8eef5e2c3bdfdd28c47164db11e606ae7a43c322372c22a5c418d3054b4ed882dc68ef8442465110dc0a938344b733d54ba36cabeb1e1329ed1fec3df2720ab465ed77266a4e9dcebb39967390e19578a59420acc9c0748c7e3bcd301ec7454599c8e43b9e3a7728c14fa1d51e4313a402620d5f01014b7847bb0c59bfb6301c4fb20ce971c16f385d0865a6571e9d6ad0fff91dd9d109cc0895c38e44aae195d83d35beb7adc3df8b18e87b39669230bab29a8d4a0fe228d8957c2f5149afdc8d2b60d5644d86fe350b18636eccfc709797af1a8a6a0671d16eb3716dd6d659a9081a00c937a22fd52b8b6ef06329d01354d343a9ddc2e888ff6a3c6397d434c8dff58e32b5fb48bb2f5dac2bab432290f78ae6c759cc1c7f9f1591b67e3f04f685c8e551eaa2111c7a2609c3c5a583bd9126fd02dd99c9cb3d55ce001170dde0cf9bd518eaa6ac5a2acd72e0b2b701d930db8a44f5cf07242a46f92d89de1faa5d278c9140b9d4ed68b790e2c82bc0081b2a8648bf8fcd4cc7110f1e67fb89a38205bca35cbaa6ee7f6a47bdf48116afda313e66244f4b46da2b7422cfbecc06d5997dc5d7fc523470ea89a5f70b165bf9ed6728a89f84ef3413efe46319010a9eb45259cc44dcab1a31f05a3040d43c6a86540f99f738cfdf258c9b279b617aa42cd755210948237bb781f95c6fed92d7b96daba7e6887e90043ee3803092bf68f03ea6b934cae87a58e64ac610ebb9deb02fe4c3aa3465025184c64f0392c7270cd2bb12df3ffb6baa6c96c0ee1dbb65dc6a62522b63768d06de2673644711d27c2323e30702e0c3b12742010f144846ec8349b09dbe395c16824be2e7722b03f800fab9bcbe0d7d35cd1db7c68db519d832ab04751c25ee2437873a6a0e7c8f33d21c8373b15ceb3eccd54435ae0a927a72e416fffa1985cf3b54a721c73012b7ad423d40718e91281b75acd2dc8b8ed084bad002a31847655091fe71a94b09dc7d7aec3b43ea20215d20a89fe43e560f176d3005bc89e6e044b4497d4cf91eb6dd2602a0da05b4597d8f9a0c515ed9e819bd12ce94028d6978df08b87b43c9e6104b84ef2cddf690fe9d1a1d200e56a124985f4807196eeb19723cd478441a1646bf9d1bf1500e240ceb4c3ec4b4c362e4d8283c00f6da5d96202bc09177828d2773ceff7313d2fd768d2ebbbc75d1781294c15ca2cb1c838cb887d1486d943e2a44b4a6176a691e03eb8743f19711bf929bab39a75c6572d2c471a9eb0258e62527e34e881ad35136e585b27af6b474ef81a957c7cdf5ecabfebb00d97bd8209c436dea5f8af805411508f9ab05789b6bfe79d37f37931fda6068ac37485108b7c786de4b1313c7b9502bf762302e06c596108b7341c3c5c11731576d6d6bb058b6f6e5d2937f9d8aa00af5df037d0a5164bbffe61a8be41c7e3f0bac0ee50da8322d080eef6d45cf566145d53ba2070b5d3173997e99063cdebd1a3447af0f53aa533d4276421b51e6efbc50163e61d599cd8e79f8b7cd76de79553ed7a9a2af53c7f171c8c0c20b3debc386ce341b0cc2f05e664a616acb7c63bb9d8e11e7c7b5d45e1669b73cd0c9d007e1744c21355247b1347cbdb34f43346a3a22dbc072d0d0f990c259fa4fd27470172837d6156094ff383b0cb826e30a0d039965315c961d2d528460c5a698443146bb925c141120f3a9f54e77097e634f7891eed995f82206c3ddc8e10350fb8a85a14d0f2cb54bac3a62e4a3c97a04752816be613028b7be983a4435806ca57c6259429eb9d975fd8c7035bd5290dd2cc77e0a252434ea11473dec6fc23f8b440c86429bb592214bf02eeb6f38e6c580947c35878482d4a4fd1b1cc3595feed7616c0b02229656dfa548bcb77d0353ac4cce401623e1ee0fa1dd4e18a059d6db5c25a3b43da115bf6b99609b464c731993fd1ddcb9333761810dfae2f4dcc82111b3415a13c038cdbcd78b69ac4c1e668d8a4bee0b10380bc4c7e7db7ba6d8c463a3377a21a1db0b9b61630f507605a47a432045ac74ebc91b25ab79a2786f39ec777d517cc6a9250b710e37ef5bed49126d0374430731e245afc841b64ba4761f809a08472eb48704d1f0c21e66a0a58c364d2362e4bf9956ed9529f60b357efdcd803908cfe1ffb342f516d4e3d1f112e5daade5075693642245b1b86295f0b0644d36d4ed994d6fbfc56cd9d8f5ae96d0a66dea472e907887e2d399cc85e015d7697ed30924de359e397eb042465ba5f7f5a75aeaab89eeaebea80d1bc6cb2b51bfb27d867cf5ec711f7230e81c19a52180805c9769096c77a8a7f6d321648aedc6f66f187853ef510c1ad43c14a6f8f6e89c6fd1e419e72b1e24e679c7ded4c3d4022d19523e7f545f1b6029317cf631c677ffc2de39886e60e206048acb94947a46d5e52529055a983f4918839569b624963af162cbd85e590b64f4626c7db394afbe8a742712f9f9d22f70ee1825cd3f76258103d9f08fc8af74b68aa1c90dec27d9dbfed46399437d45105d035a170b2b8f3110a7bf270cfe0da387fa2addfad40b01d92e0491929c95c2ab54fb03142e12ed4e8c0a321159fcb29ba1278a929f1be9f964837d346704d93913b1647656d8cbf812b368c030a09a4a205aacfe721836cfcecc7562cf9d901cd1852eb9fd0bb9e8b2b80cbac2ca5055b7732aed2aa2269c8e1a2d35dd029d47aa82dc403034b2e22737f93ba76f306434c3dcfaff38023858b30d5ed583f13c6748c983dd7726395da3cd0fbb7b4b0bc8bd8d42dc2c0c52315e4ae393930e0e4ab89081e9b2b0a9add20b4fbf2a3fed92d2d32ce6f2133d20b57fc33174ac915a99a7c4e86452ac82bf5101a36eb5f81b219d9ee2a4d18ac0946aea064455dc48b5c556c3edac71117637e3fcb8983e45bb1486473348e1fbdcc68dbbd34dec3c9ccea0944a6661819679a0d3082dbe288e5a88838e2d83b2b7e14684bd45e345be2d5126e2a14b8cda3257b24a53456baeb0c7a06c991d3869ad4b8447ea5791359260ccc2abe9189502651af964810a8f4e4097b09b82cc0beb8ae97d396c861d9bf9a07b4ae33893864f00240fa8b58a124936a1f5e694024454fcbb1e0d3dfd018700681ba81b4ec5be105ddfb1a284ffa40d22f5dc6a16cd87720798d7ec038584ae324dd96708f3a720d61bf6e1ddf0209617b3fdd34af374752d9bd5df1e03fe1d4bfcf874b39a4efe392526389fc2d9845fcf84f70046adbf90adfba0bcef3f3a8ed5c4d91c0a964b64a834dbfaf5482182693a59dfe626dfa658471c0e1eccd219056df172cff10ffedcd6685b863c0cfa913472aa0892ddfb085d9733cb3256bb4be78a2c969fe93dd75af1aa5a13f6e78fea6876e04e566f2cbd50fa16f3be42e556f6b23914a3a7df1bda531604f181af30023d546d97081b604d381926a92091b97a906550fa987f06a2d71bd222e977ad410eedd26dc36c898ea16ba27de6b964ca0f7cfbf39759c30899280f94eb5a98ae1a347c3ead256ff158f7403240246cce081521a735663a2049f02de63d3f6c8db4b0dd6e5ab5feb6fafd564dc450b1bea42218ea76b7882a24b8078dbf2ac630473010bccbdf3979291634e946a182d4266a1cc445043ac78f6b837513b7d0cc6bb9601de2ada09db0c1c4373e5c313bf998a50cb161719d2c8d0687c990c1b15013a666e8d166c287b2ba2ae59ef75c5af379078aee773f65c57bfb8b0cb4b603bb889617998c41cc82e9d336b9b03fc8dd653c8f5a2e2b5592278d43fb503f2979306c5038e64e426518c7374baf93f80d1055a62f7d7db21bbaba33e761eeca3abc6b92a58c582362d48f3f530b8f6a6e5c9219af1b74620724921477518beb5208a91cf6d47396bef21cdf4752cbf39c0876f85a122c7a7007d5e61a4396cc368494a50f633dc2bb2e165a5720712f142ca05b2df2bee8eb8f5076af592f8e22e0657b615e9d12807f4cc1e35b770f511b2f6d67e3caebeec218fab33aba1b8953fd29aba25536d2d58bec705cfc051b6d94700ca351c7452207891277868215dad2c4f5ec5485512c6698381f85eb8f29214164203d6da0b98f7ba3095c2321526b61ff30148a29166aea08b8086484da7033982fe12fe2ec03db6a50d1b645683d595e7e111af2fb4e58fb8d632ac5aa497156f2499424ace266582ab335b9fabff3de21f42778792a9829993260b2ca2159a00a649189254deb16e271336a2f4d72d287671eacd75d81029434dbd36c5ae81691e34e64638c8d5a38fe8c82194c296807be487e3aaa1e7b44c8628e36764c5babd7168ca03750a962f3b7ef2e615aaeb9068b10522263a17dcc6a1dd5088f5400b0e9824e5fdb7098cd1a531775744f10157b091321e247eade836546dbb34347b7364bdd83b1c0a9805eb29a803b27b273388fdb1ec3bacaeeeb50636f0f090106decbff327872bcafadd8347742a1466ad9926a4cc4540e9f08ad658be153538b9bb3099adfbcf20dd36d6d0181056be2b331714c4bfcabcf17958193f1530301a23957f2643bcb765d82e0a09300204c823f1003b2bb408d4b99d18dc7bbbaea482f8599c64617069f3f3c6feb9c2ba368df91351fa1a95c02dbc15db209a26a42a91b3b99039d1d332b6bac78af99cd3d77a66bd5f3e96090c4843c1a98948d5e2d9f40625082d3fcf9dcada2cdcc3e8a7b5322a3b67666b99f8a548244522ff24f30ee647071128451f08479237209a43e0792847acb4f927ac9debf7825213b713e638fc124d4d1c23e855e1618776361b0f279f9855d850416b63585c9a8b027095c728110366e4cc56bce8b42bc4f68ad06496daeca466c118a7af71eafd203d54271616603e68a90d96dcb200462beb9f0ea8defa02abdf743c568ead59b54742b80521bb95298d9b7c8f2d0f06afdde22a1010d0b30588c014630a656dc7fda627fd2c23af2eadae0f17aa391eefbf3ca5187ab7403c404d26c1fcfe5243ef4bca483f95ad4d261c70100ee09ed7985534db4470672f1d5c0a6ab4b3d9df91bdd5ca1b9c54855ad0f12e0a865a8df23d654655875a8c0cecff18b37d1ce9f756d8dadf4d8304c0ddc750d40aa59ba07b8ed77b41c02548a38e1004d8bd4cb48f22b6cbd441ab46a8618da2c18111b60ee16529620893acbdca8da3ea192128430fffd5d3cc00a752110c015435be338722d79b67fb7a572fa4ccf67dd0c256122d9d338993dd2c705469b8cebfa1def5eb865c4fc225ea841b31f3a2b97602815e95e99685d217d67f28a014e16e6398ef0e0f640e1a86487aaa5ec9f58082453dd34f07d89a1810bbab6038f3d4d8787f597b5f8a528175030c0b080105178196265dd9f7af895434917bcc1f8bbda560fe378714d26410b9f6a2a4c0ce11020d56f0dc7698505d9156b5a1ea4306736e76f6ed7c71240b8b22c0d2915e415bb04e5f8f3cddf952c43e14cb4dad2bac04331b1cc7b1ac73117409331e8c6f734c46f969b3fa72a7f28883f00314b780a185422930988eb88b1291590b7e3ecd97d4048120cc95cc229e13db4c7559dda8ad8788c2b862fd5d12252b23fd3d61991be1db1404b447e72f8a50cd7faa683422de24a9103f905a81f68d0e409d998dcda4fb0b4a3852675023347f934099a8b25c639b81fa4ca902091a3f0c20f17cbca0cd1eef4040d3af42180b056ece1ccfde9b9a3662cf535b5e4a7106f5195df3264556f632c5878b8181b0656fda36382d0908ae5f89737e96dea632e9d9c34a429c6c8d88d78b2eddb813a6f925a6371e9fe9cd7cca5f1b4ef757429c2a74d11e1b3eaac045da30f0dec8ea7d94af2df9a16ef9b19eea72489870d2cc142a66675b0f5933460b54b5b4679485b737e0df647f26669c56cc94712318fade6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Post is cheap, show me the password</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>智能合约事件监听的解决方案</title>
    <url>//articles/sc-event-listener/</url>
    <content><![CDATA[<p>合约里经常会包含有事件（event关键字），应用通过监听链上指定合约的指定事件，从而得到相应的数据触发相应的处理，也就是不同的系统不再需要链下的交互（api调用等），在这里链扮演了类似持久化的消息队列的角色。在多数场景下，对于链上事件，应用有着<strong>可以重复读，可以从指定块开始读，不能丢失事件</strong>等等的需求。应用监听智能合约事件，常见有主动轮询链节点和向链节点订阅推送的方式。当单个应用存在多个实例时，需要在各个实例间协调，避免对同一合约事件的重复处理。同时，当前监听实例一旦下线，对于该合约事件的处理需要由其他实例从当前位置接着消费（应用需要额外设计实现协调机制保证不丢事件不重复消费）。本方案将事件监听和消费协同的功能交给中间件及消息队列等组件。应用无需再额外实现实例间的协调机制，只需要负责从消息队列里消费就可以，保证消息at-least-once消费。一次注册，就可满足单应用多实例甚至多应用的共享。</p>
<span id="more"></span>
<h3 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h3><div align="center" style="width:75%;margin:auto">
    <img src="/images/sc-event-listener/topology.jpg">  
</div>

<h3 id="聚合消费版"><a href="#聚合消费版" class="headerlink" title="聚合消费版"></a>聚合消费版</h3><h4 id="Zookeeper节点目录"><a href="#Zookeeper节点目录" class="headerlink" title="Zookeeper节点目录"></a>Zookeeper节点目录</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">monitor  </span><br><span class="line">    |_ nodes</span><br><span class="line">        |_ active (ephemeral节点，记录active monitor的信息，如ip，端口等)  </span><br><span class="line">    |_ events（永久节点）  </span><br><span class="line">        |_ foo（该节点记录对应的contract address，abi, event name等信息，唯一确定链上合约事件）    </span><br><span class="line">            |_ latsBlock(该事件最近已消费的区块高度)</span><br><span class="line">            |_ topic(对应的kafka topic名)</span><br><span class="line">        |_ bar  </span><br><span class="line">            |_ lastBlock</span><br><span class="line">            |_ topic</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>各个monitor向zk的<code>monitor/nodes/active</code>节点注册选主，保证只有一个monitor是active。该active monitor负责获取链上合约事件，写入kafka。各个非active的monitor监听该zk节点，如果发现active monitor离线(zk节点消失)，则尝试注册，注册成功者成为新的active。有时候active monitor可能会有丢失心跳包等假死的现象，恢复连接后，需要重新注册，判断是否自己是否是active（这部分可以参考常用的zk抢主方案）。</li>
<li>应用通过monitor（主从皆可）创建<code>event</code>节点，即创建特定链事件的监听任务。monitor需要判断zk里是否已经有该<code>event</code>，如果有，则返回已存在的错误码。如果没有，则在<code>events</code>节点下创建以该事件命名的节点，写入对应的链事件信息。如果应用不再需要监听该事件，可以删除监听任务，也即是从zk上删除该节点。（暂停/重新启动的功能机制较复杂，不展开详述）。从应用的角度，只需要注册一次，应用以及monitor重启后都无需重新注册。</li>
<li>active monitor需要监听<code>events</code>目录下节点的增删，对应的启动/停止消费链上合约事件。针对每个事件当前已消费的最新区块高度写到该事件<code>lastBlock</code>节点下。monitor每次消费完成之后需要更新该lastBlock值。monitor主从切换或者全局重启后，active monitor需要扫描<code>events</code>目录下的所有节点记录从各个事件的lastBlock处接着消费。</li>
<li>monitor采用pull的机制使用getLogs接口向链获取日志，（from, to）分别是（lastBlock+1, currentBlockHeight），发送到kafka后再更新zk的值。<strong>异常情况下（发送kafka成功，但是更新zk失败）可能会重复推送。在应用本身负责消息的去重处理。</strong></li>
<li>对于某些事件需要按照上链时间的顺序处理的，需要设置kafka里的分区数为1，否则会在应用端乱序处理。</li>
</ol>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ol>
<li>此方案所有链上合约事件都是由单个active monitor处理，如果监听事件比较多的时候，压力过大容易成为瓶颈。不过，大多数情况下，由于monitor监听处理的速度要远远快于区块链出块的速度，大多数事件的lastBlock是相近的，monitor可以聚合获取区块事件，然后再区分不同的事件相应处理，不需要单独对每个事件向链节点单独获取。新创建的监听事件若指定从历史的fromBlock开始处理，可以单独维护消费任务线程，等追上主流消费进度后再merge监听任务。</li>
</ol>
<h3 id="单独消费版"><a href="#单独消费版" class="headerlink" title="单独消费版"></a>单独消费版</h3><h4 id="Zookeeper节点目录："><a href="#Zookeeper节点目录：" class="headerlink" title="Zookeeper节点目录："></a>Zookeeper节点目录：</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">monitor  </span><br><span class="line">    |_ nodes</span><br><span class="line">        |_ 0(顺序ephemeral节点，存放节点信息等，例如${ip1:port1}) </span><br><span class="line">        |_ 1(${ip2:port2}) </span><br><span class="line">    |_ events（永久节点）  </span><br><span class="line">        |_ foo</span><br><span class="line">            |_ active (ephemeral节点，记录active monitor的信息，如ip，端口等)   </span><br><span class="line">            |_ lastBlock</span><br><span class="line">            |_ topic</span><br><span class="line">        |_ bar</span><br><span class="line">            |_ active</span><br><span class="line">            |_ lastBlock</span><br><span class="line">            |_ topic</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>每个事件都有各自的active monitor，分散处理压力。</li>
<li>应用通过monitor创建监听任务时，该monitor同时把自己注册成该event的active实例。各个monitor监听<code>events</code>节点下的所有event的<code>active</code>节点（例如foo/active, bar/active），当<code>active</code>节点消失后（该monitor宕机或者下线），其他monitor抢主，新的active monitor接着消费。</li>
</ol>
<h4 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h4><ol>
<li>在各个事件的active monitor分散的情况下，区块需要被每个monitor读取解析以获取各自负责的合约事件，造成不必要的重复读取（如果链本身有针对事件的bloom过滤器可减轻此影响）。</li>
<li>极端情况下，例如所有应用恰好都通过同一个monitor创建监听任务，最终退化成前述的全局唯一active monitor。一种改进方式是，创建监听任务时monitor只负责创建<code>event</code>节点，但是并不把自己注册为active。所有的monitor需要监听<code>events</code>和<code>nodes</code>里所有节点，如果有新增/删除事件节点，或者节点动态加入/退出，需要执行rebalance重新分配（可以通过一个协调者来分配）。这个rebalance机制的可靠性实现会相当复杂。</li>
</ol>
]]></content>
      <tags>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约预言机</title>
    <url>//articles/sc-oracle/</url>
    <content><![CDATA[<p>合约运行的可回溯重复执行及执行确定性要求，合约执行过程使用的数据必须被记录，可以采取记录在链上预言机合约内（公链），或者是合约的含预言机返回值的执行凭证（联盟链，用于事后审计）。对于前者，使用链上预言机主要分成三种方式：</p>
<ol>
<li>“立即读取” ： 用户合约直接访问预言机合约读取所需数据。（预言机数据可能被更新，导致多次读取不一致。需要结合数据版本等机制保证，较为复杂）</li>
<li>“订阅发布” ： 关注预言机数据的变化。可以预言机合约在数据变动时，同时发出合约事件。链下应用监听特定的合约事件，然后相应的调用用户合约。本质上还是链下发起的上链交易，区别只是触发时机。</li>
<li>“请求响应” ： 由用户合约执行时组装请求（常见的HTTP请求）向预言机合约请求数据，并且附带回调API。链下的预言机应用监听预言机合约，向外部系统请求数据，然后回写到预言机合约（上链或分布式账本）。然后预言机合约将改响应数据回调前述的用户合约声明的回调API。<em>可以是用以GET获取数据合约内计算，也可以是POST链下应用系统进行复杂计算，获取计算结果。</em>此过程的关键在于保证传输过程的完整性真实性，即防止预言机合约的传递篡改以及数据源作恶。</li>
</ol>
<span id="more"></span>
<p>以下介绍在Ethereum上得到关注较多的两个预言机，Oraclize和Chainlink。</p>
<h3 id="Oraclize"><a href="#Oraclize" class="headerlink" title="Oraclize"></a>Oraclize</h3><p><a href="https://www.oraclize.it/"><em>Oraclize</em></a> 中心化预言机的核心是使用了<a href="https://old.tlsnotary.org/"><em>TSLNotary</em></a> 协议来证明预言机合约的数据传递过程的真实性，即数据源确实来自于用户合约所想访问的特定服务及数据。算法的大致思路是，Auditor和Auditee通过混淆电路，不经意传输等方式，共享生成TSL协议里的通信信道的加密密钥。这样Auditee在不泄漏登陆信息等数据的前提下，有选择的向Auditor转发server端的response，同时保证转发的response来源。</p>
<div align="center" style="width:50%;margin:auto">
    <img src="/images/sc-oracle/tslnotary.jpg">  
    图1    TSLNotary算法
</div>

<p>在Oracilze的方案里，用户合约向预言机合约发送请求，包含要访问的HTTP服务地址路径，方法参数等。链下的Oralize预言机应用扮演Auditee角色，监听链上预言机合约，充当proxy进行HTTP数据请求。同时，在AWS部署了云实例充当独立第三方Autidor角色，此云实例的可靠性安全性可用性在此方案中非常关键。考虑到Proof的体积可能会很大，对于像Ethereum这种对数据量计费的方式，链上校验代价昂贵，可以选择将Proof上传到IPFS，链上记录Proff的IPFS地址，作链下的校验。当前，链上校验的ProofShield方式仍然处在实验阶段。</p>
<blockquote>
<p><a href="https://ethereum.stackexchange.com/questions/201/how-does-oraclize-handle-the-tlsnotary-secret">How does Oraclize handle the TLSnotary secret?</a> ： 利弊分析，对于AWS的autidor实例和server端安全性的顾虑。提到对于有限参与方的场景（例如联盟链），可以自己扮演auditor和auditee的角色以规避风险。</p>
</blockquote>
<h3 id="Chainlink"><a href="#Chainlink" class="headerlink" title="Chainlink"></a>Chainlink</h3><p><a href="https://docs.chain.link/"><em>Chainlink</em></a> 从中心化到分布式分为三种模式。</p>
<ol>
<li><p><a href="https://docs.chain.link/architecture-overview/architecture-request-model?parent=gettingStarted">Basic Request Model 基本请求模型</a>。</p>
<p> <img src="/images/sc-oracle/chainlink-basic-request-model.png" alt=""></p>
<p> 类似于Oraclize的模式，链下的预言机应用监听链上预言机合约事件，代为发起链下HTTP访问，转发响应结果至链上。但此方式并没有考虑和解决链下预言机的作恶，链下预言机为中心化架构。只能通过对同一个数据多次请求不同的预言机服务聚合来减轻其问题。</p>
</li>
<li><p><a href="https://docs.chain.link/architecture-overview/architecture-decentralized-model?parent=gettingStarted">Decentralized Data Model 分布式数据模型</a>。针对对是数据feed流订阅的方式，主要是价格，利率等不断变动并且实时性要求高的数据。官方提供了部分<a href="https://docs.chain.link/data-feeds/">常用feed数据</a>。此模型链上主要有三种角色。</p>
<ul>
<li>Consumer Contract消费者合约。feed数据使用者。</li>
<li>Proxy Contract代理者合约。指向aggregator合约地址。consumer通过proxy间接访问aggretator。间接访问使得consumer可以保持稳定的配置proxy合约的地址，aggregator合约的升级更换不影响consumer的正常使用，保证业务连续性。</li>
<li>Aggregator Contrac聚合合约。链下各个数据源将数据发送到此合约，此合约进行数据聚合，例如选择大多数的值，尽可能的保证数据的准确性。有两种链下触发聚合轮次的触发时机。<ul>
<li>Deviation Threshold: 当前值偏离链上的最新值一定的范围。</li>
<li>Heartbeat Threshold: 定期更新。</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://docs.chain.link/architecture-overview/off-chain-reporting?parent=gettingStarted">Off-Chain Reporting 链下聚合报告</a>。对上一点的改进，将链上聚合转换成链下聚合。具体的方案是在链下p2p网络里，多个数据提供节点提供签名数据，由leader节点作为协调者作聚合，将聚合结果发还各提供节点进行确认并签名。然后随机选择一个节点将此数据上链，由aggreator合约来验证此数据的有效性。链下节点监视上链结果，防止所选节点上链失败。此方式可以减少上链交易的数量，同一个数据只需要上链一次；聚合无需等到超过阈值数的节点上链，缩短聚合时间，从而也可以容纳更多的数据提供源节点，增进数据可信度。</p>
</li>
</ol>
<blockquote>
<p><a href="https://stackoverflow.com/questions/72318627/chainlink-newbie-doubts">Chainlink newbie doubts</a>: 对chainlink局限性的分析</p>
</blockquote>
<hr>
<p>预言机的时效性和准确性要从数据源和链下预言机等两个方向来保证。数据源的可靠性常规方法是通过增加数据提供源，链上进行的聚合，抵御拜占庭节点。或者链上预先配置可信源，数据进行签名，链上验证数据源身份。需要注意的是，传统网络世界里的CA证书认证体系无法直接适用。对于HTTP请求这类非固定访问地址数据，需要链下有可信节点（Chainlink是完全信赖链下预言机，虽然可以通过请求多个预言机来相互校验来提高可信度；Oraclize则是依靠可信的中立审计者）。在联盟链的场景下，各方的身份都可以通过身份合约配置和数据签名校验，多方响应数据聚合能相对有效的抵御拜占庭节点。</p>
]]></content>
      <tags>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>CBDC系列（2） - 数字欧元研究报告（分层架构）浅析</title>
    <url>//articles/digital-euro-tiered-model/</url>
    <content><![CDATA[<p>基于欧央行ECB于2021年7月公开的技术研究报告<a href="https://www.banque-france.fr/sites/default/files/media/2021/08/02/821220_digital_euro_en.pdf">Digital Euro experiment Combined feasibility – Tiered model</a></p>
<p>欧央行探索数字欧元技术实现可能性，关注记账账本，隐私与反洗钱，流通的限制，终端接入4个方面。从中心化向分布式渐变的方向，总共分为以下4个思路：</p>
<ol>
<li><em>scale the existing</em> : 基于当前TIPS（TARGET Instant Payment Settlement，零售快速支付系统），中心化管理</li>
<li><em>combined feasibility</em> : 中心化系统结合分布式平台（例如分布式账本DLT）</li>
<li><em>a new solutiion</em> : 基于区块链，固定面额的token价值模型</li>
<li><em>bearer instrument</em> : 硬件支付设备，支持离线支付</li>
</ol>
<p>本方案是思路二 <em>combined feasility</em> 提出的分层架构，第一层是欧元系统运行的中心化账本，由欧央行通过欧元清算系统发行给直参；第二层则是由运营机构分发给直参，间参和个人或者公司等终端用户。这个方案带有试验性质，目的就是为后续的讨论和政策制定提供参考。</p>
<blockquote>
<p>TARGET2 :  第二代泛欧实时全额自动清算系统（Trans-European Automated Real-time Gross settlement Express Transfer system）</p>
</blockquote>
<span id="more"></span>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol>
<li>数字欧元（DC）是欧央行的直接负债。</li>
<li>二层系统满足互操作性，受监管中介机构（supervised intermediaries, 例如银行）负责面客，在该层为客户开户（基于账户体系）开钱包（基于价值体系）。统一应用编程接口（common API）方便外部接入，保留足够的弹性给将来的业务创新和解决方案。</li>
</ol>
<p><img src="/images/digital-euro-tiered-model/two-tiered-model.jpg" alt=""></p>
<p><img src="/images/digital-euro-tiered-model/composition-of-each-tier.jpg" alt=""></p>
<h3 id="发行过程"><a href="#发行过程" class="headerlink" title="发行过程"></a>发行过程</h3><ol>
<li>TIPS在试验方案中临时充当一层系统。中介机构通过在TARGET2/CLM的清算账户向TIPS的清算账户转账。</li>
<li>TIPS一层系统在相应的中介机构的DC账户生成对应数量的DC（3）。</li>
<li>中介机构通过报文等通信手段，请求一层系统将其DC账户里的DC转移到二层运营系统的中转账户。（3-&gt;4a）</li>
<li>二层运营系统与一层系统连通，DC从一层系统里的中转账户转移到二层系统里的发行账户。（4a-&gt;4b）</li>
<li>二层系统的发行账户转移到二层系统里的中介机构账户。（4b-&gt;5）</li>
<li>中介机构账户转移到客户账户。（5-&gt;6）</li>
</ol>
<h3 id="赎回过程"><a href="#赎回过程" class="headerlink" title="赎回过程"></a>赎回过程</h3><p>与发行镜像。</p>
<h3 id="交易过程"><a href="#交易过程" class="headerlink" title="交易过程"></a>交易过程</h3><ol>
<li>两个账户属于同一个运营系统的，则通过二层里的收付双方各自的中介机构的二层账户结算。</li>
<li>跨运营系统的交易，付款人的DC账户先借记，其中介机构的二层账户贷记。然后该中介机构将DC转移到该二层运营系统的发行账户。然后此中转账户在一层内转移到收款方所在运营系统的中转账户，后续类似于发行过程。（评：引入中介机构账户的转发，从方案描述看，运营系统的发行账户不直接与客户账户发生联系，而必须通过中介机构账户。即使该运营系统的实体同时也是中介机构，也需要通过自身的中介机构账户。此举保证了账户的划分职能的单一性，值得学习）</li>
</ol>
<ul>
<li>总的来看，二层<strong>运营系统</strong>与<strong>中介机构</strong>有一定的区别和独立性，运营系统偏向于技术，中介机构则更多关注业务。</li>
</ul>
<h2 id="主要结论"><a href="#主要结论" class="headerlink" title="主要结论"></a>主要结论</h2><h3 id="1-账本选择"><a href="#1-账本选择" class="headerlink" title="1. 账本选择"></a>1. 账本选择</h3><ol>
<li>欧央行负责发行，从而可以控制发行量和流通量，同时与数字欧元是欧央行的直接负债相符。</li>
<li>数字欧元通过二层中介机构可以很容易与传统银行账户，商业票据等互换，涉及到中介机构在TARGET2的清算账户和一层DC账户。交易可以满足即时结算，如果是同运营系统则是本地结算，如果是跨系统，则是通过一层账户。</li>
<li>二层运营系统不预设技术路线，足够弹性，二层可以发展各自的特色业务创新应用，已经采用不同的技术架构以及创新。可以是中心化账本，也可以是联盟链，私有链等分布式账本。</li>
<li>全局的容错避免单点故障。一层的故障，不影响二层运营系统内的DC继续交易；单个二层运营系统的故障，也只限定在当前系统。</li>
</ol>
<h3 id="2-中介机构的角色"><a href="#2-中介机构的角色" class="headerlink" title="2. 中介机构的角色"></a>2. 中介机构的角色</h3><ol>
<li>二层中介机构负责数字欧元的流通，用户的合规管理（KYC，AML，CFT）。技术上可以将合规规范编程到账户/钱包粒度。</li>
<li>允许第三方提供账户/钱包增值服务。例如用户授权管理聚合多个账户/钱包，发起交易（钱包体系下管理私钥）。架构里统一的common API，使得第三方应用可以满足一处开发，到处适用，与账户/钱包的具体的归属运营系统无关。</li>
<li>同时，中介机构可以代表其客户部署智能合约。与第2点提供了两种可编程方案，分别是common API + 第三方服务商，以及smart contract + 二层中介机构。</li>
</ol>
<h3 id="3-隐私与合规"><a href="#3-隐私与合规" class="headerlink" title="3. 隐私与合规"></a>3. 隐私与合规</h3><ol>
<li>隐私合规与余额，交易限额是相关的。有限的AML/KYC机制可以方便非本地居民使用DC，例如基于价值体系的匿名P2P支付交易。</li>
<li>二层中介机构负责合规管理。在客户开户时，应该要做开户检查，保证用户在二层运营系统里账号/钱包的唯一性（或者是关联钱包等，将新开的账号钱包与用户已有账号关联起来）。这样避免用户通过多开账号来逃避限额，逃税等。这样的信息共享需要使用适当的隐私保护技术，符合GDPR保护条例。</li>
</ol>
<h3 id="4-限额"><a href="#4-限额" class="headerlink" title="4. 限额"></a>4. 限额</h3><ol>
<li>数字欧元可能会导致存款搬家。限制账户余额以及转出交易额是其中一个应对方案。同时也是有助于AML/CFT。</li>
<li>账户分级，可以针对不同的账户设定差异化的限额。</li>
<li>账户余额限制可能会导致在收款时超过限额。有两种方案可以解决：</li>
</ol>
<ul>
<li>转账失败，返回错误信息。缺点是当收款人的余额是机密信息时，可能会暴露其隐私。</li>
<li>DC账户绑定传统银行账户，超出限额部分自动转存到银行账户。缺点是增加结算过程的复杂性。</li>
</ul>
<h3 id="5-计息"><a href="#5-计息" class="headerlink" title="5. 计息"></a>5. 计息</h3><ol>
<li>警惕引入DC可能导致银行系统的去中介化，以及阻碍货币政策的传导。</li>
<li>对于中介机构而言，如果DC参照支票不计息，则在负利率的时代，中介机构倾向于持有超量的DC来避免存款准备金的负利率影响，从而影响负利率的货币政策传导；如果DC参照存款准备金的负利率政策，则中介机构会避免持有DC，从而导致DC的流动性不足。</li>
<li>提议的分层计息方案。对中介机构持有的DC设置阈值，低于阈值的部分视为现金不计息，高于阈值的部分视同存款准备金。</li>
<li>对于终端用户，超过阈值的不计息或者正利率的付息，超过的部分则支付更低的利息，有可能是负利率。</li>
<li><code>To complement this technical analysis, thorough impact assessments of a digital euro on the transmission of monetary policy should be conducted.</code> 以上仅仅是理论分析，具体的政策还需要深入研究。</li>
</ol>
<h3 id="6-可编程性"><a href="#6-可编程性" class="headerlink" title="6. 可编程性"></a>6. 可编程性</h3><ol>
<li>条件支付：例如DvP, PvP等</li>
<li>货币的属性可编程： 例如利率，限额，收款方的黑白名单等</li>
</ol>
<p>总而言之，这个方案与公布出来的双层运营架构体系的思路很多地方类似，也不预设技术路线。从技术角度看，整个架构的各个角色，账户划分独立清晰，同时也保留最大限度的灵活性。最大的问题，可能还是在于如果处理好跟传统银行账户体系的关系，特别是涉及到计息，存款搬家，机构盈利可持续运营等。更多的政策性业务性研究，可以参看ECB在更早期2020年10月公开的研究报告<a href="http://www.zentral-bank.eu/pub/pdf/other/Report_on_a_digital_euro~4d7268b458.en.pdf">Report on a digital euro</a>。此技术研究报告也是基于此的实验报告。</p>
<h4 id="更多参考："><a href="#更多参考：" class="headerlink" title="更多参考："></a>更多参考：</h4><blockquote>
<p><a href="https://www.ecb.europa.eu/paym/intro/news/html/ecb.mipnews221221.en.html">ECB publishes second progress report on the digital euro investigation phase</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>CBDC系列（1） - OpenCBDC项目浅析</title>
    <url>//articles/open-cbdc/</url>
    <content><![CDATA[<p>基于OpenCBDC项目（Boston Fed &amp; MIT联合研究项目，也称Hamilton项目）的公开资料：</p>
<blockquote>
<p>论文 : <a href="https://eprint.iacr.org/2022/163.pdf">A High Performance Payment Processing System Designed for Central Bank Digital Currencies</a><br>github仓库 : <a href="https://github.com/mit-dci/opencbdc-tx">OpenCBDC</a>  </p>
</blockquote>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>当前阶段1属于研究性质，更多是在于探索技术上的可能性，并不是一个即插即用的成熟方案。设计目标着眼于性能以及容错，同时保留足够的灵活性（不限定发行的方式，支持中央银行直接零售发行，也支持类似于数字人民币的批发-零售双层运营模式）。同时，对于其他的课题，例如隐私保护，风控，合规，监管，商业化等也没有深入讨论。（对于隐私保护，论文里提到最安全方式就是从交易源头开始尽可能的少收集数据，这个也在阶段1的设计考虑中。<em>当然，隐私保护与监管风控的目标在一定程度上是对立的。</em>）这些问题会在阶段2里阐述。</p>
<h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol>
<li>UTXO模型。用户持有数字钱包，使用私钥签名的方式来消费。</li>
<li>分层解耦。将交易的合法性验证和资金的存在性验证分离，只有合法性验证才需要交易的细节信息，最小化交易处理核心层的存储（不涉及用户个人信息等）。核心层简单的只做纯粹的资金交易（UTXO的生成和销毁），保证稳定性和性能。货币的扩展功能做在外层。</li>
<li>基于UHS(Unspent funds Hash Set)和类似比特币交易的数据结构。兼容未来譬如类似地添加锁定脚本等，而无需修改UHS交易核心层的前提下实现扩展功能。</li>
</ol>
<span id="more"></span>
<h3 id="账户模型-VS-UTXO模型"><a href="#账户模型-VS-UTXO模型" class="headerlink" title="账户模型 VS. UTXO模型"></a>账户模型 VS. UTXO模型</h3><ol>
<li>UTXO有更好的执行并行度，账户模型需要锁定账户。OpenCBDC选择UTXO模型。</li>
<li>账户模型更具易编程性。</li>
<li><code>Account banlances are more fungible, which is an important property for money.</code></li>
<li><code>It might be useful to consider an account balance data model which minimizes the amount of data stored in the transaction processor in the future.</code> 未来可能尝试对比账户模型。</li>
<li>两种模型都支持账户模型式的用户界面UI。</li>
</ol>
<h3 id="UTXO数据结构"><a href="#UTXO数据结构" class="headerlink" title="UTXO数据结构"></a>UTXO数据结构</h3><p><code>utxo := (v,P,sn)</code>    </p>
<ol>
<li><code>v</code>: value，金额。</li>
<li><code>P(tx, wit)</code>: predicate. <code>tx</code>: 消费此UTXO的交易，<code>wit</code>: witness，见证。在支持数字签名的方案里<code>P</code>硬编码pk，并且<code>P</code>校验<code>w</code>包含该pk的签名。在只支持数字签名的方案里，<code>P</code>可以近似等同于<code>pk</code>。</li>
<li><code>sn</code>: serial number，全局唯一的序列号，用于保证UTXO的唯一性，防止重放双花。<code>our system assigns each UTXO a serial number by deterministically hashing all the corresponding transaction’s inputs, as well as the output UTXO’s encumbrance, value, and its index among all outputs.</code> 铸币的<code>sn</code>选择为均匀分布随机数或者全局单调递增数。</li>
<li>交易不具有延展性（non-malleable），可参考比特币，防双花。<code>we require signatures to cover all fields of uniquely-encoded transaction and derive UTXO serial numbers from the same fields (plus, output indexes).</code></li>
</ol>
<h3 id="交易系统的双层设计思想"><a href="#交易系统的双层设计思想" class="headerlink" title="交易系统的双层设计思想"></a>交易系统的双层设计思想</h3><ol>
<li><code>transaction-local validation</code>交易合法性验证。主要校验数据结构，输入输出金额相等，签名等。无状态，计算密集型。生成UHS，即cryptographic commitments <code>h := H(v, P, sn)</code>。使用hash值代替交易本身，利用hash碰撞极低概率的特性。</li>
<li><code>existence validation</code>交易引擎。存储UHS，执行实际的swap操作（UHS的增删，即对应着UTXO的生成销毁）。存储密集型。  </li>
</ol>
<h4 id="设计关键思考："><a href="#设计关键思考：" class="headerlink" title="设计关键思考："></a>设计关键思考：</h4><ul>
<li>按需弹性横向扩容。</li>
<li>节省存储空间。交易引擎只存储32字节的hash值。</li>
<li>弹性设计。交易引擎的UHS结构也可以用于账户模型。<code>The UHS makes no assumptions about what hashes represent, and this data structure is not limited to UTXOs; it could be applied to a digital currency with balances or some other application that requires atomically swapping hashes.</code> <em>账户模型下具体如何对应UHS的增删仍然有待观察，一种方式是账户模型下记账关联UTXO，由合法性验证sentinel来拆分合并UTXO</em></li>
<li>隐私保护及监管审计。交易引擎功能单一，UHS没有包含交易细节。这部分功能放到sentinel等外围系统，或者是使用隐私计算。例如客户端做本地化验证，提交零知识证明和UHS，而不是原始的交易本身，最大程度的保护隐私。</li>
<li>编程性。并发处理下，UTXO相对账户模型具有一定的优势，账户模式需要锁定账户，UTXO锁定的粒度更小。但是，UTXO要实现复杂的智能合约难度更大，需要在后续智能合约触发使用UTXO时知道状态转移链，以及每个状态的UTXO才能构造交易。而账户模型仅仅需要账户标志。</li>
<li>UTXO的获取。UTXO记录在用户本地，交易完成需要通知收发双发。用户丢失UTXO，或者更换设备UTXO转移失败，都需要恢复。但是当前设计下整个系统没有记录UTXO，需要第三方系统协助。</li>
</ul>
<h3 id="交易模型"><a href="#交易模型" class="headerlink" title="交易模型"></a>交易模型</h3><ul>
<li><p>交易数据结构<br></p><div align="center" style="width:50%;margin:auto">
  <img src="/images/opencbdc/tx-format.jpeg">
</div><br>  UTXO的序列号<code>sn := (txid, idx). The first component, txid is the unique transaction identifier: the cryptographic hash of the Mint or Transfer transaction that created this UTXO. This hash covers all input UTXOs, output encumbrances and values. The second component, idx, is the particular output index, i.e., first, second, etc, output of the transaction.</code><p></p>
</li>
<li><p>交易引擎的存储及原子性swap处理<br><img src="/images/opencbdc/compact-tx.jpeg" alt=""></p>
</li>
</ul>
<h3 id="用户体验及交互场景"><a href="#用户体验及交互场景" class="headerlink" title="用户体验及交互场景"></a>用户体验及交互场景</h3><ol>
<li>交互场景收发双方需要协商，发送方需要得到接收方的pk。接收者需要收到output utxo，并且确认这笔transfer交易成功，否则这笔资金有可能无法被使用。<code>The recipient should not consider a payment “complete” until they have received both a confirmation from the transaction processor and the full preimage data for their new outputs.</code></li>
<li>非交互的交易场景，例如扫描静态二维码慈善捐款场景，交易系统先存储这些output，接收方后续查询。需要系统存储pk和utxo的对应关系，交易间的关系容易被追踪，有隐私泄露的隐患。  </li>
</ol>
<h4 id="交易系统确认方式"><a href="#交易系统确认方式" class="headerlink" title="交易系统确认方式"></a>交易系统确认方式</h4><ul>
<li>交易执行成功后，交易系统对结果签名，返回发送方。发送方直接中继给接收方确认。</li>
<li>构造交易时，交易结构增加<code>callback endpoint</code>。交易系统执行成功后，回调此endpoint通知接收方。此方案依赖于callback endpoint的可用性，暂时不可用时需要支持降级查询功能，增加了系统的存储需求，也就记录交易主体和交易本身的关联关系。<em>本方案里很关注隐私保护的考虑，也就是尽可能的减少交易可被追踪的可能性。此确认方式有所冲突</em>。</li>
</ul>
<h4 id="交易方式局限性"><a href="#交易方式局限性" class="headerlink" title="交易方式局限性"></a>交易方式局限性</h4><p>当前 <strong>无法</strong> 支持由收款方主动发起（例如代发工资，划扣生活缴费等场景），因为构造交易需要指定input utxo并且发送方签名，在缺少发送方的知识和私钥的情况下，难以构造合法交易。<em>账户模式以记账模式比较容易实现。</em></p>
<h3 id="交易系统架构设计"><a href="#交易系统架构设计" class="headerlink" title="交易系统架构设计"></a>交易系统架构设计</h3><h4 id="1-全局有序方案"><a href="#1-全局有序方案" class="headerlink" title="1. 全局有序方案"></a>1. 全局有序方案</h4><p><strong><em>TBD</em></strong></p>
<h4 id="2-两阶段提交方案"><a href="#2-两阶段提交方案" class="headerlink" title="2. 两阶段提交方案"></a>2. 两阶段提交方案</h4><p><img src="/images/opencbdc/2PC-architecture.jpeg" alt=""></p>
<ul>
<li>批量执行。两阶段执行结果是具备确定性的，批量内的交易可能会因为相互冲突导致部分失败。</li>
<li><p>集群容错。每个组件都使用Raft协议保证数据一致性。</p>
<p>  <em>工程实现上仍然还有很多细节需要考虑设计，极端场景，边缘场景等，这些无法在论文里展开详述。</em></p>
</li>
</ul>
<h3 id="未来的工作"><a href="#未来的工作" class="headerlink" title="未来的工作"></a>未来的工作</h3><ol>
<li>隐私保护，费用，风控，合规</li>
<li>中间机构（例如商业银行）的作用</li>
<li>离线支付</li>
<li>防止DoS攻击</li>
<li>丰富使用场景，提升用户体验。通知收发双方确认交易完成和隐私保护间的平衡</li>
<li>提升系统性能（先消费input UTXO，延迟生成output UTXO）</li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol>
<li><p>CBDC领域里UTXO模型有局限性，某些场景下等同于账户模型。</p>
<ul>
<li>正如论文里提到的用户体验，如何将可用UTXO通知到用户，并且需要能支持查询，恢复。这就涉及到UTXO的存储和用户关系（可能是pk）的管理，这就类似于账户模型了。一旦pk关联的用户被获得，就完全退化为账户模型。</li>
<li>目前难以实现由收款方主动发起且付款方一次授权后续无需参与的交易，因为前提是需要获取到付款方的可用UTXO。可以由货币发行方统一管理和记录，用户和UTXO的对应关系，但这一定程度上也等价于账户模型。或者授权第三方，这需要付款方及时将可用UTXO发送到第三方，保证充足的头寸。这些方案都需要将私钥托管。这就涉及到隐私保护和支付安全的问题，虽然可以通过签订协议，以及为不同的场景生成不同的密钥对来一定程度上保护。账户模型下，也可以通过开立专用账户达到同样的效果。</li>
<li>CBDC领域里差错处理是非常重要的，当前常用的账户模型下货币记账方拥有更多的控制权，使用冲正等方案也比较成熟，能有效避免资损。相对来说UTXO模型更加依赖即时清结算的确定性。</li>
<li>类似账户模型的分级管理等风控手段，业务规则在UTXO模型下可能难以使用。</li>
</ul>
</li>
<li><p>智能合约与UTXO结合更能达到对支付的有效控制。<br>UTXO模型下，智能合约的代码是内生在UTXO数据结构本身的（witness字段），类似于比特币里的锁定脚本，智能合约控制着UTXO是否能被消费。而相比之下账户模型下智能合约的执行和记账本身是分离的，理论上存在绕开智能合约直接改动账本的可能性。当然，witness字段必须尽可能的少占据空间，因此也限制了智能合约的复杂性，同时能够通过脚本语言做到图灵完备，或者简化的满足CBDC领域的需要，这点仍然有待更多的研究。</p>
</li>
<li><p>隐私和监管的平衡。<br>UTXO的隐私性更强，监管难度更大。由于用户理论上可以无限的自由生成公私钥对，并且生成的密钥对里无法反向推出用户信息。再结合混币器混淆等技术，UTXO的交易路径也很难被追踪，相比账户模型，其隐私保护的能力更强。同时从监管角度更难追踪交易流向。对于涉及到反诈骗反洗钱反恐怖融资等场景，监管当局对风险交易和账户及时的识别和处置风险难度很大，手段较为有限。账户模型下采用冻结账户和资金等方式则较为简单有效。当然，这也是一把双刃剑，在国际纷争中也很容易成为“制裁”的武器。</p>
</li>
</ol>
<p>总而言之，当前金融系统采用账户模型，这一套运行体系已经很成熟了。要在货币领域转到UTXO的方式还缺少可以借鉴的成功案例，在讲求稳定的金融领域，这个目前还只能算是很初级的研究阶段，距离落地还有很长一段距离。当然，UTXO还是有很多优点，例如与智能合约的结合实现更有效的专款专用和监管。但可以确定的是，加密货币领域单纯的UTXO模型是无法完全适用于CBDC领域的。在当前的传统账户模型下，如何利用UTXO模型的优点，这是应该着力探索的方向，大概率是账户模型和UTXO的有机结合。至于OpenCBDC项目的第一阶段，尽管中心化系统，没有使用区块链，但是借鉴和组合了当前很多区块链和分布式应用领域的技术，本身并没有特别多的亮点，除了引发对CBDC的数据模型的思考，仅仅是因为其背景和宣称的实验室测试数据而受人关注。很多工程细节都没有考虑，这些在一定程度上肯定会影响系统的复杂度和性能。还是期待下一个阶段能有一些更有创新性或者更接近落地的成果。</p>
<div align="right">
    To beloved Hannah <span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>
</div>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly 2.0新特性</title>
    <url>//articles/whats-new-in-wasm-2-0/</url>
    <content><![CDATA[<p>官网： <a href="https://webassembly.github.io/spec/core/appendix/changes.html#change-history">Change History</a></p>
<ol>
<li><p>Multiple values</p>
<ul>
<li><em>Function types allow more than one result</em><br>  适配go语言等函数多返回值的特性。</li>
<li><em>Block types can be arbitrary function types</em><br>  控制块带参数，适配C语言等内联函数的展开。Wasm1.0里调用内联函数使用的是<code>call</code>指令。</li>
</ul>
</li>
<li><p>Reference types</p>
<ul>
<li><em>Added <code>funcref</code> and <code>externref</code> as new value types and respective</em>： 表元素增加新类型<blockquote>
<p><code>externref</code> allows modules to hold references to objects provided by the host environment; in other words, you can pass a JavaScript object to your .wasm module. The .wasm module can’t really do much with the object via the type. What’s more important is that the module is holding a reference to a garbage collected object on the JavaScript heap. 持有外部引用，为将来wasm引入GC准备。 参看<a href="https://www.oreilly.com/library/view/what-is-webassembly/9781492076902/ch04.html">Upcoming Features and Proposals</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Bulk memory </p>
<ul>
<li><em>New memory instructions: memory.fill, memory.init, memory.copy, data.drop</em><br>对应C里的<code>memcpy</code>, <code>memmove</code>等，目的提高处理大块内存的性能。Wasm1.0里使用<code>load</code>, <code>store</code>指令操作内存，只能处理基本类型的数值。</li>
</ul>
</li>
<li><p>Multiple table<br><em>coming soon</em></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>监管科技（1） - 数据采集</title>
    <url>//articles/suptech-data-collection/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="146e9ef62fa6a93a3ae39abfd32cacd161146cf6fe18b069a147d9594d60f796">3175488eedc729df0c7d358c640da99e5db97a13f852973918f00ac21570e613274c023f24fb0816aae305d8ec69c5952ad4b24e77da37571698484b461fdacab92854ece071879549e016da92c9eec9343f77c437aee31c76a455ea386d199294abfd2897004d87a4b1be0d48b4c86b9518e151d6273629cb953ee6602e3a0f1d6979e254bb57558ddc9999a132dd156fb6ac9ed43dc6696784c22a76c9b60f4ea86a7fb1a77a572dbb3924a24887384816018218072e0dfcd5397d57e6604f67a9fa75a869ff80e71a7da5e078171f38dec0efd899f508e582ba62e6ab223ce8074d538c617caa1408cf4635a0d5eed0ef978044450209de24b3c513d9ad5c3431a90babf1df6401ea2ad86b3ef120a60249c165f8737350330abc255ae97ce8c9cc90d349b95393935748c2b72960af43b387d6281b56498c188cdedab89fe22cd6f3ca346f8dfc547a4e6303d4677470ba7f7d43e2824f650865c9dc32b8fc79842349f9dc0f3507a47cc939cd4b951c8dae802af94cbdfa363adac97d2afb2e42469a1e3217a34989f90b21b5d5bdece1759a4924c05f02f338f90688729426de7ea04bc361d3e6bc15d0a15df3aa1204684ae94cbf13542913b0e2b75efcbafc2a89be53770a861de138362970806d5799d349be5c9ee5e589177622ca7a74841b691fe3a8f88b279d1c6c43644b1e6150e4da1e877cd1ec5e3bdf22c8541befe8340f5d6dbc1333faa68226a7f2bf62cd31b389ff531a5444670417bdfc09ea779ba0e6e3fe0c38a35952f0a475f1c32bc48afed22219cb62531df18cb889e060901fb0b458139cb1880f82a7a02644d301b88d55a15168fe1c8e620ad0b06cd3970b1f876cd28b44af984d442e85198a00d89a844287ad35d659c5783433276a9fa476f4d961da4bc066ec97e82d5ae2a57f176a26e6eec43e15cf667579372a87845efd69ddf22911b002a4e9eba9da1a76591f3f6c9444b88f42f3d126c8f82a9d035a2c413326923e61af7084a57c9a2bd88d20d67a9351ff3d6a988b2af3d8c55cb2923b0eec27a860bc47f323a3b221a57ab2aa07ae03e206ce049ae06f4502097f12c7cb07313df574e31e792f57aee1c69b97221883972eb25b5789dfd843de01e17ed5967cfce32ea991b04f3add87e80ca9d1f3ebc03befb9e43091a5284234ac0b4ccafb29b7952b2ba60249e967d9d1e1af4dc67e7b15f875ab7dc80be21c223fb06ebe0dbe5e62425d6dc5acb0757bf1f26df44fedfd5e440332b9bc8e31c585604c61944b1574a441c679bb4e01579c8cb48ba37087c9bcbd53c72aa58ed682cf9ed60834722cb854bdbbb341439ee9ffadf82c53c13cb4c7cee60f5a5fa727f17129b821a08486e709e0cff7c1915d7dc5d8d227013419d4977c27db7d6acf15495ba8421deb4fd75448ff9da6591f34e55ad833e6cbe2158575899c248ce87d9c09b58dbff98e866b401128ae03c3687fd0b22bb1aee8b7f65028eb9dd37212134f9e32a076163592e39ad12b8067845161470f6edfa0954b8d02bd6e7ca1babaf10fbe458a4ff060a379961f7d6464392486228e0c1e58713d0dd3a43c19e18753acf32c38862cf14a17f20d12ae2f9ab18a8f58bf5d7dc89f01d23632e354f04dabdec1fee69d09556564d1f6da2d7e2a3f13cf1d3e7e40c215b9cf43f06f6c5f833136263388e5a5ca0153fc91754980ea5fa2d6448c0fab93c4ef3e11f5d3cb2dba6319f8140ae698f909ef7100efc74db7111ad960301d6b137a4676138d2e26178d63cbc3cbf2e16be06a19217843a1ccf0d894acb14091a96b3616db67e35a9830133a80326d62c79416bb6cf3518b8896ed4dde453a976898da6fde9f8223a87f0506c1eb2b08310e9fc5d19af925d893e7c43d39ed995a78ad79ea420759f30bd3c95f1283d1108efd19fa0d188caf8113907ecebce567036aaba8fab178ed55ce8988db40fb6be5947c29a6dea6e2f0ee3221f740edc6138ff32f54451a7bc3609ab7e104c98c0210be7c4fae0bb56d5702083cb7f3b7c8dcf65dde94a3cd05ce0569605668384f36d22ef705ab1f55372f103410d0b522a03e37773af2b5a3d388f47b35c5aa4dd41e064c3dd9ced86989d674bd2c9dac9191eb2f16529c146deb17423dd3db01ad24a296eda9b500efba74c63592a07ea11e3cff34b29f17834f7381529a51d1e1a1190ba66ab2fda402d00ce14609b6b8f26dfb37ef3942e4361986d83b308568cb8db2c02558a231eda1fee5f3f6e000081135c2e5e40bf41a50c3b7cefacb652a64f12c4736ba24dc2e684f71ecd218c5eb83e8faf395e18d81a1cb5474f1b783ca7bcdcd73bf182670cb27baed4c4bc7a66e3b621541380e393b3c9af466a625b3ec5a379b0284fbc9e9b04ab99fccc2671b8054dd8d9749c9e420c6c77eb682a7f279457978938b19d03ddf0419e317aff42380cd4dc4ae7073d1cdb139e61077a33c90d7c02c8fe5fd9d56f845e0d224e6034b23f2d25c5dee1cdaace45909b1721bd37f9ba429d34517559c00c27f96775773b00b8816f00649719a979c41d02d1c7c7fba47cf154747900d9ab55e325fa02f966cec07c65126ccf3c5a0b3d715b8dacb87a05c72954aa92b77b32ccdd007d91606e0a163adb170659aa3048da02639891332b83ec10b664435955ffe6188ea444a1e411e8121da2bd36a5e2b569aaceb1b80aac900e4a8548acead46b88cd3b53b45e2cf24d8c16672cdc49a0f207f4231a6ca4ba16b31ac03568154c6d76fcc42f9af42d75225b5dedf33ea638c3b62ab264db9ffb23fdf926aec2ae59f2679177dad111112eda5d20a6fff1aa6ea5c4613767353a689cf893923c5bedb07d54c83755ca7baa870b37c1ce9f22d8c1e347dee3cb652ebaf8b4021b32858706b7a42e96772ed586cbe4f62be99a618f45ed89588fa01f268a2fa1d55935a81e6887e7e4b11fc461f281b6b425af079d7287fa37063fe8999bae335a2488dc45f5d955770be5cb87af7a1723cb84a5f985e5c5bcb09701c8a93c387a9c7afb9c9e4f6df6ee426325e7ea6c3b47a3b13068573e96e7a07c6a289649200218a43bc837fbb00ecb012fbb8586ab6f37a8db0e751596c3945d3d2253f8ef50a3fc71278b45a119408097e2094c0d40af7bd81051c6eef9d56d8154634313ad6bb61c5a178e5374fcbe6866b6190c166eb13955a0197cba8fc75957f87ce063f4e31cd21ce919ce0644dd36f3878972973c02fd95ca4b68b3dd4173e839640c3c8b6cd9121b36c2706de5fa84a81bb7044ff9a13b53c6e2c0c2ccf75b8795b2cde714b619d977775807bfd246f656d09c4c192be6d1d96fa6e5480af997d23fb8ea8995a4ba7fb2af8ee22cec49855177e62f45aae65d06c70f5f01497ac983109db0decd08ea95cb9e833b063d6ed7f11ee7daf83674ec596617975d3bb49ba756fe01dbf7522be47220e933efbd3ccd35f1415cd7fca45cd4875b81ca0865b756fe54ded9a5c71b938aa70ae1b6e229fba2f6664e50632dcb6512c44f093c237089eb8e54ab058c072dc18f050020da8c68724b0a04614bd7bfaa9e17594a2b1ebc40014f80583a1f0aed8d7365274e7acc3fc2bbeec6d5cd510f5a48e22ebe19d96054cdac5af6e8dbefefbdc944ec5c1a85c3b8b382077b98340b0d11a35bd2869cddc19de4d12abf6914481695d447739c6bd4814827ba2f742f07bc70501cb1654ca6a7f65178bee6acfb9a923737ab618750470ca5bf7977bffa178df7c85ae84b0ea531f7cde1a2daf505c41160f0dac9c98e540b5f311d0377ae15818ddc17f27fb04957fdf3f569f6db6e497a9ef7ac38c263a5ab7bc6c61ca935231d8d97fe5b2b50eeb171275ee2b30f1968f96bb9d0d6bbd2e02838070f001e755dd9fa8b76d5af83fc328dfc6a348018568273276c4c12313934830ef90a40a4b2250972baeceec5bb02a79ad2bb4964d118defa061f77927d0f72bc7ea1c4091a1eb52f6db7efa4fa307757de7f70d6f159f30e1b7e1d6abdf6bdc9dca4403fa323686556a5fef88030a864d18900f3758f0ddf09ae03cd67e144591f1726ce7f232bafe8ab7341945abc192321f6f177221215c4417334f5c8f5f352b0b0ecb74bddf4137c907cf467eff9e0b104cd27cf6f8b95f253dcad47ebdcef9c47a885a86dc27532cff146f8aa3e15756e484257eb91e18a0bb3aaa31e6c78e4e27efb1e048623bd2128523857e660e834bc608eb6b80a3550a5157c38c4d7ce0a4048fb8fa379dd6a9a211a62a23927679e5ba41a28c719f38ccf86d0aaf7bfe9e8bfa7f82b5e9c1783a2a69c5427b95b5b66e966cc75ea2b354646f942ae41af7e084a932f2071c3c40ccdf5c593114d55d469b5d67360464ae3725d7b0f077dbae2314819a28897cbf73f7557c2f1293b4a7bd23418dc30b1b019030519f75b9d540332bd051fe2542b624a15e702a038feb297d171a6cffa30f2d1cab598dbf3ec2c1370a93eff1397531c900554d518976fb18d06e16f03d1706151405d6728f5a281219a5fffc58539498234944756d47f8e09507063538754f492360566f21d0aa79975c5422667becbfbf9b614f4af44202ac471e60c2c4847764a559a18a53fc23261da6f5bd3caac2cbb76403cf556ee3842c7861d4cc62e8ba6d99c339c130586421c3e7b62df8873ecd74f308e7743be56caf3b7858dd89b1238d0e3a41d8643f18d44d87b9b97fbc7105dacda1e333db432e152e26172e629fd6a436fbecee94b194766d24db8543ac9497ca9beb27d74f15caa114f1e34e9fb0aa10d336236d45dc9ebcb913791fb5f5da774fe8ccaa5096ed940ad019b0c6239c914b5ea89d7a7b3d4b1406c9ac1367669b317c408bf8ac08a68330d93306142ae57022b0167527a47ccae7719ac5060559d5663ad3bc1863b23142fe4a64020250e001eca55870b26e80286ee25edbf9a093495911eb0c0ec21f54f1f0ba551dc587311e7f3b38e6d8177d23f99f0e04f10034f72b2a5d71e859fd69aaf28c0c86ff581a1c34d2540b5d9fa42fd0e82f406d4d472933b202db2b5ecd8fb26dd3925db92e9d1d5049325c9841e9371ed44f81d136e6e89ce1f84740e1da243b04b9fc7da79a701f59622794e3ba32e533ac2a384c91097badad2991ceab37bde4bdff006f5861ca001b4e04e8c9641a3e8c2158eae702478d9abba87e2f2c7b474fb669807dffd596e7c84ca143b9afa75ddca04eab0dfb773877a9b64e353e09af9065e9f569647cedb85b9b9733ef45631924458a70d73f1c56ca515fc504fa3ea2c7fc8f7db38693af11a16444eb362fc7905530555e593189bd1bd9bdca6a66cac45a19e7606d43a3c7807bda4813e9940e8084d043c76517c794a8ba3df285e6630460c28b15489a91e25bd3c9c373577a65b11451c37f43ece8a81eba3d78e9b40b6311ad8531d1923a4ea4e91951c4c6fc1515c02d1e1fa0bfb9e984dd45b242f496388abb4f626e7abe4dc458ae23edd4f3b9a3321be60103dc2b674d8411499da4c7c9b3b3e3d7897650f7bb5829ffdc027757d56af37eef341a7195a4a7dcb463381a39c1cb7573451c2e578d4ee595ba6d4a213aeb225ba7bf33bd7ef0b156682e43aa94f552dff30a3b41caf4a5f45e693272fccc6fb1f1336a3767055566e4fea1d851025e0058ffe1f79f0c27c056a5edbf9668ee0022a1be125f3518b2a6f9321eb553372893be6a24a1d8040a7d5e8691986b21afb7bdede9c02a892dbb845e8918cbe6dab699ae5ba1f3b6047cb92d24adfdc0e9c942438e73aeaa6345f815ba89b39e284e0d31a55d0295170f204a309631a54724e772e9a0ef960ccc10d2e02741fd480eed461d09264db8447280c0778f06a335e13bfd4b20cfd5fa905c43a00026cccefe6c595b980ddc27d36eae22c68cd588095c918ac627012f17787a6f3f102da8a1a98b795518b0907db4b4d3bbf3e872abc3f6532e2a2f259a9b6e1dd80d119860cede97942ed0dcea7607b295124051ca922e13de0e7f092f5808f4b0c5c58a692402faf84f68ced70a41412ae43b52c597810185409583a8707f66b8b5ff0c77f67569864cab3b1166bf6929aaca182595db2da327c8713df7bf3b061d74fbf3596fbae8dace3c63917fe7725c7c7c75aa430ae46910093653259abe1886b7fefea4d649b690aff729f10a2e9930bbb2b248713e0dfbf84279155479bb5ed9e3bd48c379d63d9c34d75b52f145de19b483fba766db8135a31dae9b5004d6b8510d4404b5ce7d33df261f21a84b7d94e50f8995ddf470fdc1715f772b8ee2922f64fd1c682ea9ed0c03857574b7646de8bcab4ec0a66e7970f388d41c29287c559ca3ea1a1fdbff0b3f3a433bed2b01ebfa6772055c07bc8d5b1e2cc1abef83d90de82714350662e72f5d881ba4ab1350359c4a24d4502388b33664c0eae183fad979e3cb5fd67910305d362065e4c4462c66aaaa60975162836cf98be34011802f46b089d9b4a5b84ab50fc6f0d7956a007cb0b9409cbcba153a04631066fe3a79a33b0f1cfa5186027097421d42811028847397923b7bd5558a7b785c66988d8680d326e0e73ad67554f77407252e82ecaad3059b144ab3a7276ffa679f53b9974d33438e462e57fbe8870f91dfa67ca6ce03be4b6a9323a36c37d848f6e19374fff692aaa07eceafa84c482a8ce74f85cc3dd300e8c9a0e6d586bf653d0aeefe656310eb89064109813897f9386f83b1d7f0520ec8fbce3067195184ede4af16793c26fc4c3703c7e1743700f25e81685a3468bd05cf3b399ba39a6e9bbaa258a0dbf5c26fb22ee0ba9940739de519129b27ec5ccf3eb0cd61b96c19a80ba713f88df7288bc3a14706afbb37486911f551983f6512f92e63018d7855220dc7ef72116c6d364b727415ad3637a603ad571177e45a087c3490f754f3e923093bf35ff768161b14b1b3a77a1a8fab92ed0313aeb1d6b08c1946af3c75bb9364fec781406d4edd9c747becacb5662e87a7656c79d98643ba7aecdd39fe7911c8c3b7bcbb9edd864b4589db4bd4c1022f7b5976e50a10ccfd7d4dcc9d4140ef9ba9ba69351b0c77478b6ac13df98fc2ad843ed9ccbfbaf3d7c1c54f3cf9efe4af606c4665f965f427701ad8c0338e509101aa89e85086197829df2f7a8ec0acac107459ec1d707dcb20c5073f229b4ea7da1afc3a1cbbd8b365a0827b2cda6ec96378e687518072afe525a6184badf5069552f167bf42065db49fd3e2b9ba5a2d7ff31ee1c87182612a266c8ec0125056b9b519f5269cae86e119bed46f13d844be1b3a701f247ebaacd0244e99d727d1551fcdc76e8d4faa41abcf6f750b8043389ef3e3d8bbb8d365f747b10cf8693077403ff9626bddce0d3ffd44817ae9d4b83fa79c1f1f9491f3bdcd064e56c23bda03653d1482542933356dc7e7e4486c4f7bd4bb7fac8e21eca4f29516fe552c916dc5da299bd13b0d5d4ec1cf331646f3003e28920296f41859c54385ed2304962e7e32a14cc584047635fa018291d4d0c948f433c3515934cfc0f612c62f7d98040f9d020fa872b097abd3ae1ad95afd94bd220c4fad19f4541805bf09913a93403301f00eb5816c76ac34aa86c1c1fb01bca9bffaa0c2e2d97ba6a4e3d67dd3e76bedde5f70bace853851769963d09d1bd2debd6765d2044529d268f831e24185d5893d99c21beb88e55fc2fa76a9aced348ceff95d346e2dcf9fdb713e7263c3321878d0fef7c2bb5c58d5b6e28c82a570ed6dff65c2be9e0a60b1c84b3fc212ed2b36081aba47225ff5cc5b7840f923b4301229afb7db846edbbe75e92c772509a48bedf41d40b4fdcf1b3eed81d76f0050cf8b6edb4f7dada35b6eb77f0ed7e3700b246102ce87323daede0c37388d72e4a2de7db9dce98d9b68571192c880d53097970ed938462cee756b001412d1d6af8feb2f1c34904b41b657a86a2d2c3bbc1016316728a46a7964323b4ca7acf97f62b9efd035f8dea6844b1b0bd1fcafb5cec9e8af113e85894332b5f65ad58bd1a45f42955d25a45113c5288f37a31c7861e0e49f32e47a7b0df50db939f5e81bfc08c81b7f16ce7e37c05fe528c728ea676283815251d23873dbe60a5b5ef5e02197e01b649c4b05f6bc730d8aa22482f535d9812d2f7d4e9217c51c9a541525b3113a2f0435ba700b89b96005cd29614ca4b4e4941305989175c6a9a123c3c72f0d0e8f38a6225af5cc16c84e1448c93183c483b1caf5220168525a4d3103b13f78dbcedcb9b89ed1098240f21a8702a1c0047f6cb6f0640a30ed23e2cafa87fb50fa3d990b765ab555dbb96ab44008f08dba88be15dc1f2fcdac22b390a6694bfced14b21fade87552c001e6bd996704c9a59577fadbd70eacf5272847295086ec1b65e832c8b54e15ad1a1897a3d7832ef351d3f7e1c4d2f05df8b27352fe4d019c80dcf98702cfc79260c9aca04f034cc8586a00e9e6294c2225aa450f9fe7db46041a1cbdfee515919f5cc29562ba32d880ef19e03aa1101c83d3b684cada31341a15509b781b01a9265809528ba7ed7ebe9b211cde6b4727cb73cd98bcaa151f7ec4eecfae9b96f87d8e015e028a65d8bf5a12f19c5b0ad23a0be15bbad84ab0a2329e67b3c8128c9cce478f08d3747544ce359d7e57cfa30bac055915287c6796fdbc26d6b69bcf205a3c6302f557c0585d07a00791697139d65af45a40aab5a80c9dd68a6498d75f86c8a10597a4af44a8d30ef453b0b4f2c964cb8c5e1ee22db46793750d0cfbe42ab4689c1c84a320e637887e3d86564009e5d108a7e922470c26018522d43031215a6816ade4efb6e0c46d3add0c7574741cad67b87cde3d07c78072cd81e6fa333b3e3f457a33f1653e1e913f2c0ef8cd75c54477b648aaa29916a976b42f554e59b19ef996cbb92a9da4268d3b84a5e2a2c86e0591becc984e5c1fb7298dce0af79b3c9b53065467046c69b3a3a5bb6fd62a43f3b15f5cccbe30ed4ba839f9994fa8e61f598ea664f374f20d2a87aee9cdf3d0ef62201d3b240d6fca87d8e1b287c57281a150389b6a011303f067604fa4a8d3781522c8806d2457b3194e7e8b31b952ef4df0aba6ca1e6bebf1a681bf4182db33a7d525cf08a217cca9cf5bed1217695ce30bde8c00bdb5760321de4db60f6a8e414467ae5b1f59acf2ef2d25c36659a010ee36953029d626169b0f17067db10210ad0f72112765e9e5424073ed0b363636c588ca8b0bc323ce244c2e460ed3fb9cd3ee62f7b1e400520776ba1bc44e3921a1f0285fe10a2f27ff09ed4c149575b6a1a6dd745d0cff63712f2fb68535fe0d6e41a6b2fbcddcf2153f6d2a3e1de0e32b24226575816fa5a235da20c3be3d7f04152ac077cce9823f226f46de228821175ec3c16aece5790168edadcff0b3083ce80694a4bd658161b1411b428526c87914d2f698603b719b0f8602f81ef9f04dca92333e7da8399fc54d7b813377578e8acddf638550442a9b9ff61db7afc5a27f167efce2087f6586cc22ae6ab56a41d10c51f855cc2de4debb10b9fab96998163caeee17a0a64cd27326c145e3c10dbcafdd0068dbb7819f6d11798a64b1e3e5f41677cac8dc9e2775965fb26a1bae6dde48556109612812eb9744ef07fb4636d4a48eff9f20a2cb847536df544456c411d3e835c76fb290d48c784f8c100bf6db2b35e54d41de9cafad4e6344def9b9521cb4dd5a342e45ee7abce1d65d25784c9ef01062bcf6fd12f79b8046f40e18592ad0d6832ad0208b839ca4d963cbe7837d2ec0e10724963889efa56ade040071420c2d5f0cab9cc279192ba3502e3ecdb82d7f4c3dec8946f97361c75217919b4caf374205c50c158a4d6cbd77987fb688090ef5a7f5f1ae01a45c455fbca80ba8983d181c045f69cae269679bd7e4c65c2c0375e39fce494918c9167e39fa65ffcebaad0dccb6262d977fa96d343593c77c30ae17a919cecf1191ad584230695d3a6ad36326bae60a224df36ae28a65350f15b13e18ecdde6cc92ba4d50e6dda5f6a87473892238c0ee47e8f6b0afb5d92c561b06753a0c3a8ae3cfafc3de1fb55ebd09f9d0ba2f7f05cc67f2f2148da570d90a507b7f6573d7291a9b45b01323bd50251532e6059a68672b804e78225db011b611695aa7de1966ded70b88d893d9b17c3602199de56a69f1bf2e1ac6debe9b22576c186a5e2eec2fa1dff9766e27fbe18d30d0b60c1ab5fbe0627e5953362dfed846d69d42463b372cbae9e016f42175da65e502d046b7db9cea7ece2675bdc9ba38c962b2b3160a470bff1ce7062c5d555f6861c5a1a80ce2a4e06ad323800cf19624daba7fbb0f60bb49e8181213de394c14f56703bb5943d36657737ad48e70790934dc3952d4e98fb1c09551bc829450e89d1e44949e7ae40fb738d41ecce521b8703765911ba08f8ee08e324ecb63a83ba21c67b7eae95bd5da2fc684110d2087c41cbe1038f020416f5ea637b0d5ded70ec556ab0572b6e63ce49c5ee632dbf08db625a5c6b905a2ca4680353bafbc5ba17e5efa19c0d4333fe89771e3b1a2e001d66ef759cee49bc1b5ae04e2a3bb24c6db2106c2838db60e30eaf8cde850a43d592dbd933581e13a45828a0f624daab04b0fce4979459d90e6fb39ba24a4a7abecd06f685741c2132764953a6463d79357231561a11b66a1c911e227a507e7ee72a765b950281034a3bb7416b093ca40fee3bc7d621f1a65d025a3c4b1d833cf1e9ca47a1f3e5e93db293acb625692d072d3a0eb73ca7ac12512b733574d6e2ea3d41334775af670a41c34f09608ae0789c92cef8c31b93ac3f1f346fa77ef080c0ae489ac12902cf0fc7c97887f9055af8cc13ee1f5f0335fca3e8fe9811e83c84af05fec7747e647b5c626171241c4302653b76e81a15e978836d58e5470bb93d76f03e9565c764c0a2e1d2c89fefc99f001e33ef970ee7d23cd7e747f55472bbc691054fe8f6dbf2d9435e4e6c62a22ae5cb95393223342b580016baf9fcada5ab36d4b4b7aa98a6f38a37c618e2451568993aa86bf7914fb04b8eaa9707c13572cfec0cff203542c9529bf3639c5b40992acea3acdc59379a53400bfffabcda84d5789e1e5373dd7f40a3370b49368a294e3f0ba5afe5679b7d28de0f0ffd4cdd7de2f5426fce1201258642933e5fab02d059b9acabf75a822fdf10525a449bb32a74c2819299f61ad306aa9fb7eddfd3e2a6ba724f8b2dd1e8d9bd5b88f6aeda998f033ec0b67c7fc14773153a694a5ed07e3dae2924e3c4abfcdc9e1ba98d98ebda2c6f9c1c4a0d43b725c7b863f63a2f9713fa105f6982bec19c994a138c9748d190c11393779fd714ba3d1a76521840ce5ba1c5119f45aae2dcf61dd4b244a426371c746b2965a039a9727a6bd00f56f57b447e5701c3a7e9da8f04240345eadb139453546be1871eaacb3245021b47c7909f451e9db562848a3c86969c97190b2cb95dcb88561824793189ea5ded2a22db5429f12c089d6504dcfb23df7a979061fcedd0929819e35028c1cd2cac8ec2fc4b45558e467c2251cafb331d9216b0550a45cb202468add76fdb6a15eef9b202575891550cf233068b8d85c6214590ef85d776bf18dff59de7c79839aad676ad634e6564254c8e8ce97f7acb0812c40db86aed124271cf1c68114eb37742e4ae9e5e6a21b4b8818e677a5a2aa486741e54102e49c56107c5411ae4441cada6b9229de0e0c00c3cdf961474f7670654146c9cd87f09554e000f5106dc0836be9151ee53a5dd5341ebe9d421c25af486c0a58bbbf22d085d722616894ff2b6da79bdb2e2fa47be1e5c33b51ae7a45a75742fa974a580f79dd844b3c4250fff3828af1e225d9cd806fb86aa97156d76af5212a9a3e594dc8a13bf62dd13c7a268f5df928ba164152a805215ea1ce21ab17a2b890ccbd79a5cc60ff6b192ce41d2242f0db295264145e2778aff86572c594483ec885d7cc307666ba3d18fec3f9c4d4dd65c99a609764fa9b82adcd5a0f5febc296513dc1570bfbcd8fa76f22d1485594865825e0f51d429b7553f9b43b1dbce326697ac5c8471276a51c3e6967fc9d48cacded27d3516c5c6e7115886b434fd6151eac132339b5f9b604a3000591180c385a4217b9dfae8a3a23a35801e61608da536c6dff5358a1f5e51a27f02668c77add8af3c1cabde0260d63bf06dade9cd563492a54a24c13e55c07d863e297416aa44d7fa8f3d0f09578ff7f6c06d611d15d3509d4c00cc7af2072b485998ee0041b03fe0eb651d251533b3f633990bfa19d866d187dbbae8d28ab69113b13f401a805b3f9145e9bac178d6f91373dc29300f528151ba8df225e4d341e21dd1d7460705603169e1e55f476c6594bf67b8432a273b1485c42fd9f468ece0ac4027fa070e1348da8c4bc298d4f46e86e7bb092a64357719a41c2ad12b8b6f1305aa2174d263337ee5b37cc388f47df589f3a49959d166f4ef41e74995e60dee63ff170cc2a15be990aeadf8e8d55e468e5347b4aa2b25893b1c0fcef43e7abfca521bbc13f8d572ed6970240321fc7c1b2d9688b43ddf8ec875fecd87fb0b1257f7dc7e8a8a4e5588a56ef9530a19258378411054dbec8c5ada7903b3aed98785482df64851ffe320b2e71b185a0dbbb376971f01f82d7cd1076a875179a8be4240d9ad5d4e9a783ca32698d56cab14633ea2a5178664aa64dc8df47fcaf387154851fb91733e93c4cee11be604a0d391b55df4e331b361bac4c78554dcd155ca5d61c0d96608563d209a8162b3726c14704014ed983e6299c169b06856c249bd5d680ef94bc8aed832db7f434097fec490203f2e8694cea2d7eea728740e438530ca016c7b30a2dc2cbef96dad998aa62d1454849b0ca71233d1adfa5f3541127f2eb4a445f443e62ad9d0990a478d0ddfd5af6c408c07675d4136ba288e4e1573fed9771f142511dfcfea931eb3cf366c08ac5b8e69f3b92254ad682c77905409aa1788ea46656506d94e99f94ac03e6d61d00d0d1473496a936a9df91767f45f79a1ab3973404854195f01af7fdb9e668e0076cc4f6835ad74e439f274e65a3534f0e8631678d0d19b64bc271b2dfd23efb4a42caa910ada550849e3ed5d2ecb8e0fb4894832aaf29f2a942fbd317a33f2e75da7b2c46388c0a3b3654bed41b5cc22426ab8fef74b6d275093aef3f37f396ae9519feff6ef8fd7da7f1fe941126a76f8fd3a592c43f1262cc58b99024575231e21986576d836b17543970e3bd5fbdf1078c4752aeacac17701ccad3b3d6a169e5d0d805159c58a21447e00f49c0505ed4882375b404c8d8b440a0f44aa8bad07e86101765cab756e06b17806d32ae34b838bcd3d85b89c9363e1c3252870f20e3587ea4479dca3dace268b3c15a4472247331f20020ee2b3ac7a9ccc184df60fdf9377bd01b8f3cab55a5dc1e107a46724a87400be12e42135557e1951e4bc98b82b2fa89178cfeaf6a00c5b3c3f3ac0f1a830cbfde1d479a525b6de8050d630cc66cd2755538099d25d7d12cc0a0caa7af28fe4844981cc686bc562810547c953b2068fc12d4d2528d6ab87ca46601040013fa2b38da86ffd5ff4fa41a24df45380ed09f1645434b7a35a59cdcda39a068b164ac2ead454d1c96763abe52fa35ca5f1d0df87bde78ad0d0f0137fed1af99c9b5c1ceb45f6c3af7dcb2f94f679cc6e0eb220a9a6d516d6cdbe31043b087d89814bd804c82980ede4494eec15d0ca987304a947265ad07e422247f0bb36a0b045864fa1712dea845ea55a33c17eb0f2e0a2bc0ca3dc1c7c9d2480eec242a5e897e55658b49a04f5b7ade69c356a7e652c4ac1bdbff7a97ac14cbbf949c4b749d32c54fbcc0e8bc16000655c8e3a577560329714bfd3475301fa2ce2313fca7a25d9383399022288ed18357e315c879915acfa818493b93a1a2fdd5dccebb98312e660a2c3d48d59d06e98ad8c3b81ba3bce10fc25edb18ab9ae10cda25820bd4ae3528a9b175ff32036c9c9ac8e36d074dbd70ee62906724a562720c9c690d10db5e85b374f3c9dc6d97cd712c66ac49f0a30f8d4b0c6d28b8f998f0108b8915422035deedbf375a571396f91c45ea2ed8d7aa72fa47cb65dbccf9c7f3b5546ee4e0eac8fce5cde5b95965c2b070a2c05a307e6784f27d3506f231775a480f9efe27f91005b50cca13debab2c4ed80489a0ebb85cfdcb93aa455c3bb0442cb89a81c7ae870a5acc73a11c47cc2269eee97dcfb1af8fcaf82416de53a26323ed0aec4adff9e9ee6c0889803adfff93572ca57f93f8fc5043ad06dfb2f1b7fab5cb85468550f4eec65080ee72181cf707c9794e944460c939801bcc78c06eedd51d0c6f67b91b6e8f255cb1c159f17394fa1efea13ec403b8afb53dd21e9f4d1d94741b596ef6cdc961412096aed05dbad1e93fbd5da263c3d1803f8f6a30a4bb36d2332a79489f37d38d16452d0754c30bd4c22c23c82e742b53c64be8ce00a6f49b6845abf600de5d2626d7bc716b3deabd36a16c3894283bc0cad06c149773c9bc157de5d9efbcb633a9bcf61244367e45249003b3dd3f6e8834d33e439c05eda2c24d4bade995e93d99cea0aa0a52c39549dd16d0893e484159bf25029bab35c4dca1b8b3077bc451c8f0cbb17b15aec4058d49315e5d5fcca53611f0bed7a66af9debbfe638f550b8507ffc41e6f1c5419e16fc8609701effc7a8c735e0e8d16edaf8a0d038a83bb8e6c04f41b66acd085159df600c2b3f61c16dbf97eb7dd122feaf3a070c4c56c58901b4c43515d6317f08b3a8824427b08332b76aaaeaf988387d3e2a813f472846e69064a5f4d28179587fb7ff0f8d2ea96c15e7c2f14cd0cde0e35eaad0627a03b21d683e6978d2555ef10cd39a62cf0af778e6db0779bcd2e30ed6ec1de25b54c17779ce537689081bfc2790774239eb010f972338f8b0e1b23f9660f6a2c579e69124c166867933178181e46e4df7c065b24774eca8c3e902805a41b9454d418f58d4001e21e6ef70365a07984e0586213ecd9954aebb333bbbac2d1b99831d596e44c5684033fb000f90bfa8c053303e66102663c38f8cb1fdd183a4415762c80e3b9266d515782e49ce13814da2c51c4d51029d1c5e34459679513475a52adf0596e215b1badc3ce97d8bb2139d7c4220884ab7566cd419866915b67a02e7802571e10fd112f1d4250de27160512907fe03ff1a2ab2be31f78344dee6c1fd6aaa7cd9d456a5543b6eede70050ec6a8f4a648c5995baf5402202d09d84d4acc31ad61a425df8516de07fea5897a6d546809540722719eb8cfa680fcd6f18ddc220caa117809c626ad6410f5f5e94347d81bdb64e9a7979d17beb500259a1875f7a9b2ca761baed166c49363a5f5289f69cdee6be1cde2e4c846b29a900788b693e32acd5e7a5700f7917968ed2c94b219a6aa271a9ebff72e04c7e2c271f5065d7afe0443022dffa49624bb6018e5e0bde27ed49d86e02b11f7fd87923d39e75d37c2ae30372f884df6aff04466daf0245e81203596d0d3f33e68f296dc7fd36f2c7d282ce0f46d664b567acb89cb9184bf26687f1e0765f79ef27da7fcb9f456ea5df9544890d8268b7e2cfc4bd976a7e98dd2a0a326b7855f1fd6138b3d37658d1df4691932f30a7930691c4aceb0e63409660eb12a79e3e4a2d6415f5381c7d6e23eebfb50da100f99c94b6df4b28677eaab0483a9aedd38cb40010be8f2c4755c6bf2b863ae4e4db02be42e1fa7e6680d4f7e08aa8e261d1cd1c42db4b9538c231f9a4098060d5cdb51d3cd1e94ebbe76b81f7364fa045407efdc19a5bfb55fa9c273a4ef5b97fc739f031b33c8b1a295911daf94685c5050bd7fe49f32c3ff6c7775e2acf5a37b446ae30eefda87b7e2623a3327609fe6ae2de92dcdf896f493b7f7060b5fdad859d981fee1abcef4172cf7854210cab0a3affe1f41ce6ee671842fab9cc3f1a0b91873d1a983b0d782e1b78b6076f000869af0b557a49afe846ee18948ab8aa03ab509fbba742408d6c5929321ac1e717a99ea02109fae61174312b64e35000a0929f5f56b82ccbc5e0617d4d9727eb12e2ff1ec44f5fad910ad185b66f42670a92d5f5aede5cf131a881b4b456f29bf919e9775aff30ee84d50d13d76d0bff7bd2c518960163a5737b47181076494d12a9146ee6742d488eab53a54b0ad74f6327dee843056cc5581dfbbf4920c60c2283009ad26a4a7e2fb305caded1b29a73c49e2602b8e053e6eaac95f594fe5b12dac651d6dd11d596cf3d5946471b0d2e575210eaa83ecd5610156e41c30f4cd8612a7c19239baa2ddba1bc832826afa6ddde1ca79fb9242821303bf8f548787ca9d1470032c5e9f573fe60ddf8eb6e7c9fc58138e6333f458bfff6207ed842589f10a8d941c29208782a393ce236c75c573bdebcaaf09a6d393bc7f9dbf26cdfad5cb59a1e89eeb5ec9398a632a1367d772e2e0c03eece1abb2b7819a964cfdf2a2c81677f897c738a604a0f9fc0d1dc279883cf85a7f50cb7fb850159900cf08e35d3cb5f3fdae2914588d4ed9524b0977cce974a177612276be099c1b12eef2017bf5eefd09fb164d848daa7d08d4aad51a5d646066c40862bf2de2348e7e9345a37c089569cdeaf816def11c77a5ea1a4ce06aaef70ad851c64eb6dcc8c5e32162aaef11d93760b9cd2d7b2e24509f90d4d3ebd55318b584da1172b36569a037318fe11b81345c1658823a8aaf41d5159cecfbc4a30cf303ced3bd4fefa659017d2ba34f9662e338c9cc0f5621c2e8cfe1b4c6cca81c04f1c189b7cbbe09caef0e8f67ae9154a1f89074f05edea0241f1c6933cfa9df89a209270eb8fd5205699b38025506d9be4ccb8ff44d4e67993d3145993e456279be1a97b4f48f60d93f1f3b88496a40afcac1bd221ff861810b2a5fe096a945cf72b4bb9b9df6a74a93f2856c02a2efd5db2e540fe08a116117cee61092711f628098691bc90ed79c55b1ffd77789b90b5754870f5bbbb2ae5d17d32d546ce81bb83e2b1dcfcb6f5a51b0b02e89f1482e7f2f882565e6c878c638d9483b33b8126de9ef1a3eb807f2be4a84899a1d932b5c61f9e66d05740b9d17b9c66bd0dcf3a4b964368d9a4cb7a38d8b8c74434712ca2bfb29491023ce24b267191ccbe5017cada5406f74971abe5b3c7121c73df09a5fd36fac731e9fe6100cb907755e40b50df1730e9b78388014de395766e3dc2888c0a91aba51894ec9218499fe3c6e18978bd94f3bfbcbab9ad3e88b4333d5155e743335ba55cd44f275e2e72daa8e6ec8829440ee908004debe10b73333f71ae8e6a3761807f4bfe7df25594a09b46201949b645dae44fcd7462be40fea646b58c7d9ff4a60a0dcfa8936e906809bc9c345caa3b73ecd969da98eac4cab9e5e5ef62aa6e6231918b938659345c5a70cfe69800e1d71e49190d54c500b931fcaad38c0e7aa535eb25d0dee45e127ad503472ce2862b9f8c40cd1f2e6df0fe8a812ab4033666c5e8812edcc7db2b3c34c0e97ef4e92e19ae3162cc26b573634ff846e22b1f63c61ae1cd7e1d06889824edde4c956f7a5087a5d5507b92cb3c54ea77d66432cd6b8c34b58bad5e22a6f40d9f56d5da02e5ce9aa72cb741fe200b02cc08c18008b1396c0c2c87fe722ac9585f5b88431281927e72a9ad99d1020d83d403e8e00faba6c6975dcaf255e279e2c0ec37b48cb500bacba98c475a01c3f94aa468d0ccf5fdc8a10084672b12a931e7960afab26d45105b4707a0d566b678e5f9c4c0e2dd44f8bc9d631c8ceef2433f0afcae4295f2cb9d69fce6ef08afedc98b571c9b53dfa49324bcc62332ec50a5423e0d43f93cf279e8ccabc67af43193081be50a94ac8656316d17ad8c9e8332d831214cacb326bb73bb7a6bb7c0dc630f93c2935953d97132bf439fa4e6900fdda81e8d90df53600c89a58f358b063d02df793130b1203d24397ae2279024e2787be036a9d815d36159579b9f72bbb90c8d60383269cf7d5b43ac6c605d1e0ab2a483ff0f57f6a7</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Post is cheap, show me the password</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Suptech</category>
      </categories>
      <tags>
        <tag>Suptech</tag>
      </tags>
  </entry>
  <entry>
    <title>数据治理（2） - 元数据管理Atlas</title>
    <url>//articles/bigdata-metadata-governance/</url>
    <content><![CDATA[<h3 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h3><ol>
<li>支持主流数据源，例如正在用的hive（库，表，列，处理过程）以及sqoop（数据库，处理过程）。此外还有hbase，kafka等。<br>业务视角：</li>
<li>数据字典。有UI界面，可以查看到hive表的schema，表注释，分区字段，存储路径，创建/更新的时间及操作用户等审计日志。可以查看到hive表字段的类型，注释等。</li>
<li>检索。可以根据表名，表注释，字段注释等进行模糊搜索，快速定位需要查找的表或者字段。</li>
<li>自动实时采集。例如新建hive表，或者对已存在的hive进行修改，自动实时同步变更信息，无需人工维护更新字典及清洗逻辑<br>开发视角：</li>
<li>血缘关系。维护表级和字段级的血缘关系，可以清楚看到表间上下游的关系，以及清洗的逻辑。当在表中发现有垃圾数据时，可以回溯到该数据是从上游哪个源头引入的。同时，如果需要修改已有的表，也可以看到会影响下游的哪些表。</li>
<li>表有维护last access time，可以判断哪些表已经废弃，可用于对废弃表的清理</li>
<li>标签体系，结合ranger（如果使用）做权限管理。可以在atlas对表或者字段打各类标签tag，例如对手机号phone字段标上“PII”个人隐私，在ranger里配置限制特定账号对打上PII标签的数据的读/写权限。</li>
</ol>
<h3 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h3><ol>
<li>hive元数据来源于其定义，例如建表语句中的comment注释，当前在用的部分表是没有添加注释的，而且对于枚举值都不会列举出来，这样导致某些表/字段没有任何中文注释/描述，需要查找上下游来确定。在atlas UI界面上的表/字段都有description描述项（类似于备注），但目前没有找到直接在ui上更新该描述的方法，也不知道此描述从何而来。对于枚举项，仍然需要再另外维护文档。</li>
<li>UI界面无法添加修改表的owner责任人。</li>
<li>没有访问热度统计信息，无法用于区分冷热数据参考。</li>
<li>暂未支持flink，spark的运行时血缘。</li>
<li>UI界面没有显示所属主题域，所在层等信息</li>
<li>部署需要引入额外的组件。hbase（用于存储元数据信息）， solr/es（用于搜索），kafka（用于自动同步更新元数据变更）。除了单独部署这些组件，atlas也提供内嵌hbase和solr的方式（多用于开发环境验证使用）。</li>
<li>无数据预览，分区信息。需要结合其他工具，例如cdh套装里的hue。</li>
</ol>
<h3 id="竞品"><a href="#竞品" class="headerlink" title="竞品"></a>竞品</h3><ol>
<li>Linkedin Datahub是另一个常用的开源工具，具备数据字典，血缘关系，标签等，也可以自修改维护描述，责任人等。基于docker部署。atlas相对datahub成熟，参考资料较为丰富，与apache其他组件适配度更高些。demo： <a href="https://demo.datahubproject.io/">https://demo.datahubproject.io/</a></li>
</ol>
]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Data Governance</tag>
      </tags>
  </entry>
  <entry>
    <title>数据治理（1） - 概述</title>
    <url>//articles/bigdata-data-governance/</url>
    <content><![CDATA[<h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><h4 id="1-建组织"><a href="#1-建组织" class="headerlink" title="1. 建组织"></a>1. 建组织</h4><p><img src="/images/bigdata-data-governance/organization.png" alt=""><br><img src="/images/bigdata-data-governance/roles1.png" alt=""><br><img src="/images/bigdata-data-governance/roles2.png" alt=""><br><img src="/images/bigdata-data-governance/roles3.png" alt=""></p>
<ul>
<li>摘自 信通院《数据资产管理实践白皮书4.0》<h4 id="2-立规范"><a href="#2-立规范" class="headerlink" title="2. 立规范"></a>2. 立规范</h4><img src="/images/bigdata-data-governance/rules.png" alt=""><h4 id="3-选平台"><a href="#3-选平台" class="headerlink" title="3. 选平台"></a>3. 选平台</h4><h4 id="4-重运营"><a href="#4-重运营" class="headerlink" title="4. 重运营"></a>4. 重运营</h4></li>
</ul>
<span id="more"></span>
<hr>
<h2 id="技术角度"><a href="#技术角度" class="headerlink" title="技术角度"></a>技术角度</h2><h3 id="1-元数据治理"><a href="#1-元数据治理" class="headerlink" title="1. 元数据治理"></a>1. 元数据治理</h3><ol>
<li>数据字典&amp;数据地图。需要提供可用工具，数据使用方能很方便的查找到所需要的数据，理解大数据数仓中的表，字段定义，例如统计交易数据该使用哪张表等等。同时当线上的数仓结构更新时，能自动的捕获变化，保证使用方查到的数据字典等信息与生产的时刻保持一致，减少人工维护成本。</li>
<li>工具需要记录技术元数据（表，列的schema等） &amp; 业务元数据（维度/属性，业务过程，指标的规范化定义） &amp; 任务运行/调度元数据（运行时间过长节点）</li>
<li>血缘关系。方便查看表/字段间各层的相互关系，可以看到在数仓里，数据是从哪里来，如何使用。当发现数据问题，可以回溯到源头；当需要对数据进行清洗时，也可以看到对后面的哪些数据造成影响。</li>
<li>规范指标定义。指标产出需要指定业务责任人，技术责任人。业务团队需要清晰定义统计口径。当组织人员流动比较大，缺乏责任人机制会造成历史任务无法跟踪，造成任务上线多，下线少。同时，对统计指标缺乏明确定义，既不利于理解指标，也容易造成技术开发与业务对口径的理解偏差，还不利于指标的复用。</li>
<li>物理表查询热度，资源消耗。</li>
</ol>
<h3 id="2-数据资产分级及标签化"><a href="#2-数据资产分级及标签化" class="headerlink" title="2. 数据资产分级及标签化"></a>2. 数据资产分级及标签化</h3><ol>
<li>根据业务重要性及影响力划分等级（例如 灾难，重要，普通，未知）等。借助上述的元数据管理工具，根据任务的血缘关系，将分级上推至各层级的数据，数仓表。数据分级的应用可以在监控任务等。例如，监控任务产出时效性，监控重要任务链路上的节点，按照不同的等级设置告警策略。</li>
<li>利用元数据管理工具，可以数据标签化，进行分级。<ul>
<li>基础标签： 安全等级，访问情况（冷热数据）</li>
<li>数仓标签： 全量/增量，是否可再生，生命周期</li>
<li>业务标签： 主题域，层，业务类型</li>
</ul>
</li>
</ol>
<p>分级处理可以应用在治理中的各个维度，分级的标准依据根据具体的维度设计。</p>
<h3 id="3-数据质量"><a href="#3-数据质量" class="headerlink" title="3. 数据质量"></a>3. 数据质量</h3><ol>
<li>质量衡量由事前（DQC覆盖，自定义规则），事中（异常报警），事后（问题跟踪，质量评分，历史趋势）结合。</li>
<li>根据数据资产分级进行质量监控程度分级。准确性，完整性，及时性，唯一性，规范性，一致性。</li>
<li>准确性。DQC检查，按照资产等级配置监控覆盖率。由于DQC检查嵌入任务，需要按等级做好覆盖率等级配置。</li>
<li>及时性。按照任务优先级分配资源，设置告警策略，任务延迟预警等。相应的规范人工运维介入时机，保证重要任务产出。</li>
<li>事后质量问题记录。故障定义，分级，处理，review。形成长期记录，质量问题有跟踪记录，同时避免质量问题重复的出现。</li>
</ol>
<h3 id="4-数据安全"><a href="#4-数据安全" class="headerlink" title="4. 数据安全"></a>4. 数据安全</h3><p>数据安全分为四个层次。</p>
<ol>
<li>利用上述的分级思想，从字段含义，产出指标反推等，定义数据密级。利用元数据管理工具，可以将密级推送到上下游。</li>
<li>角色/分组访问授权，数据确权。数据所有者/管理员分配数据访问权限。按照最小权限分配。</li>
<li>数据脱敏，加密。即使越权获取到数据也无法读懂理解数据。根据不同的数据类型，密级，数据使用方式，使用不同的权限控制与加密方式，例如隐藏数据列，hash，对称加密，同态加密等。确保即使越权获取到数据也无法读懂理解数据。最晚解密原则。</li>
<li>对数据访问进行审计。使用数据水印，在数据泄漏时可追溯泄漏源。</li>
</ol>
<h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h3><ol>
<li>表分类。 空表， 3个月无访问表，数据无更新无/有任务表等</li>
<li>删除策略<ul>
<li>周期性删除X天前。适用于每天从数据库同步</li>
<li>永久保留（增量交易） + 迁移至冷数据中心（3年以上日志）</li>
<li>增量同步，全量merge。对应的delta表保留3个月</li>
</ul>
</li>
<li>划分历史数据等级<ul>
<li>非常重要/重要/不重要，可恢复/不可恢复</li>
</ul>
</li>
<li>根据 （数据重要性等级，数据表类型（全量表，维度表，交易增量表），数仓层） 等组合维度划分生命周期管理矩阵 ，按照所在的区间，相应的采取保留3天，一周，一月，一年，永久保存等不同的策略。</li>
</ol>
<h3 id="6-数据成本"><a href="#6-数据成本" class="headerlink" title="6. 数据成本"></a>6. 数据成本</h3><ol>
<li>计算资源成本。<ul>
<li>监控资源使用率，合理分配资源，避免浪费。</li>
<li>无效任务下线。需要根据数据表的访问统计，识别废弃任务/表。</li>
<li>超长任务优化。</li>
</ul>
</li>
<li>数据存储成本。结合上述的数据生命周期，分级处理，制定策略。例如如何处理冷数据，重复数据，压缩，无效数据下线销毁等。</li>
<li>按照分组/个体人员，以统一的标准折算数据成本（例如，1CPU，1T折合一个单位成本），每周统计折算后成本，督促成本大户重新审视和优化任务.</li>
</ol>
<hr>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><blockquote>
<ol>
<li>《大数据之路-阿里巴巴大数据实践》</li>
<li>信通院《数据资产管理实践白皮书4.0》</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Data Governance</tag>
      </tags>
  </entry>
  <entry>
    <title>微众银行FISCO-BCOS中间件赏析</title>
    <url>//articles/webank-fisco-bcos-middleware/</url>
    <content><![CDATA[<p>区块链中间件是在区块链节点和区块链应用间的通用组件，由于多数情况下会存在多个应用共用一条链的情况，因此中间件功能的通用性和完备性就非常重要。针对不同的链，中间件跟链的接口是不同的，但是提供给上层应用的功能和接口应该是稳定的，而且理想状态下应该尽可能的不与具体的链特性做绑定（实际上很多情况下做不到完全的屏蔽底层链特性），即适配层。一般来说，中间件需要提供有以下的功能:</p>
<ul>
<li><strong>链数据管理</strong>： 相当于区块链浏览器，获取链的信息，例如块高，块信息等，以及管理各个节点的管理员admin功能（对应微众的<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Node-Manager/index.html">WeBASE-Node-Manager</a>，下同）</li>
<li><strong>交易</strong>： 交易上链，交易查询，交易回执查询，存证等（<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Transaction/index.html">WeBASE-Transcation</a>）</li>
<li><strong>合约编译部署</strong>： 编译合约，部署合约等(<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Sign/index.html">WeBASE-Sign</a>)</li>
<li><strong>合约事件监听</strong>： 订阅事件，事件推送等(在<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Front/index.html">WeBASE-Front</a>里有基于MQ的方案，以及单独的基于区块链的分布式事件驱动架构<a href="https://fintech.webank.com/weevent">WeEvent</a>)</li>
<li><strong>私钥托管</strong>： 托管私钥，代用户签名上链(<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Sign/index.html">WeBASE-Sign</a>)</li>
<li><strong>分布式身份</strong>：DID，一般遵从W3C规范（基于公众联盟链的实体身份标识与可信数据交换解决方案<a href="https://fintech.webank.com/weidentity">WeIdentity</a>）</li>
</ul>
<p>其他的还有<strong>跨链</strong><a href="https://fintech.webank.com/wecross">WeCross</a>，<strong>链上数据导出</strong><a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Collect-Bee/index.html">WeBASE-Collect-Bee</a>等。设计遵从模块独立可扩展，分布式按需部署的理念。在后端设计上通常使用http restful接口服务的形式，减少对调用方的要求，同时屏蔽底层，使应用开发方专注于业务开发。下面具体分析各个组件。</p>
<h1 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h1><ol>
<li><a href="#event-listener">合约事件监听</a></li>
<li><a href="#governance">WeBankBlockchain-Governance链治理通用组件</a></li>
<li><a href="#data">WeBankBlockchain-Data数据治理通用组件</a></li>
</ol>
<span id="more"></span>
<h2 id="1-合约事件监听"><a href="#1-合约事件监听" class="headerlink" title="1. 合约事件监听"></a><span id="event-listener">1. 合约事件监听</span></h2><p>合约里经常会包含有事件（event关键字），应用通过监听链上指定合约的指定事件，从而得到相应的数据触发相应的处理，也就是不同的系统不再需要链下的交互（例如api调用等），在这里，链扮演了类似<strong>持久化的消息队列</strong>的角色。在多数场景下，对于链上事件，应用方会有着 <strong>可以重复读，可以从指定块开始读，不能丢失事件</strong> 等等的需求，这些在设计中间件时都需要考虑在内。</p>
<h3 id="1-1-基于MQ的通知方案"><a href="#1-1-基于MQ的通知方案" class="headerlink" title="1.1 基于MQ的通知方案"></a>1.1 基于MQ的通知方案</h3><p>该实现在<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Front/appendix.html#id8">WeBASE-Front:支持链上事件订阅和通知</a>内，大致流程（摘录）：</p>
<ol>
<li>WeBASE-Front连接到MQ-Server(目前支持RabbitMQ-Server);</li>
<li>WeBASE-Front接收节点的事件Push后，如出块通知，WeBASE-Front将出块消息发送到消息队列中；</li>
<li>区块链应用连接MQ-Server，获取消息队列中待消费的消息，即可获得事件通知；  </li>
</ol>
<p>接口文档在<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Front/interface.html#id491">订阅合约event事件通知</a>(基于版本v1.4.1，下同)。其中主要参数有（部分）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>中文</th>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用编号</td>
<td>appId</td>
<td>注册事件通知的应用的唯一编号，仅支持数字字母和下划线</td>
</tr>
<tr>
<td>合约abi</td>
<td>contractAbi</td>
<td>合约的ABI，用于合约event解析</td>
</tr>
<tr>
<td>event起始区块</td>
<td>fromBlock</td>
<td>默认latest，表示一直监听最新区块，最小值为1</td>
</tr>
<tr>
<td>event末区块</td>
<td>toBlock</td>
<td>最小值为1，最大值为当前区块高度，需 要大于等于fromBlock；填写latest，表示一直监听最新区块</td>
</tr>
<tr>
<td>合约地址</td>
<td>contractAddress</td>
<td>合约地址</td>
</tr>
<tr>
<td>合约event列表</td>
<td>topicList</td>
<td>List类型，合约Event事件列表，Event参数之间不带空格</td>
</tr>
</tbody>
</table>
</div>
<p>大致流程如下：<br><img src="/images/webank/webase-front-event.jpg" width="50%" height="50%"></p>
<ol>
<li>应用通过API请求<a href="https://fintech.webank.com/developer/docs/webase/docs/WeBASE-Front/interface.html#id491">订阅合约event事件通知</a>接口</li>
<li><code>EventService</code>类构造了<code>ContractEventCallback</code>用于后续收到异步推送的回掉实现，同时生成UUID作为filterID，然后将（filterID-callback）这键值对记录到<code>eventLogFilterManager</code>(本地map结构）内。然后向FISCO BCOS节点同步发送<code>ChannelMessageType.CLIENT_REGISTER_EVENT_LOG</code>类型的注册请求。（客户端与节点的交互基于<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/protocol_description.html#channelmessage-v2">Channel</a>协议。交互分为三个阶段：注册请求，节点回复，Event Log数据推送。）实际实现是基于netty通信框架，这里的webase-front中间件与链节点间维持着长链接。参考<a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/sdk/java_sdk/event_sub.html">Fisco Bcos的合约事件推送</a>。然后同步注册成功/失败后将结果返回给API调用方。</li>
<li>中间件收到链节点推送的<code>ChannelMessageType.EVENT_LOG_PUSH</code>类型消息，根据消息体里携带的filterID从<code>eventLogFilterManager</code>里取出相应的callback，然后调用<code>ContractEventCallback#onPushMessageLog</code>。</li>
<li>在callback里调用<code>ContractEventCallback#pushMeessage2MQ</code>，将监听到的log推送到MQ。在此之前，应用已经订阅了MQ的指定主题，后续的管理交由MQ。</li>
</ol>
<h4 id="观点："><a href="#观点：" class="headerlink" title="观点："></a>观点：</h4><ol>
<li>在多consumer场景协同消费等情况下，传统MQ的管理是相对复杂的，而且也有很成熟的方案和组件。因此，区块链中间件负责监听链上数据并导入MQ，后续管理消费交由MQ，各司其职，也充分利用MQ的特性，值得借鉴。</li>
<li>该方案没有持久化，每次front中间件重启之后需要重新注册。因此，需要在应用层持久化当前消费到的blockNumber，下次重启后指定fromBlock。下次重启后，很可能会造成重复消费。</li>
<li>如果同一个应用的多个实例向多个front中间件注册，由于没有持久化，并且都是记录在进程map数据结构内，不同的filterID，就会造成多个front中间件独立注册（例如向不同的链节点），造成同一个事件的数据被重复推送（例如，总共3个front，各自向3个不同的链节点注册同一个事件，则3个front中间件都会收到同一个事件，也就是被3次写入MQ）。因此，需要在应用层做好多实例下的同步，包括实例的加入/退出场景，避免重复注册监听器。</li>
<li>监听的事件通知是通过PUSH的模式实现的，也就是链上监听的lastBlockNumber是记录在链节点端的。存在一种极端的情况，例如<code>ContractEventCallback#pushMeessage2MQ</code>异常，没法推送到MQ里，当前只是记录到日志里error级别。在链节点端看来推送成功（无论是否处理成功），lastBlockNumber继续往前推进，而实际上MQ里没有这条数据，导致数据的丢失。即使后期通过日志来补发MQ，对于处理事件有先后顺序的特殊应用可能会引起连锁反应，（例如某个合约里在block N有事件一但是丢失了，block N+10里事件二，由于事件一未处理，状态对应不上，导致事件二也失败）。这种PUSH的方式在某些场景下难以接受。</li>
</ol>
<h4 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h4><ol>
<li>仍然参考引入第三方MQ的思路，将链上事件导入MQ，由MQ来管理队列消费。此处考虑引入zk + kafka。</li>
<li>改用PULL的方式。在front中间件持久化当前已经成功发送到MQ的lastBlockNumber，每次在成功发送MQ后再更新持久化的lastBlockNumber。能保证数据不会丢失，但是可能会重复加入MQ。这里的持久化可以考虑使用zk，将消费信息记录到zk上，如果交互可能会比较频繁，也可以考虑使用mysql等关系型数据库。</li>
<li>多个front节点只需要一个实例来PULL链上的event log，而且需要有且仅有唯一。可以使用zk来做分布式锁，解决多实例的加入退出下的动态选主。</li>
<li>由于在front中间件有持久化监听信息，因此即使在多个应用实例同时注册时，也可以通过判断同一个监听是否已被注册而且在运行中等状态（这里需要适当的锁），从而避免多实例重复注册的问题。</li>
</ol>
<h3 id="1-2-WeEvent框架"><a href="#1-2-WeEvent框架" class="headerlink" title="1.2 WeEvent框架"></a>1.2 <a href="https://fintech.webank.com/weevent">WeEvent</a>框架</h3><p>基于WeEvent v1.4.0版本。概念及模型参考<a href="https://weeventdoc.readthedocs.io/zh_CN/latest/introduction/core.html">核心概念</a>。consumer的实现逻辑如下图：<br><img src="/images/webank/weevent-stomp.jpg" width="80%" height="80%"></p>
<ul>
<li><strong>应用订阅主题</strong>：</li>
</ul>
<ol>
<li>通过stomp协议订阅topic，这个是websocket的使用比较广泛的报文格式。这个在weevent-broker包里。里面有mqtt（用于IoT）和stomp协议用于consumer，另外有jsonrpc和rest用于producer。参看<a href="https://weeventdoc.readthedocs.io/zh_CN/latest/introduction/core.html">接入说明</a>，其中，<strong><code>暂时不支持消息确认ACK和事务Transaction语义。</code>(</strong><a href="https://weeventdoc.readthedocs.io/zh_CN/latest/protocol/stomp.html">摘录</a>)</li>
<li>针对每个订阅，新建notifyTask并且注册。（weevent-core包）</li>
</ol>
<ul>
<li><strong><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/amop_protocol.html">AMOP</a>（Advanced Messages Onchain Protocol）协议</strong><br>链上信使协议AMOP（Advanced Messages Onchain Protocol）系统旨在为Fisco Bcos联盟链提供一个安全高效的消息信道，联盟链中的各个机构，只要部署了区块链节点，无论是共识节点还是观察节点，均可使用AMOP进行通讯（摘）。这个实际上是构建在链的单播/广播消息通信协议，支持私有话题加密通信，发送文本和文件（以后有机会再深入研究），此处可以实现链节点和链外系统的通信。此处也有Topic的概念，需要区分该Topic和event topic不是同一个概念。</li>
</ul>
<ol>
<li>链节点在出块时通过AMOP协议向<code>Consummer</code>推送<code>BLOCK_NOTIFY</code>消息。（该话题是consumer初始化时订阅的）</li>
<li><code>BlockEventListener</code>向<code>BlockNotifyQueue</code>队列加入最新的blockNumer。</li>
</ol>
<ul>
<li><strong>消费event并推送</strong></li>
</ul>
<ol>
<li>常驻线程<code>MainEventLoop</code>从<code>BlockNotifyQueue</code>poll队列内的<code>blockNumber</code>，获得最新的blockNumer</li>
<li><code>MainEventLoop</code>本地维护上次消费到的<code>lastBlock</code>，比较<code>lastBlock + 1 &lt;= blockNumber</code>，通过<code>getBlock</code>接口向链节点获取下一个区块（<code>lastBlock + 1</code>，每次只消费一个区块），从而获取区块包含的交易回执，从而decode出具体的event。</li>
<li>然后dispatch提交到各自到<code>eventQueue</code>队列内，然后更新<code>lastBlock += 1</code>。此处<code>lastBlock</code>是线程内部变量，不持久化。</li>
<li><code>NotifyTask</code>从自身的<code>eventQueue</code>poll队列内的event，然后回调<code>BrokerStomp.EventListener#onEvent</code>方法。</li>
<li><code>BrokerStomp</code>使用stomp协议里<code>SEND</code>向应用推送event。</li>
</ol>
<h4 id="观点：-1"><a href="#观点：-1" class="headerlink" title="观点："></a>观点：</h4><ol>
<li>链节点到event中间件间的AMOP协议是PUSH方式，event中间件向链节点获取区块时是PULL方式。因此，即使PULL方式偶尔失败，例如丢失若干个中间出块事件的块高，最后还是会以最大的块高为准。而获取区块getBlock使用pull的方式，可重复读，保证数据不会丢失。</li>
<li>消费<code>lastBlock</code>没有持久化，应用每次subscribe后都是按照从最新的block开始取，<strong>不支持</strong>指定(fromBlock, toBlock)消费历史数据。</li>
<li><code>BrokerStomp</code>到应用这一段的推送<strong>不支持</strong>ACK及事务，因此这部分推送有可能丢失。</li>
<li><code>weevent-processor</code>包里主要是链上的流事件处理。（这个与大数据流计算的对比有待后续分析）</li>
</ol>
<hr>
<h2 id="2-WeBankBlockchain-Governance链治理通用组件"><a href="#2-WeBankBlockchain-Governance链治理通用组件" class="headerlink" title="2. WeBankBlockchain-Governance链治理通用组件"></a><span id="governance">2. <a href="https://github.com/WeBankBlockchain/Governance-Doc">WeBankBlockchain-Governance链治理通用组件</a></span></h2><p>微众银行提出面向区块链的多方协作治理框架—— Multilateral Collaborative Governance Framework（MCGF）。具体见<a href="https://mp.weixin.qq.com/s?__biz=MzU0MDY4MDMzOA==&amp;mid=2247486381&amp;idx=1&amp;sn=caae41a2241e3b1c2cd58181ef73a1bc&amp;chksm=fb34c250cc434b46b2c1b72299c2eb71e1bd6b7597c341423c5d262f18a6e0af1628e0ba4037&amp;scene=21#wechat_redirect">白皮书</a></p>
<h3 id="2-1-WeBankBlockchain-Governance-Key-私钥管理组件"><a href="#2-1-WeBankBlockchain-Governance-Key-私钥管理组件" class="headerlink" title="2.1 WeBankBlockchain-Governance-Key 私钥管理组件"></a>2.1 WeBankBlockchain-Governance-Key 私钥管理组件</h3><ol>
<li><p>助记词生成私钥<br>参考类<code>PkeyByMnemonicService.java</code>。通过助记词<code>mnemonic</code>与密码<code>passphrase</code>进行<code>PBKDF2WithHmacSha512</code>哈希算法生成确定性的公私钥对<code>keyPair</code>和用于安全派生子密钥的<code>chaincode</code>。</p>
</li>
<li><p>私钥托管<br>参考类<code>KeyHandler.java</code>。以数据库存储为例，私钥 <strong><em>加密</em></strong> 后存储，加密的方式例如<a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Ethereum wallet file</a>(适配Ethereum的模式), 或者p12的KeyStore（密码访问模式）等。按照加密口令根据是否同时托管也分为半托管（加密口令在用户手中，加密后的私钥存放在数据库中，需要使用私钥签名时候需要同时传入加密口令解密）和全托管。全托管方式下，加密口令和加密后的私钥分库存储，降低安全风险。</p>
</li>
<li><p>私钥派生</p>
</li>
<li>私钥分片</li>
</ol>
<h3 id="2-2-WeBankBlockchain-Governance-Account-账户治理组件"><a href="#2-2-WeBankBlockchain-Governance-Account-账户治理组件" class="headerlink" title="2.2 WeBankBlockchain-Governance-Account 账户治理组件"></a>2.2 WeBankBlockchain-Governance-Account 账户治理组件</h3><p>增加<code>普通账户（Normal Account）</code>的概念，与外部账户一对一绑定，在链上的身份用的是普通账户的地址。即<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ------------------------      --------       --------</span><br><span class="line">| 外部账户(用户手持的公私钥) | -&gt; | 普通账户 | -&gt; | 应用合约 |</span><br><span class="line"> ------------------------      --------       --------</span><br></pre></td></tr></table></figure><br>因此，管理员可以添加，替换，冻结，解冻普通账户（也可以由用户自身提出），例如用户遗失/泄露私钥的场景下，只需要更新&lt;外部, 普通&gt;账户对应关系，而链上的应用合约对应的普通账户不变。应用合约需要引入<code>AccountManager.sol</code>，使用<code>_accountManager</code>里记录的普通用户地址来代替<code>msg.sender</code>来判断身份权限。</p>
<p>管理员的角色可以分类两类，一类是超级管理员（唯一），一类是管员委员会（投票决策）。部署的合约分别是<code>AdminGovernBuilder.sol</code>和<code>（Weight）VoteGovernBuilder.sol</code>。以<code>AdminGovernBuilder.sol</code>为例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AdminGovernBuilder.sol</span></span><br><span class="line"><span class="comment">// 部署合约，目的是为了实例化以下的合约。</span></span><br><span class="line">contract AdminGovernBuilder &#123;</span><br><span class="line">  address public _governance;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">    WEGovernance governance = <span class="keyword">new</span> WEGovernance(<span class="number">0</span>);</span><br><span class="line">    governance.setOwner(msg.sender);</span><br><span class="line">    _governance = address(governance);</span><br><span class="line">    address _accountManager = governance.getAccountManager();</span><br><span class="line">    AccountManager accountManager = AccountManager(_accountManager);</span><br><span class="line">    accountManager.newAccount(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getGovernance</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAccountManager</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WEGovernance.sol</span></span><br><span class="line"><span class="comment">// 该合约是管理规则，例如在管理委员会方式下，发起投票requestVote和各个委员vote的汇总计算逻辑都是在此合约里。</span></span><br><span class="line">contract WEGovernance is WEBoardVoteGuard &#123;</span><br><span class="line">  address _accountManager;</span><br><span class="line">  <span class="comment">// 0: admin-mode; 1: vote-mode.</span></span><br><span class="line">  uint8 public _mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params">uint8 mode</span>) <span class="title">public</span> &#123;</span><br><span class="line">    _mode = mode;</span><br><span class="line">    AccountManager accountManager = <span class="keyword">new</span> AccountManager();</span><br><span class="line">    _accountManager = address(accountManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起投票，登记该投票信息</span></span><br><span class="line">  <span class="comment">// return id : 唯一标志提案，与vote方法的入参相对应</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params">uint8 txType, ...</span>) <span class="title">external</span> <span class="title">validVoter</span> <span class="title">returns</span> (<span class="params">bool b, uint256 id</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 投票</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">vote</span>(<span class="params">uint256 id, bool flag</span>) <span class="title">external</span> <span class="title">validVoter</span> <span class="title">returns</span> (<span class="params">bool b</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AccountManager.sol</span></span><br><span class="line"><span class="comment">// &lt;外部, 普通&gt;账户对应关系的存放</span></span><br><span class="line">contract AccountManager is WEBasicAuth &#123;</span><br><span class="line">  <span class="comment">// 外部账户 -&gt; 普通账户</span></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> address) _externalAccountMapping;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通账户 -&gt; 外部账户</span></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> address) _userAccountMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EvidenceDemo.sol</span></span><br><span class="line"><span class="comment">// 应用合约示例。引入AccountManager即可</span></span><br><span class="line">contract EvidenceDemo &#123;</span><br><span class="line">  address public _owner;</span><br><span class="line">  AccountManager _accountManager;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params">address accountManager</span>) <span class="title">public</span> &#123;</span><br><span class="line">    _accountManager = AccountManager(accountManager);</span><br><span class="line">    _owner = _accountManager.getUserAccount(msg.sender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用_accountManager里记录的普通用户地址来代替 msg.sender</span></span><br><span class="line">  modifier <span class="function"><span class="title">onlyOwner</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    address userAccountAddress = _accountManager.getUserAccount(msg.sender);</span><br><span class="line">    <span class="built_in">require</span>(userAccountAddress == _owner, <span class="string">&quot;Not admin&quot;</span>);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-WeBankBlockchain-Governance-Auth-权限治理组件"><a href="#2-3-WeBankBlockchain-Governance-Auth-权限治理组件" class="headerlink" title="2.3 WeBankBlockchain-Governance-Auth 权限治理组件"></a>2.3 WeBankBlockchain-Governance-Auth 权限治理组件</h3><p>与账户治理组件非常类似，也是引入了权限管理合约，由超级管理员或者管理员委员会进行管理。在应用合约里访问权限管理合约，调用<code>canCallFunction</code>来判断是否可以访问指定的合约方法。架构图如下：<br><img src="/images/webank/webank-governance-auth.jpg" width="50%" height="50%"></p>
<hr>
<h2 id="3-WeBankBlockchain-Data数据治理通用组件"><a href="#3-WeBankBlockchain-Data数据治理通用组件" class="headerlink" title="3. WeBankBlockchain-Data数据治理通用组件"></a><span id="data">3. WeBankBlockchain-Data数据治理通用组件</span></h2><p>参考<a href="https://github.com/WeBankBlockchain/Data-Doc">文档</a></p>
<h3 id="3-1-WeBankBlockchain-Data-Reconcile对账服务"><a href="#3-1-WeBankBlockchain-Data-Reconcile对账服务" class="headerlink" title="3.1 WeBankBlockchain-Data-Reconcile对账服务"></a>3.1 WeBankBlockchain-Data-Reconcile对账服务</h3><p>金融机构特别是央行/商业银行间清结算，而且在当前区块链的性能限制条件下，批量定时的对账是常采用的方式。这个组件其实是比较完成的对账项目代码，饱含了基本流程。具体参考<a href="https://data-doc.readthedocs.io/zh_CN/dev/docs/WeBankBlockchain-Data-Reconcile/index.html">文档</a>。流程如下图所示：<br><img src="/images/webank/data-reconcile.jpg" width="50%" height="50%"></p>
<p>以正向定时任务为例，代码里主要采用了责任链的方式，具体配置在<code>ReconcileHandlerFactory.java</code>类中。具体的hanlder chain如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ------------------------------------------      ------------------------------------------------------</span><br><span class="line">| ReconcileTaskHandler(创建任务，记录在数据库) | -&gt; | ReconcileFileObtainHandler（从FTP/区块链上获取对账文件） |  </span><br><span class="line"> ------------------------------------------      ------------------------------------------------------</span><br><span class="line">         ------------------------------------------------------      ------------------------------------------</span><br><span class="line">    -&gt; | ReconcileExecuteHandler（对账过程，具体每条数据以索引对齐） | -&gt; | ReconcileResultHandler（将对账结果上传到FTP）｜</span><br><span class="line">         ------------------------------------------------------      ------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>实际过程中，需要考虑数据/文件的加密，特别是在多方对账的场景，需要在多个层面做好数据加密和隔离，这点在项目中没有体现。例如，上链方生成对称密钥，对每笔数据（例如涉及到金额的敏感字段等）使用对称密钥加密，并且在上链的数据中附带上该对称密钥的标志。上链方采用对账方的公钥对对称密钥进行加密，并且通过报文发送给对账方。对账方使用自己的私钥解密后，进而对链上数据进行对称解密。另外，上链方在FTP中存放的对账文件，也需要相应的进行加密写入，并且，不同的对账方也需要相互隔离，在FTP上使用不同的路径，并且配置可访问权限。</p>
]]></content>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约权限管理</title>
    <url>//articles/sc-authorization/</url>
    <content><![CDATA[<h3 id="1-合约内授权"><a href="#1-合约内授权" class="headerlink" title="1. 合约内授权"></a>1. 合约内授权</h3><p>业务智能合约内，可能会针对某些用户给予指定的数据访问权，或者调用方法的权限，涉及到合约内数据的授权。以下是solidity伪代码，适用于该业务合约由权威机构管理，也就是存在administrator角色统一分配权限，其他只能作为参与方访问授权数据。相应的可以参考微众银行<a href="https://github.com/WeBankBlockchain/Governance-Authority/tree/master/src/main/contracts">权限治理合约</a>，将用户权限按照分组在权限合约里统一管理，应用合约接口粒度的权限。<br></p><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">contract Admin {</span><br><span class="line">  address public administrator;</span><br><span class="line"></span><br><span class="line">  modifier <span class="function"><span class="title">admin</span>(<span class="params"></span>)</span> {</span><br><span class="line">      <span class="built_in">require</span>(msg.sender == administrator, <span class="string">"Only called by administrator"</span>);</span><br><span class="line">      _;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transferAdmin</span>(<span class="params">address newAdministrator</span>) <span class="title">admin</span> <span class="title">public</span> </span>{</span><br><span class="line">      administrator = newAdministrator;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务合约（包含权限管理）</span></span><br><span class="line">contract Service is Admin {</span><br><span class="line">  mapping(<span class="function"><span class="params">uint256</span> =&gt;</span> mapping(<span class="function"><span class="params">address</span> =&gt;</span> bool)) private _authorized;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> {</span><br><span class="line">    administrator = msg.sender;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只有administrator才有权限授权给userAddr</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">authourize</span>(<span class="params">uint256 itemID, address userAddr</span>) <span class="title">admin</span> <span class="title">public</span> </span>{</span><br><span class="line">    _authorized[itemID][userAddr] = <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 授权用户才能操作特定数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSth</span>(<span class="params">uint256 itemID</span>) <span class="title">admin</span> <span class="title">public</span> </span>{</span><br><span class="line">    <span class="built_in">require</span>(_authorized[itemID][msg.sender] == <span class="literal">true</span>, <span class="string">"Unthorized"</span>);</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<span id="more"></span>
<h3 id="2-应用授权"><a href="#2-应用授权" class="headerlink" title="2. 应用授权"></a>2. 应用授权</h3><p>回顾上一篇文章提到的钱包（应用商店）拓扑，平台会存在共用的合约，用户通过某个应用（类似于dapp）来调用这个平台合约（只能通过用户的身份而不是应用的身份，也就是msg.sender是用户身份合约地址）。此处涉及到两个验证，一是验证该应用被平台授权调用该合约，二是验证该用户被该应用授权可以通过来调用该合约。可以遵循以下三个步骤：</p>
<ol>
<li>用户需要在应用获得授权，应用会在用户的身份合约里添加标签（可以理解为应用对用户的授权签名）。</li>
<li>当用户请求平台合约时，平台合约会根绝用户的身份地址msg.sender去查找到用户的身份合约，并且从中读到相应的应用，以及应用打上的标签。</li>
<li>平台合约会到监管授权合约中去认证，确认应用已授权后，平台合约校验用户身份合约里应用标签的真实性。则用户可以调用此平台合约。</li>
</ol>
]]></content>
      <tags>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>DID分布式身份（2） - 账户体系架构</title>
    <url>//articles/did-account-system/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="85f9cc2b3ab6a76c0049d2c74b4b82a8996bddea3918cb86cac6c9958b8086d7">3175488eedc729df0c7d358c640da99e5db97a13f852973918f00ac21570e613c8066394a45ce05b6fb350006fc572aba6ddbb11c5d81918b1e6e787347dc4090eae74287cb56e112850ed5877a00b0c38f7f72d1f82c0e6f33952297af2eed6f7e9b9281efae3b827cd823ad0dc6aa0166f8a5cc5ecd391fed4d5b8059855e4b12184333ed28d40b5517345f07b9888b06a7e76d343f56507d72c8582dd621f2039d1aa7b5504f362d8fc942bcdd04dca63d6e5efc7eeae08cd8b39d326b29103078d812dc280406ecd2c91a900594e6fc11eca8b2482d4cf277f5bcbcc4ed82c645e83227a11cd214ccb74dadd5cafd45c62883845bcaab687c4d69160d93bcc5de69c09c32851fd3f57742098440818ab40f93ed0a565d8d165f42727510c5392021a91caf4cadf7945160e01c213337bb444f0cca83d45a5ac63cc8e06a58ad550577a3aab00e1ea13be33de5b3bc87ab4f6b50c622a7bec8543ce46e36d4652c118be6348b8ccf3ce5dffe2ed847377085fb9ea06c6fb61e1e0ae81958e701eb5898c0188a48cfaccecdd42bd9f1f16d9e9f88cd063a7dd37c41547a37bea54a797c92fce40aa98f0c37a30373f19d961855b7e686a10a0a82df791733494a2625f79b98285abc4ce56fd40c2d909c29bdad008923115ed39413b141c053df5d6145f8290401f3a9c6d4580582ab3cc090209a20b04b93b0f90ccf57534a0ecd275f899f4c884a59193508c325a8a8d1108fa16c3799d3e2a0523966be55fe98e815cfcfb7bb376a9530a30638767b7385ab803fcbb0946288a7440feb62f8a1e493996a2ba119f864da5f5c73afc5661532a18013e60b765b3d0a987a8fc5e32042e6f0849f7b8b23254bacb8f89683a7b4acb2477fb69212355f43136eec23f2306993f9f9bf21faf240ddcc19b2ccbf5331ab92f0700c7f5bf3c8c56109b68934eb38022d8815ff6155991d80833699ad4eafbd8abb22af92c15ecff47d68fdc4f9c4a5c3058e411faea0fdd78492eeea731ee246f041ebf026a7987c22ea8c0cc509d1cac78d55033616cf130422db38593b5950e689cc58adc0f798ea0ba1ddab47ed328f47e92070565267a6b904f54fc48cf9bc17ca1266382388b4ebbef84a758dfae8b6749ca729588ab225b2ed0f5bb7a0df4b2dea95d5d13f39c4a326d143da10ea9e09220f678c20bead66e68940ea1ecde75df11aaff69ec3028eb448824bb980d8db802d33dd93fbd72de5b55ab0107eab230a149b7a07457958c2973f8aebdbb368391dd3754c061194c325548c06f06ba17242ab958b9210f62420fecbdac09881ccb31cd67ed4fbbb57f510600f45c17dca25dc441b38065070ec147d348d8282e79c28cebd1aa27838e258d61abe8cace4c98a98392d7e0cb58b9ca61ddc5a4d87b58b73f8a2276b158c3c3934f7c4466c87f3a77bd0e9674446eb95e233dd7da36caf7adec2f158b95c1c9e63861211e1042901e7917b84d7ab33bd3bf0298ab2b688ec990d06d66828cce8217da621d5b9cde59e6daf58f6245538e71153e48468ceb6c89b959e64334afa254646fa0e6aac1ee04284f2791fe811538703e9e6d0300bdce76c3534ba1be054d3f2bc5c507e31d59d2566c8aec38621fe6332509100ec1adddb101c95f09b000ac09e2922ac817e43de927a341a910e50e9f1f29a22b0d0a0cf3ac933dcbea0f76b9ee624cc125cb48222d20d7eea445f104bf759f485dee96fada1599ab9cfb5288040195644e5e4391355605f5842300743dd2bbcfc0035ba5f69b78e0668fed9b30847eb5be6bf088b463cca359b2fe6c328c022b2b6f61157e7d4c37902fb1d540396800a083bdb8007c5287983a44b8b7acde17d3d4ed5858bd72ba2d04707043a11231d722e588a9545c36fbd3bee2164c4fd7c0700c385fdcbc81ff57d210103d40725e1cda2d61e4177756d2677dd21715850f5c45c3bd3d59965e7a1d37a88ad0c3291fa660136c261cd11f8f8173134bc413c9038397903ae981950b4f1f6f7237ecd6a3369988dbcc7a1f34f7369cb824a9277cef9f65151a48e47705f9d909fb468e778bbbb25dc3e17ece3e059a432e4f4abb3f7fe18e3fd989e02f55be66db8470d71559cea81c275c32af30425abe52e7d99d04e165e02a4c796a3938a05eacb0a33064a6748d680206e834d6ed587d71dd5db55c36a3ad06126038b90adca821be1a8d6a1da15c654af18644c21b1b999e7dcfdc37143e65cb386727dcb5166d933d474123eb6b70856ae0895cf0b821a02e61cff29a29a6c8cde840f39dfdbabab36b83eb6309e2658bf018935c8f717036b1ad5c4ab3cd86cd5a644ae94fd3253342037d2cc875d7be4d58d3cd4e0b2b86c373a8c3a15483b49f15d6272a546160e2a281e069b2812bd5fa3585323001cb91e9ef507041328899f279195ed3884e2841386b3e3105b6c677b37ceda824c2e9f9a3a7e19ac5319ba2c9372feaf2474e8e02955da1650c26d5ecd94517f862dc66f2b71ed7fc9b852f6ae5348c58d5cf064fe32c3ff73f7f74e98b1a3ed9861c3482962826171bf4b768814704748424b097fd5b2bb05652d5a048a376d9bbab2707a7589db111ed28f1c0e97eceb6d0d3ac1bac261ff04465fc17eef0aef515064276d7a943dd8869cc58b056021bece30356abde90ac64e6c1eafab7641cd97658812cb88d0cb1302849140c580789e070adde50a1845a7debd4793725b02410b42871c6943bc12570a1392820deeabd4c52e6f9123d5c79031ea03ec569496523fe8b07659ebd9f26fcd708b3256ace8f97c379ddda62ed3a2f5776388547a4f6eaf8f99bd9a7c0286ca76e23dedb6fa85b26dbae8463d5e2f0e907b9e6890975fb95e9bbf19837315341ddb4d121d53b6bd70aca4ae0aa385364849dbf95c624c1bfd4b98872c742a00091b28d80650d14e246acba1f911a2c9ff84eb2674d071ef877ffe43718b30332a8b1f6b57692e4ebf471d63466267439d7599db34e19d26da843619ee4e7f7292a2309056b808321b5d3436595a5c95d3ce58c6a3fbabb7f5bb0e82b4ac0f97eb2b7f3b18476695f9a93b02b1bb2ea0f6c08b4da0cf4409f7f7a8c15e726a5cff26cf9f0e1f58defb2862d76fd0cf8192f8be06ae71ee7e47d53dbab5b518566ad3f9c77083bd75abf19b6d80f351b4d74cb11802defb22db2e22a4c544ac716c13c86b01856bf9606bec8138f72bbf3653b399f278b4b1e2543cad890ce02db6b0db1472cc23e1c8cb5067db8bfba0898e428c03b9f66a66573e75b5b9c550a8a905eb11c34361c29fe9b1e0ae32bf63969b342459ea55dc5c874ceda15c8e342e426ddbbc3d2d7a7da0120dec20fe0f2dbf96099bf3a51a4c0179e15039dc6e566e6aadabda78c431a30e60636b0bb35a5713e9f125f59e774e1f71300a3508437990ef173fe4111b9e410641f00b1cd42c5d9639ff3e60a3338e901c32e9c4b69065aa558179182210186b010dbcafbe3200e8d55c734e27e752f6893984b145d55196db789b06aa0226ccffd6b11b0df3560d8f0fe026373aba207933d1608816fd020ec46728bb8082b824f2df49298e4a759b510450a27679ec11ff088d046f540b4b6c11458302680ff428f0759f65495e6d42131058c9d3f0f03c6e49a6b8e2456ee463897d0e4c47688383b7d435ed749c09e4997fcbf25aef3ee67849332dc831940ef8cb2308bf4b28b9361dfa0f353453540f5788210a7d3b968947691edfd1c25e9c79b7ce7a0ec99e4ce01cbabd8e58c0b86ba7f6d05cfc0c9eec112d4ef7894f94e3e83489b42ea58d88b61ddb3dfc8b21bd0ac34d4de2071eda39f177b7d0d0fbb3b2d02d8e96aa87ddc1dad98c129fa7ca75c3e5562e9d7959438a80975957940aaae179dbb0294fba855c3b65d19689887cc2da90685ab3e2d9687164b7a6bc434a76462ada862e2331fc6b288312b9bf36eb66139115fde92f41e242cab904ca854f9f6db5ac5a5d304a8acdc6fc13f9a8aac3352301af1413ee0a4d7f1e56145659ff41b90da40817575850783b9e9d54faed518b49f16d23408629ddbb8bbc4a2ab25f8f3cf1cbfa3edd04e987379228f0d6a19612f7b1044776136725a255f4e95a0307cc872a7f910303710a25837d3c9dfd62ca02081147df7523741fcfacab533add4d56b6618bec200e2adf7adda9321e3123a7abf3233a41e401b73cdd04a33059ad707560c79188b81079b961e2352eceaccf9999b9537f672b42cea98e972afa1379d7186dad922b42331feeab3b7ce6732fc0dc75008401de6b0be1e9fbabce484a94b28affb27dfbb3fd7ceecd8f6899f762ea14ebc19a2fab49d64c64015a92782defdb3940c33d4fd80fc25b4d1cf365733f9fd3f2ef85a9277550f2e74b366450b3f84df947899e36d476a25e3d758a63cfbab7847b59cd717976ba966aa0f1b30802afbbd31c50969a5a6da10bca2c7cd9be1488c4b01b967345f93a9972472f46e29092ac9259cf56c1793cbe3b2acb06329097d6d4fb0d6e8db54bf7b24cdcec02ab949858819711bb5bce5d5f473784c8a914caadb272a2def6f4910b89252c537776fde0183e17b25b746eaf999822a4f1601f3381fa7107c9c82dabf49c524b5b3fc84bfeca77d28169f847aedb7e36ad57041e26a95f649747027db3cfb6b652edb6a16206bd9935b9a397e30a843b220d55aa4a53d492c2007f0475256c04e5a01803f62db63f3b6314c8397503a0f763ee1a7459526f35d8a988b58fd2b5401ceb04d30905d9fe3a6e7e211780cf495c981732e66ad243210c512ace597e1a29778c83e78797eba03a66cb8447741034b67cfc07b08a6ce225e4cdb9ecaedda1be68844235a0d6f17ba26c4e1ba49cb6ee15ea45f7e8a544710cb3dab67ed9451b5da54282a7cfcc730edad60d80f962dadcaabdad539acd058e6b4030ccccf3bce9e83c61cd88f510310fc2f263129a11987bc368ab3b454ea6e9fda444426749b5b45f199ec94e920a4d18f36269ffb65a0f065795c5de373af9e654d86305490a01e6e3ef5f1ed3da3c63327e70cd2fbf710c96c0145b68f4579cf287f99830080fbe11133d8bb23124df994e0d12da517c9def88d928604b556d9a3b091e0a7fe9f7da848c57394b82c87fca3b5c3b407f6bb2094327cbdd6b4fd27a742d12de1bd81eb7144cf1926030144fb3c14078b7759c37858585859ddc7f6c0c684af957a1d8ca4701d1adbf99723de5c25fc5e1d3fa9cc8744ef47d3a012d95eb9cdd231c886a224b6f559a524839a5672bf0549eee11b3f28cd8f7c72af87719caeae7687ea2035717b15de71fe74837f61410222a41a9271aab44eb431a2e6a64a13dae62be8c4af68e0b9008c0d0d0389db3aa62724a20f2d5e232560778a6065ae45ea0f79e69ca8d2a94bf5fb65675c17bd503f9af0552b5d352fc6084bbb7d671feed13593e2c01a6fbcfd3d8f66389215fcb37045b1bff49baa106632b25eaa8cb56405306dd3562c3aef561971e512411b0c8f748ab430d3a992cab316ce3dfd0977909c5a6571e51985a66f2005ec139fd77687d640277cd760726e0ed2ec4f47c92c99cb1dc53a85134ab243e13d2c3476317c9c198ac517a16a48e5644eb29d95cf10143be47ab30823e8598bc7cf6c3e463ca2bd2a3dcf28a90de566d16028d06d13bd67c94f9f5f1a446683c0f31b0327ef9f78d2892dfd57948e62ea8c338004599800088fa56de83587ce0e29f2554f20c4cb58c090b5a886bae32ec077f194e3848bec5fa70ffe58de35503cd44575c0dea1f6c220d9b23ebef56869c65ecdc4b8c45ed517b953dec63ec16b52f1d1119b09824920b0e6915f79595ce97a5e630839abfb78d0f03f2c8018a9f721a483da5d9179ea58e343520ed2f47f33415daaaa54345677ed3fb67f6650b93959f1e542073570fcb6c8f2b7b489c02e87387e92a9ddd39aab8988e76449224d3c6e25ed8ad53c2354bf04000376f9497b0713dbb9307ac6abd4065954da729858cdf272d10e0cc0b73bab73d1682759ad254d020cc6a890c61f59a8d04751e598abbb0ad2f39afdf8997c7900b500d00039eca00a360cddf1d064859948af17d291af2f3b49c75b6c6b5ad1aeeec90ad1dc2f8ed87150edb00a74aad670123c0a919ee88841dab900e018c380c831c6339f0891c08d3430ab627697cc510ef544d8c1846b2bb46b0407f4f35444976682cb00fdb040ab49284d314410a5be30300fabb282ec1cf27b1dd7fdc35c76f6a3ccee6a361abd8fe4abfb24b0d2b78489ba24f7cc7eef6b8a75cdf3fd58c793ef3956a1c98dea625a3d2994f10a42e4f312f315ca3bc09668e5cbe116df75927463694cc3d0c90c9b3f80e320340a7f86a92862e4aa66b013f0d436de1dfb22b5f91e00ac628f6967c68e6db882189b25f17ecaa298c7c26134636dbfa549ae1db9cf777fd40ab3592c5858f7cfbf1fdf7526b300daa19f75fad6ad1b2a1c8f9d78c43ec423f92df0b16895807fbaf7b80dca87319a8bf574ce4076b09d1fdca57d82b2483656cb5ebd8c042316ecfb3d032ebb50e9439602a4d3524f9215214daea8f6676b6ef476e4258e347ffd0a8aa528f88ad8b05845229ef2e39beca238c1bcf6b073068ca2e104ac32e041ee72260bc82a94248fe63ea8e1184222c2602c1eea991f7e21eea0d76bd4a663dad64cf08e630453f7f3f38a4da51a955fe829c2c8131d2fe226ca34f4e400af7b83f199f71ee8defdfbaae78172e3124929f97e6208cdd37d92586c285477b3bfdd24535d26c450bdc90537bf3af442f806f8b0d3900500b263d741b9f8d5be5e1d72cd81a2b0730fa66805cbabf190d6b6558f9347ad7dff42e9049eecfc3156945ea32fd51d9aaf23812c845f0cbd40bdf2d0272f2ed59e78c608e669e78a5a0e9a52aa09ce4d0bff39b7d573420d8daf37e38ec2531f216a9a7add1801ce0565b745bb8be47a5963c2eabb667109855dfe5668083a1056ac73a3d7ed744b343f2541ba36b2646a7c5595ba6315990dfa9368ac4f67fded9252f50a84ce2b6426cc09dd6ea41be9ff174cd0841be298fc573c1409d6820365048bc98871fd4bf4a0d8bfbdc863c644fecf013533c98be407b15d79a21c5152cbf82b9299f57d3d41983e4fd7f44a3735fe8e9c737e94c9aec7154686d5e4f02867b7575d413e96bdbea46721c21820d7e262ea21bf21913583823b4c1af2b50e8f0ecb0eb69592ce46ceea167c0f164d9a7ce891ff0f70a6d617906bcbe26b69297266dc051784f580c0b3cc84e32a90b35db1fe343159b733f55897519a2137243739233be88a9160525c7f8e3fc06ed9c4a0a84d18c42df8dd8e1c14ead6baf3b9b56a88995af82788e9f594323abd0906b25c59043f041441da62a0d901849c34695357e62dc96895d9c39fd9e29a241239fc61e6b69227996f75508c062d6587a763c7c10042ba2bab6b23ec832966bc2dd0fb22ee982b46ca4c6633105cb3cf71788ba775dfc38f3227dd8a25d37fc7bbb1a5935fdbc4af55b0a484ca4b97022c702eeb7d3c2d5f9bd4a7c999e02b427bcaef1fa60f9aa9af4b079a419440d693fdc3fa82809e510f2da6e6b3c8d19c541bf784f922a83df1d7cb0b1352531c65bbd04b90a57e2c4cb1446388e406829e117d939f02823b37a649d253f5e013caa0073232b72fd8e2feae4824905c2a752c337a28ec2367ea570699b4e85c92774fe1c02e05cd3d2755782f44e8f199c18a788f6e0c6b27100f23793f5fcd3bb389aae83a416753ccbd623c1e93a57db2d3a008b7585820b05fe1c29edc52ac8b8ac1086a2f4d2c69f4d24d23d6c2e659859ef12802bbb94a47bda27281e03b680a0b0b35c59de9320873aae9b486a463a8139fa8a74e23b8cc9bd818e36553d4d3d253198edcfd7715d45b039a5297058ed63ff53035347807f394c877a7d8d3e6bcbe5df6fa568633265728e2bface05af2f45084a39882b902bcc72ce504058be5950df13d335db7c75b80a269edf3fa81452f318e670ada88661ae44392a50ff3315982b0b1b1d44b826aad3d4f87df7635737c1b0b094b7976b8d204e985814fda2a474f4a8d3b3326e724925b164048c82baf6e030ec2ccd933ff633bf5b80716b88b0a965766095a5740ed6ab13dbdb3f79639b0a1afe8a33f44632904ace764ba205c959b7d27a0f91f4105d6c2d46e1b6acc0ba46a8b50cd2b76f8dcccc2406ed53c45dd7ee6de2f3865c5194a9cd2eccd3750b1daac5c25d9074cb2b2bf7d99ad5fc3107c3e0365865a5b615a67b2440d6dc464c6e3f9c03c10e92b8571c4eae1980e15ca02c9c365a29465d0414f27a38086dbe7ac0b7c59937f7b5b18e67c775aab94e40c1c330f05e3d08e7e0ebd2cf46cbc0c8aacc53cb19b69b3c72f9b60a3e6e423b2c0f06fc0a41bd4d260a4421e58b96353dc879d990b93f2570f291eddf8d763a0caf5e3c47f272caf6a6ec2b0e6ba529bb089bb778902bf6bee0c4c1c344c52feaf9e42bd4891248102a920b07275ce7fe8b181f668bc144beb8d03ea46a6ae20699f56774b62e3c1ea46e3f01227293adf7e2887698958c4d8b49fa6c3b7d54a3f9d823d2eed2158558e095c4cad97dda24235ee4b85c2dac261b8f27a888a853bcc3a63d2ccf772cb4bf406a1dc13936340d5fefd8116ff969fa0129ef2728d0385bed14a3b7ba197e16f5d0623a3e3f85ee1647871a6dcb4d18ed5a043ba5f51a1650c7ef4adfae4106f63c1876e0450c5000c516dfa1686f959b28c9f2e6c25913c974980070bb312e3e6f1cda8e1646ca80fc94baf8e512d4a6cc6da1d0fa2d401bc013d7988154e42c9ca5b331e7a7be2674bfc73812c2ab33a488ccfbd8624d1b175243931787c529bbbe40d12653829158ad4dce286d0092340ea704260f6eaf67c8ac6fed11e8dfa9863f1fef81d3ee72c02e70a358360ca480e7590d50e3f7f982587474b4c1cfeb2e8acc1e6e85a97f843a4e34ea7618a888506bc8d36ea5fb857e1bfed796a8b16755d4ee8723262ee488814d9a34054bf03ed0fbab25675b5e9acc82d9bbb4b004562594cba90d6dca785e17dd07b5b96b53c139b0e12a12776a0a166807cc96494b3ccf39d2c05e83c4571f6dc13b55cb3548f4fc8bf50dd63555c1e01af67173765771b378f4347612b32b23111a767af85237f776a75809a0f6bdf839de1a08f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Post is cheap, show me the password</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>DID分布式身份（1） - W3C规范</title>
    <url>//articles/did-w3c/</url>
    <content><![CDATA[<h2 id="DID-decentralized-identifier-分布式身份的特点："><a href="#DID-decentralized-identifier-分布式身份的特点：" class="headerlink" title="DID(decentralized identifier)分布式身份的特点："></a>DID(decentralized identifier)分布式身份的特点：</h2><ul>
<li><strong>自主</strong>。实体可自主完成DID的注册、解析、更新或撤销操作（上链），⽆需中央注册机构实现<strong>全局唯⼀性</strong>。</li>
<li><strong>身份互通</strong>。多个dapp应用可以共用一个DID，共用一套身份账户体系。</li>
<li><strong>隐私</strong>。⼀个实体可以拥有多个身份，由实体自⼰进⾏管理、维护，不同的身份之间没有关联信息，避免身份信息被第三⽅归集。同时，未授权的第三方dapp应用无法得知DID对应的具体用户信息。</li>
</ul>
<h2 id="W3C标准"><a href="#W3C标准" class="headerlink" title="W3C标准"></a>W3C标准</h2><p>认可度较高，是行业的主要标准，大多数平台遵从W3C的规范，这样数据可以方便移植和共享，实现底层区块链平台的兼容。</p>
<h3 id="1-格式规范"><a href="#1-格式规范" class="headerlink" title="1. 格式规范"></a>1. 格式规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scheme:DID Method:DID Method Specific String</span><br></pre></td></tr></table></figure>
<ul>
<li>Scheme : 通常固定为did，指明该串为DID标志</li>
<li>DID Method : 指定具体遵从的格式规范，通常为不同的服务运营商</li>
<li>DID Method Specific String ：具体的实体的标志，通常为URL或者URI标识符。<br>例如，微众的WeIdentity为 <code>did:weid:101:0x0086eb1f712ebc6f1c276e12ec21</code>, 具体参看Ref[2]。</li>
</ul>
<h3 id="2-DID文档（Document）"><a href="#2-DID文档（Document）" class="headerlink" title="2. DID文档（Document）"></a>2. DID文档（Document）</h3><p>JSON结构，自描述的文档，通常包含有DID本身，公钥信息等内容，可支持解析，更新，撤销等功能。可以存在区块链或者非区块链的分布式账本底层平台，或者存放在IPFS等分布式文件系统里。可以理解成DID与Document是K-V结构。具体字段格式内容参看Ref1。</p>
<h3 id="3-可验证声明（Verifiable-Credential）"><a href="#3-可验证声明（Verifiable-Credential）" class="headerlink" title="3. 可验证声明（Verifiable Credential）"></a>3. 可验证声明（Verifiable Credential）</h3><ul>
<li>建立DID体系的价值所在。DID可以自管理，但是只有被相关方认证过的身份才会被信任，才有业务上的价值。</li>
<li>包含若⼲个“声明(claims) ”。声明信息是与身份关联的属性信息，如姓名，年龄、学历、职业等等。</li>
<li>凭证由发⾏者签名，可通过密码学证明是否由凭证中声称的实体签发且未被篡改，因此被称为可验证凭证。</li>
<li>VC也可以依赖于区块链实现流转，验证。</li>
<li><strong>可以通过授权控制，只透露Document里的指定字段。结合零知识证明，可以只证明某些论断，而不透露具体的信息。</strong>  </li>
<li>模型参看<a href="https://w3c.github.io/vc-data-model/#terminology">W3C Draft: Verifiable Credentials Data Model 1.0</a><br><img src="/images/did-verifiable-credential.jpg" alt=""></li>
</ul>
<p>Ref：</p>
<blockquote>
<ol>
<li><a href="https://w3c.github.io/did-core/">W3C Draft: Decentralized Identifiers (DIDs) v1.0</a>: W3C的规范介绍。</li>
<li><a href="https://weidentity.readthedocs.io/zh_CN/latest/docs/weidentity-spec.html">WeIdentity 规范</a>： 微众的DID规范介绍，科普</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>链上隐私数据保护</title>
    <url>//articles/privacy-on-chain/</url>
    <content><![CDATA[<p>由于区块链各参与方可能存在利益冲突，不愿意将私有数据上链，催生了链上隐私数据的需求。对于不同的隐私等级存在相应的处理方式。</p>
<ol>
<li><strong>短期内隐私数据</strong>。指的是易变数据，一定期限后该数据的价值降低，例如波动的商品成交价。因为密码学破解在可预见的短期内无法达成，可以认为安全风险很小，因此可以使用流行的对称加密/非对称加密的方式，密文上链，相关方使用链下方式或者链上方式交换密钥。甚至可以单笔交易更换密钥，这样对于可变但是数值范围有限的数据，例如状态值，单价/数量等数值，则避免了统计学上破解。</li>
<li><strong>长期固定隐私数据</strong>。例如身份证号码，企业社会信用代码等，该数据长期不变，存在若干年后由于量子计算或者相应的密码学被破解导致泄露（当然，随着破解方案的演进，加密方案也会相应的演进，但是对于链上的历史数据则极易受到新的破解方案的威胁）。因此，链上可以保存数值hash，具体的数据链下交换，使用链上的hash值作为验证。同时，对于数值类等取值空间有限的，可以针对每笔交易数据添加盐值后（同样通过链下交换），再做hash上链，避免彩虹表攻击。</li>
</ol>
<span id="more"></span>
<hr>
<h3 id="Fabric的private-data设计"><a href="#Fabric的private-data设计" class="headerlink" title="Fabric的private data设计"></a>Fabric的private data设计</h3><h4 id="1-transient-data-vs-transient-data-store-vs-private-data-collection"><a href="#1-transient-data-vs-transient-data-store-vs-private-data-collection" class="headerlink" title="1. transient data vs. transient data store vs. private data collection"></a>1. transient data vs. transient data store vs. private data collection</h4><ul>
<li>transient data: 链码chaincode的输入数据，client发起交易时指定，endorser在背书过程中，将这些数据以gossip的方式点对点发送到其他的拥有权限的相关节点（例如同属于该private data collection的不同组织），链上block里的交易信息并不会包含有这些数据。</li>
<li>transient data store: 中间存储，存放transient data进行运算后的RW-set，方便后续的gossip交换到其他的authorized节点，在commit阶段，private data hash将会与该部分数据进行校验，无误后提交到private data collection，然后清除transient data store。</li>
<li>private data collection: 长期存储（由blockToLive参数控制生命）区块执行之后的world state世界状态里，包含有public state和private state，（分别对应着public RW-set和private RW-set）这部分是通过gossip协议从其他节点发送过来的，针对相关的org开放读写权限。包含原始数据和该数据的hash值组成，这样的hash值会被在commit阶段比较private RW-set，以及后续在chaincode里确认该笔数据或者交易的存在真实性。</li>
</ul>
<p><img src="/images/fabric-private-data-structure.jpg" alt=""></p>
<center>Fig1. 隐私数据存储结构（摘自Ref.3）</center>

<p><img src="/images/fabric-private-data-phases.jpg" alt=""></p>
<center>Fig2. 隐私数据交互流程（摘自Ref.2）</center>  

<ol>
<li><code>The transactions with the private data hashes get included in blocks as normal. The block with the private data hashes is distributed to all the peers.</code>即private data hash会提交到orderer进行排序，对于没有权限的private data collection，只能获取到其hash作为存证和后续验证。</li>
<li><code>Note that because gossip distributes the private data peer-to-peer across authorized organizations, it is required to set up anchor peers on the channel, and configure CORE_PEER_GOSSIP_EXTERNALENDPOINT on each peer, in order to bootstrap cross-organization communication.</code>。意味着gossip协议会根据collection的json定义文件里的policy政策传播到符合条件的各个组织。</li>
</ol>
<p>当前fabric提供的是hash校验的基本功能，只是数据的真实性校验和数据交换，对于更多的应用场景例如需要计算/比较的，将来可以扩展叠加零知识证明和同态加密运算等，会有更广的应用想象空间。</p>
<p>Ref：</p>
<blockquote>
<ol>
<li><a href="https://hyperledger-fabric.readthedocs.io/en/latest/private-data/private-data.html?highlight=private">HyperLedger Fabric官网</a></li>
<li><a href="https://www.serial-coder.com/post/demystifying-hyperledger-fabric-private-data-collection/">Demystifying Hyperledger Fabric (2/3): Private Data Collection</a></li>
<li><a href="https://medium.com/@kctheservant/private-data-and-transient-data-in-hyperledger-fabric-46b5258f391e">Private Data and Transient Data in Hyperledger Fabric</a></li>
<li><a href="https://v.qq.com/x/page/a09419gwu90.html">视频</a> ： IBM工程师介绍private data</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>安全多方计算MPC的若干个概念</title>
    <url>//articles/mpc-terminology/</url>
    <content><![CDATA[<p>安全多方计算（MPC）与可信计算环境（TEE），联邦学习（Federated Learning）是隐私计算领域的三个重要实现方式。</p>
<p>参考资料：</p>
<blockquote>
<p><a href="https://securecomputation.org/">A Pragmatic Introduction to Secure Multi-Party Computation</a></p>
</blockquote>
<h3 id="1-不经意传输（OT，Oblivious-Transfer）"><a href="#1-不经意传输（OT，Oblivious-Transfer）" class="headerlink" title="1. 不经意传输（OT，Oblivious Transfer）"></a>1. 不经意传输（OT，Oblivious Transfer）</h3><p><strong>目标如下</strong>：</p>
<ol>
<li>Sender提供可选参数(m0, m1)，但是不知道Receiver具体选择哪个。</li>
<li>Receiver可以选择其中一个，但是不知道除此之外的其他参数值。例如，选择m0后，无法得知m1的值。<br><img src="/images/mpc-ot.jpg" alt=""></li>
</ol>
<div style='display: none'>
1-ou-of-2的实现方案有多种，其中一个基于公私钥机制的实现方案：
1. Sender拥有两个消息，分别为m0, m1,并且生成两对密钥对（pub0, pri0）和（pub1, pri1）
2. Receiver随机生成对称密钥k，以Receiver选择消息m0为例，用公钥pub0加密k，得到k0和k1，返回给Sender。
3. Sender使用私钥（pri0，pri1）分别解密（k0，k1），得到（k0', k1'）。此时，Sender无法得知具体选择了哪个，满足条件（1）。对Receiver而言，其中k0'=k，k1'则是一串不明字符串。
4. Sender使用对称密钥k0'和k1'分别对m0, m1加密，得到m0'， m1'，并回传给Receiver。
5. Receiver可以用k对m0'解密，得到m0。另外，m1'则是不可解，满足条件（2）。
</div>

<p>参考资料：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/126396795">混淆电路介绍（一）不经意传输</a><br><a href="https://crypto.stanford.edu/pbc/notes/crypto/ot.html">Oblivious Transfer (OT)</a></p>
</blockquote>
<span id="more"></span>
<h3 id="2-混淆电路（GC，Garbled-Circuit）"><a href="#2-混淆电路（GC，Garbled-Circuit）" class="headerlink" title="2. 混淆电路（GC，Garbled Circuit）"></a>2. 混淆电路（GC，Garbled Circuit）</h3><p>将计算逻辑转换成门电路，以与门为例，流程如下  </p>
<ol>
<li>A生成x为0，1对应的密钥kx0,kx1, y为0，1时对应的密钥ky0,ky1，并且计算如下真值表(z为两次对称加密值)</li>
<li>A将真值表打乱行顺序。假设A输入x=0，将对应的kx0和真值表发送给B。因为顺序乱，所以这样B无法从行排列中推测出kx0对应的A的输入是x=0还是x=1，即<strong><em>B无法得知A的输入</em></strong>。</li>
<li>假设B选择y=1,通过OT协议获取ky1（无法得知ky0），此时<strong><em>A也无法得知B的输入</em></strong>。</li>
<li>B通过对真值表里的z进行解密（此时B只有kx0和ky1），选择对E<sub>kx0</sub>(E<sub>ky1</sub>(0))进行解密，也就是最终结果0，即x=0，y=1时的结果。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td>kx0</td>
<td>ky0</td>
<td>E<sub>kx0</sub>(E<sub>ky0</sub>(0))</td>
</tr>
<tr>
<td>kx0</td>
<td>ky1</td>
<td>E<sub>kx0</sub>(E<sub>ky1</sub>(0))</td>
</tr>
<tr>
<td>kx1</td>
<td>ky0</td>
<td>E<sub>kx1</sub>(E<sub>ky0</sub>(0))</td>
</tr>
<tr>
<td>kx1</td>
<td>ky1</td>
<td>E<sub>kx1</sub>(E<sub>ky1</sub>(1))</td>
</tr>
</tbody>
</table>
</div>
<center>表1: 加密真值表</center>

<h3 id="3-秘密共享-SS-Secret-Sharing"><a href="#3-秘密共享-SS-Secret-Sharing" class="headerlink" title="3. 秘密共享(SS, Secret-Sharing)"></a>3. 秘密共享(SS, Secret-Sharing)</h3><p>秘密共享通过把秘密进行分割，并把秘密在n个参与者中分享，使得只有多于特定t个参与者合作才可以计算出或是恢复秘密，而少于t个参与者则不可以得到有关秘密。实现方式例如：</p>
<ol>
<li>构造t-1次多项式 f(x) = s + a<sub>1</sub>·x + … + a<sub>t-1</sub> · x<sup>t-1</sup>。 其中，s为分享的秘密</li>
<li>计算f(x1), f(x2), …, f(xn)，分别分发给参与方P1, …, Pn。此时任意至少t个P组合在一起可通过拉格朗日插值法计算f(x),也就得到秘密s。</li>
</ol>
<p>在布尔电路上，可将异或门和与门分别看成在有限域上 <em>F<sub>2</sub></em> 的加法和乘法。将异或用模为 2 的加法进行计算，与用模为 2 的乘法进行计算。<a href="https://blog.csdn.net/Matrix_element/article/details/117357359?spm=1001.2014.3001.5501">BGW协议</a>基于Shamir秘密分享方案实现加法/乘法特性。</p>
<p>参考资料：</p>
<blockquote>
<p><a href="http://web.mit.edu/6.857/OldStuff/Fall03/ref/Shamir-HowToShareASecret.pdf">How to Share a Secret</a> - Adi Shamir</p>
</blockquote>
<h3 id="4-差分隐私-DP-Differential-Privacy"><a href="#4-差分隐私-DP-Differential-Privacy" class="headerlink" title="4. 差分隐私(DP, Differential Privacy)"></a>4. 差分隐私(DP, Differential Privacy)</h3><p><strong>中心思想</strong>：无法从结果中反推出单个输入个体的信息。<br><strong>临近数据集</strong>：指的是两个数据集D1，D2只有单个记录不一致。例如，D1={1, 0, 1}, D1={1, 0, 1, 1}。数据操作是count，则count(D1)=2, count(D2)=2, 则可以反推出最后一个输入为1。主要通过两种方式添加噪声，一是根据数据敏感的数值型（服从拉普拉斯分布的随机噪声），二是离散值(指数分布)。添加的噪声分类如下：</p>
<ul>
<li>输入噪声： f(x0, x1, …, xn, <em>c</em>) -&gt; f(x0, x1, …, xn + <em>noice</em>, <em>c</em>)</li>
<li>参数噪声： f(x0, x1, …, xn, <em>c</em>) -&gt; f(x0, x1, …, xn, <em>c</em> + <em>noice</em>)</li>
<li>输出噪声： f(x0, x1, …, xn, <em>c</em>) -&gt; f(x0, x1, …, xn, <em>c</em>) + <em>noice</em></li>
</ul>
]]></content>
      <tags>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>零知识证明： Why and How zk-SNARK Works：Definitive Explanation论文学习笔记</title>
    <url>//articles/zk-snark-paper/</url>
    <content><![CDATA[<p>本文为<a href="https://arxiv.org/abs/1906.07221">Why and How zk-SNARK Works: Definitive Explanation</a>论文学习心得，纯粹个人在阅读过程中的疑问和思考，详细的理解请阅读附录引用的文章。</p>
<h3 id="2-The-Medium-of-a-Proof"><a href="#2-The-Medium-of-a-Proof" class="headerlink" title="2. The Medium of a Proof"></a>2. The Medium of a Proof</h3><ul>
<li><strong>多项式是zk-snark的核心</strong></li>
</ul>
<ol>
<li>基本流程<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">• Verifier chooses a random value for x and evaluates his polynomial locally</span><br><span class="line">• Verifier gives x to the prover and asks to evaluate the polynomial in question</span><br><span class="line">• Prover evaluates his polynomial at x and gives the result to the verifier</span><br><span class="line">• Verifier checks if the local result is equal to the prover’s result, and if so then the statement is proven with a high confidence</span><br></pre></td></tr></tbody></table></figure></li>
<li>存在问题<ul>
<li>prover可以通过其他方式得到多项式结果，没有方法确保该结果是经过多项式计算得来</li>
<li>多项式的阶数需要足够高</li>
</ul>
</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h3 id="3-Non-Interactive-Zero-Knowledge-of-a-Polynomial"><a href="#3-Non-Interactive-Zero-Knowledge-of-a-Polynomial" class="headerlink" title="3 Non-Interactive Zero-Knowledge of a Polynomial"></a>3 Non-Interactive Zero-Knowledge of a Polynomial</h3><p>这一章是zk-snark的理论基础。</p>
<h3 id="3-1-Proving-Knowledge-of-a-Polynomial"><a href="#3-1-Proving-Knowledge-of-a-Polynomial" class="headerlink" title="3.1 Proving Knowledge of a Polynomial"></a>3.1 Proving Knowledge of a Polynomial</h3><ol>
<li><p>流程</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">• Verifier samples a random value r, calculates t = t(r) (i.e., evaluates) and gives r to the prover</span><br><span class="line">• Prover calculates h(x) = p(x) and evaluates p(r) and h(r); the resulting values p,h are t(x) provided to the verifier</span><br><span class="line">• Verifier then checks that p = t · h, if so those polynomials are equal, meaning that p(x) has t(x) as a cofactor.</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>Q1： 为什么prover不直接传递t ?<br>A1： 需要证明的是 prover知道t，即其中的两个根。下文有说明，prover可能通过别的方式恰好知道t(s)的值，协议不安全。而zk-snark里是将要证明的表达成多项式，然后由verifier构造基础多项式，让prover来赋值输入/输出，通过证明t的根是verifier的目标多项式的根，从而证明其输出的正确性。</p>
</li>
<li><p>Q2: 如果试验次数足够多，例如h的阶数，是否可能推算出h，从而推算出p ?<br>A2: 下文引入零知识证明，通过3.3的同态加密的模运算实现。</p>
</li>
</ul>
</li>
<li><p>存在问题</p>
<ul>
<li>prover计算得到t后，可以随意选择h，计算p=h*t，verifier无法验证prover是否知道p。</li>
<li>prover恰好知道x=r处的值t(r)，可以构造任何的多项式</li>
</ul>
</li>
</ol>
<h3 id="3-3-Obscure-Evaluation"><a href="#3-3-Obscure-Evaluation" class="headerlink" title="3.3 Obscure Evaluation"></a>3.3 Obscure Evaluation</h3><h3 id="3-3-1-Homomorphic-Encryption（同态加密）"><a href="#3-3-1-Homomorphic-Encryption（同态加密）" class="headerlink" title="3.3.1 Homomorphic Encryption（同态加密）"></a>3.3.1 Homomorphic Encryption（同态加密）</h3><p>The general idea is that we choose a base natural number g (say 5) and to encrypt a value we exponentiate g to the power of that value.<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5^3 = 125, Where 125 is the encryption of 3.</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol>
<li>存在问题<br>将125持续的除以5，直到结果为1，此时的step就是加密的3</li>
</ol>
<h3 id="3-3-3-Strong-Homomorphic-Encryption"><a href="#3-3-3-Strong-Homomorphic-Encryption" class="headerlink" title="3.3.3 Strong Homomorphic Encryption"></a>3.3.3 Strong Homomorphic Encryption</h3><p>模运算。基本流程如下：<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">encryption :  5^3 = 6 (mod 7)</span><br><span class="line">multiplication :  6^2 = (5^3)^2 = 5^6 = 1 (mod 7)</span><br><span class="line">addition:   5^3·5^2 =5^5 =3 (mod7)</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol>
<li>局限性<br>while we can multiply an encrypted value by an unencrypted value, we cannot multiply (and divide) two encrypted values, as well as we cannot exponentiate an encrypted value.<br>两个加密结果间无法直接进行乘法运算。（下文引入pairing配对函数，解决乘法运算）</li>
</ol>
<h3 id="3-3-4-Encrypted-Polynomial"><a href="#3-3-4-Encrypted-Polynomial" class="headerlink" title="3.3.4 Encrypted Polynomial"></a>3.3.4 Encrypted Polynomial</h3><p><img src="/images/zk-snarks/zk-snarks-encrypted-polynomial.jpeg" alt=""><br><img src="/images/zk-snarks/zk-snarks-encrypted-polynomial-derivation.jpeg" alt=""></p>
<ul>
<li><em>(说明：图中r即论文中的s)</em></li>
</ul>
<ol>
<li>能解决<code>prover恰好知道x=s的值t(s)，可以构造任何的多项式</code>这个问题，因为已经prover已经无法得知<code>s</code>以及<code>t(s)</code>。</li>
<li><strong><em>不能</em></strong> 解决<code>prover计算得到t后，可以随意选择h，计算p=h*t，verifier无法验证prover是否知道p</code>，例如，可以随意选择r的值，构造 z<sub>h</sub> = g<sup>r</sup> 和 z<sub>p</sub> = (g<sup>t(s)</sup>)<sup>r</sup></li>
</ol>
<h3 id="3-4-Restricting-a-Polynomial"><a href="#3-4-Restricting-a-Polynomial" class="headerlink" title="3.4 Restricting a Polynomial"></a>3.4 Restricting a Polynomial</h3><p><img src="/images/zk-snarks/zk-snarks-restricting-polynomial-derivation.jpeg" alt=""></p>
<ul>
<li><em>(说明：图中r即论文中的s)</em></li>
</ul>
<ol>
<li><p>结论：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">– Bob has applied the same exponent (i.e., c) to both values of the tuple</span><br><span class="line">– Bob could only use the original Alice’s tuple to maintain the α relationship</span><br><span class="line">– Bob knows the applied exponent c, because the only way to produce valid (b,b′) is to use the same exponent</span><br><span class="line">– Alice has not learned c for the same reason Bob cannot learn α</span><br></pre></td></tr></tbody></table></figure>
<p>即Prover必须使用verifier提供的基于s<sup>i</sup>计算出来的值进行计算，verifier可以通过验证(g<sup>p</sup>, g<sup>p’</sup>)间仍然保持 α 的指数偏移量关系。同时verifier无法得知prover使用的参数c的值。</p>
</li>
<li><p>存在问题：</p>
</li>
</ol>
<ul>
<li>Q1: 如果原始的<code>p=(x+1)*(x+2)</code>，其中<code>t=x+1</code>,<code>h=x+2</code>。但是prover捏造<code>h'=x+3</code>，即<code>p'=(x+1)*(x+3)</code>，verifier是否无法验证？<br>A1: 在zk-snark实际应用中看4.8小节</li>
</ul>
<h3 id="3-5-Zero-Knowledge"><a href="#3-5-Zero-Knowledge" class="headerlink" title="3.5 Zero-Knowledge"></a>3.5 Zero-Knowledge</h3><p>verifier可以从E（p）知道关于p的多项式的具体参数。例如上面的例子对E（p）因式分解？<br>解决方案：类似verifier引入 α 保证prover使用其提供的值进行运算，相应的prover也映入 δ 指数偏移量。例如验证 g<sup>δ·p</sup> = g<sup>δ·t(s)h</sup></p>
<h3 id="3-6-Non-Interactivity"><a href="#3-6-Non-Interactivity" class="headerlink" title="3.6 Non-Interactivity"></a>3.6 Non-Interactivity</h3><p>非交互式。多方各自验证，防止verifier和prover联合作假或者泄漏，proof可以重用提高效率，并且prover无需时刻在线响应。核心是Cryptographic pairings(配对函数)，即找到算法可以支持加密后数值的<strong>同态乘法</strong>运算，即e(g<sup>a</sup>, g<sup>b</sup>) = e(g, g)<sup>ab</sup>（小节3.3.3中不支持）。这样在setup阶段可以构造composite CRS（common reference string）（小节3.6.3）<br><img src="/images/zk-snarks/zk-snark-non-interactivity.jpg" alt=""></p>
<p>小节3.6.2中，由于引入了<strong>配对函数</strong>，验证加密方法是 e(g<sup>p</sup>, g<sup>1</sup>)=e(g<sup>t</sup>, g<sup>h</sup>)，而3.3.4同态加法加密小节里，则是验证g<sup>p</sup>=g<sup>t(s)·h</sup>。</p>
<h3 id="3-7-Succinct-Non-Interactive-Argument-of-Knowledge-of-Polynomial"><a href="#3-7-Succinct-Non-Interactive-Argument-of-Knowledge-of-Polynomial" class="headerlink" title="3.7 Succinct Non-Interactive Argument of Knowledge of Polynomial"></a>3.7 Succinct Non-Interactive Argument of Knowledge of Polynomial</h3><p>重要，基础。<strong>Setup-Proving-Verification</strong> 三步骤，详见文章。</p>
<ul>
<li><strong>Setup</strong>  <ul>
<li>proving key: { g<sup>s<sup>i</sup>&lt;/sup&gt; } <sub> i∈[d] </sub> , { g<sup>αs<sup>i</sup>&lt;/sup&gt; }<sub> i∈[d] </sub>   (提供给prover)</sup></sup></li>
<li>verification key: g<sup>α</sup>, g<sup>t(s)</sup> （自留，后续在Verification阶段使用）</li>
</ul>
</li>
<li><strong>Proving</strong><ul>
<li>set the randomized proof π = （g<sup>δp(s)</sup>, g<sup>δh(s)</sup>, g<sup>δαp(s)</sup>)，即（g<sup>p</sup>, g<sup>h</sup>, g<sup>p′</sup>)</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>check polynomial restriction : e(g<sup>p′</sup> , g) = e(g<sup>p</sup>, g<sup>α</sup>)  </li>
<li>check polynomial cofactors : e(g<sup>p</sup>, g) = e(g<sup>t(s)</sup>, g<sup>h</sup>)  </li>
</ul>
</li>
</ul>
<p>证明了p(x)的根，即p(x）因式分解后含有多项式 t(x)。</p>
<hr>
<h3 id="4-General-Purpose-Zero-Knowledge-Proofs"><a href="#4-General-Purpose-Zero-Knowledge-Proofs" class="headerlink" title="4 General-Purpose Zero-Knowledge Proofs"></a>4 General-Purpose Zero-Knowledge Proofs</h3><p>上面一章铺垫基础知识，这一章节拓展到实际的应用场景。</p>
<h3 id="4-1-Computation"><a href="#4-1-Computation" class="headerlink" title="4.1 Computation"></a>4.1 Computation</h3><p>需要证明的是 <code>for the input (1,4,2) of expression f(w,a,b) the output is 8, in other words, we check the equality: w(a × b) + (1 − w)(a + b) = 8</code><br>根据输入，证明计算的输出结果。将计算逻辑转化成多项式运算。</p>
<h3 id="4-3-Enforcing-Operation"><a href="#4-3-Enforcing-Operation" class="headerlink" title="4.3 Enforcing Operation"></a>4.3 Enforcing Operation</h3><p>简化多项式 <code>l(x) operator r(x) = o(x)</code></p>
<ul>
<li>Q1: 这里证明3·2=6,如果构造时候输入为4·3=12，verifier验证的等式同样成立。如何校验输入的正确性？</li>
<li>A1: 4.8小节的例子</li>
</ul>
<h3 id="4-4-Proof-of-Operation"><a href="#4-4-Proof-of-Operation" class="headerlink" title="4.4 Proof of Operation"></a>4.4 Proof of Operation</h3><p><code>p(x) = l(x) · r(x) − o(x)</code>， 并且拥有已知的根。（假如只有一个根a, 则此处<code>t(x)=x-a</code> ）</p>
<ul>
<li><strong>Proving</strong><ul>
<li>proof π = (g<sup>l</sup>, g<sup>r</sup>,g<sup>o</sup>, …)</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>valid operation check: e(g<sup>l</sup>,g<sup>r</sup>) = e(g<sup>t(s)</sup>,g<sup>h</sup>)·e(g<sup>o</sup>,g)</li>
</ul>
</li>
</ul>
<p>关键在与Proving环节，构造这个p(x)，使用了Pairing函数实现加密的乘法运算。<br>存在4.3上面提到的问题，因为计算这个l,g,o时候使用的是需要证明的输入输出来计算系数。<strong>需要保证此l(x),g(x),o(x)能反映需要证明的输入operand和输出output</strong></p>
<h3 id="4-6-Variable-Polynomials"><a href="#4-6-Variable-Polynomials" class="headerlink" title="4.6 Variable Polynomials"></a>4.6 Variable Polynomials</h3><ul>
<li><strong>Setup</strong>  <ul>
<li>construct l<sub>a</sub>(x), l<sub>d</sub>(x)  : 在小节4.5的例子中，满足<code>For our example la(x) must conform to evaluations la(1) = 1, la(2) = 1 and la(3) = 0 and ld(x) is zero at 1 and 2 but 1 at x = 3</code>。也就是满足这个特性。</li>
<li>proving key: ( g<sup>l<sub>a</sub>(x)</sup>, g<sup>l<sub>d</sub>(x)</sup>, g<sup>αl<sub>a</sub>(x)</sup>, g<sup>αl<sub>d</sub>(x)</sup>) </li>
</ul>
</li>
<li><strong>Proving</strong><ul>
<li>assign values a and d and add and provide proof π = （g<sup>L(s)</sup> = g<sup>al<sub>a</sub>(x)</sup> · g<sup>dl<sub>d</sub>(x)</sup> = g<sup>al<sub>a</sub>(x) + dl<sub>d</sub>(x)</sup>)，g<sup>αL(s)</sup>) :  然后Prover再来构造 L(x) = a·l<sub>a</sub>(x) + d·l<sub>d</sub>(x)，具体的赋值，也就是输入值。在4.5的例子中，a=2,d=6。也就是限定了，prover必须使用指定的输入。</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>check polynomial restriction : e(g<sup>p′</sup> , g) = e(g<sup>p</sup>, g<sup>α</sup>)  </li>
<li>check polynomial cofactors : e(g<sup>p</sup>, g) = e(g<sup>t(s)</sup>, g<sup>h</sup>) </li>
</ul>
</li>
</ul>
<ul>
<li><p>Q1: 这里证明3X2=6,如果构造时候输入为4X3=12，verifier验证的等式同样成立。如何校验输入的正确性？</p>
<p>A1: 这里verifier可以检查 g<sup>L(s)</sup> = g<sup>al<sub>a</sub>(s)</sup> · g<sup>dl<sub>d</sub>(s)</sup> = g<sup>al<sub>a</sub>(s) + dl<sub>d</sub>(s)</sup>，即可判断输入参数是否相符。<strong><em>verifie是否知道a,d的取值？</em></strong></p>
</li>
<li>Q2: 提供的是l(x)的阶数为多阶的，verifier提供是以{ g<sup>s<sup>i</sup>&lt;/sup&gt; }i∈[d]的方式提供的，在Proving阶段prover赋值时，如何保证对于每一阶都赋予相同的值？<br>A2: </sup></li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">As a consequence the prover:</span><br><span class="line">• is not able to modify provided variable polynomials by changing their coefficients, except “assigning” values, because prover is presented only with encrypted evaluations of these polynomials, and because necessary encrypted powers of s are unavailable separately with their α-shifts</span><br><span class="line">• is not able to add another polynomial to the provided ones because the α-ratio will be broken</span><br><span class="line">• is not able to modify operand polynomials through multiplication by some other polyno- mial u(x), which could disproportionately modify the values because encrypted multipli- cation is not possible in pre-pairings space</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-7-Construction-Properties"><a href="#4-7-Construction-Properties" class="headerlink" title="4.7 Construction Properties"></a>4.7 Construction Properties</h3><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Note the operation’s construction is also called “constraint” because the operation represented by polynomial construction does not compute results per se, but rather checks that the prover already knows variables (including result), and they are valid for the operation, i.e., the prover is constrained to provide consistent values no matter what they are.</span><br></pre></td></tr></tbody></table></figure>
<p>也就是说，验证的是输入/输出计算结果，即代入上面构造的L(x),R(x),O(x)，需要证明其中的根，即t(x)。通过验证约束的方式取代直接提供输出结果的方式。</p>
<h3 id="4-8-Example-Computation"><a href="#4-8-Example-Computation" class="headerlink" title="4.8 Example Computation"></a>4.8 Example Computation</h3><p>l(x),r(x),o(x)系列子函数的这些都是已知的，也是verifier加密后传递到prover。prover使用输入w=1,a=3,b=2,计算出结果v=6，并且代入计算得到L(x),R(x),O(x),然后即传统的p(x)=L(x)·R(x)-O(x)，其中t(x)已知，因为这个是verifier用来计算l(x),r(x),o(x)的根。也就是，<strong>需要证明的是v=6</strong>。这个是通过将v=6代入不等式证明的。</p>
<p><img src="/images/zk-snarks/zk-snark-example.jpg" alt=""><br></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">m=a·b</span><br><span class="line">w·(m-a-b)=v-a-b</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>即图中在x=1,2,3三个点处都满足<code>L(x)·R(x)-O(x)=0</code>，如果改变v的值使其不等于6，则<code>L(x)·R(x)-O(x)</code>该等式在x=2处<code>w·（m-a-b）!= v-a-b</code>，即x=2不是其中一个根，verifier验证失败。</p>
<h3 id="4-9-Verifiable-Computation-Protocol"><a href="#4-9-Verifiable-Computation-Protocol" class="headerlink" title="4.9 Verifiable Computation Protocol"></a>4.9 Verifiable Computation Protocol</h3><h4 id="4-9-1-限定L-x-只由-li-x-构成，并且证明的等式必须是L-x-·-R（x）-O-x-。-防止左操作数，右操作数，输出在证明中混用。"><a href="#4-9-1-限定L-x-只由-li-x-构成，并且证明的等式必须是L-x-·-R（x）-O-x-。-防止左操作数，右操作数，输出在证明中混用。" class="headerlink" title="4.9.1 - 限定L(x)只由 li(x) 构成，并且证明的等式必须是L(x) · R（x）= O(x)。 防止左操作数，右操作数，输出在证明中混用。"></a>4.9.1 - 限定<code>L(x)</code>只由 l<sub>i</sub>(x) 构成，并且证明的等式必须是<code>L(x) · R（x）= O(x)</code>。 防止左操作数，右操作数，输出在证明中混用。</h4><p><strong>Solution</strong>: <code>l(x),r(x),o(x)</code>分别使用不同的α<sub>l</sub>, α<sub>r</sub>, α<sub>o</sub>。</p>
<h4 id="4-9-2-限定在L-x-R-x-O-x-使用的参数vi-即4-8例子中的a-b-w等）是一致的。"><a href="#4-9-2-限定在L-x-R-x-O-x-使用的参数vi-即4-8例子中的a-b-w等）是一致的。" class="headerlink" title="4.9.2 - 限定在L(x),R(x),O(x)使用的参数vi(即4.8例子中的a,b,w等）是一致的。"></a>4.9.2 - 限定在<code>L(x),R(x),O(x)</code>使用的参数v<sub>i</sub>(即4.8例子中的a,b,w等）是一致的。</h4><p><strong>Solution</strong>:  为校验校验 v<sub>l,i</sub> = v<sub>r,i</sub> = v<sub>o,i</sub> = v<sub>β,i</sub>，关键是通过以下等式<br>e(g<sup>v<sub>l,i</sub> ·l<sub>i</sub>(s)</sup> · g<sup>v<sub>r,i</sub> ·r<sub>i</sub>(s)</sup> · g<sup>v<sub>o,i</sub> ·o<sub>i</sub>(s)</sup>, g<sup>β</sup>) = e(g<sup>v<sub>β,i</sub> ·β·(l<sub>i</sub>(s)+r<sub>i</sub>(s)+o<sub>i</sub>(s))</sup>, g)。 进一步为防止如<code>l(x) = r(x)</code>的情况，选择各自不等的β<sub>l</sub>, β<sub>r</sub>, β<sub>o</sub></p>
<ul>
<li><strong>Setup</strong>  <ul>
<li>proving key the variable consistency polynomials:<br>g<sup>β<sub>z</sub></sup>={g<sup>β<sub>l</sub>l<sub>i</sub>(s)+&gt;β<sub>r</sub>r<sub>i</sub>(s)+&gt;β<sub>o</sub>o<sub>i</sub>(s)</sup>}<sub>i∈{1,…,n}</sub></li>
<li>verification key: (g<sup>β<sub>l</sub></sup> , g<sup>β<sub>r</sub></sup> , g<sup>β<sub>o</sub></sup>, g<sup>β<sub>z</sub></sup>)</li>
</ul>
</li>
<li><strong>Proving</strong><ul>
<li>赋值计算，g<sup>z<sub>i</sub>(s)</sup>=(g<sup>β<sub>z</sub></sup>)<sup>v<sub>i</sub></sup> for i ∈ {1,…,n}，并且相乘得到proof: g<sup>Z(s)</sup></li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>e(g<sup>L</sup>, g<sup>β<sub>l</sub></sup>) · e(g<sup>R</sup>, g<sup>β<sub>r</sub></sup>) · e(g<sup>O</sup>, g<sup>β<sub>o</sub></sup>) = e(g<sup>Z</sup> , g)</li>
</ul>
</li>
</ul>
<h4 id="4-9-3-Non-malleability-of-Variable-and-Variable-Consistency-Polynomials"><a href="#4-9-3-Non-malleability-of-Variable-and-Variable-Consistency-Polynomials" class="headerlink" title="4.9.3 Non-malleability of Variable and Variable Consistency Polynomials"></a>4.9.3 Non-malleability of Variable and Variable Consistency Polynomials</h4><p><strong>Q1</strong>:（Malleability of Variable Polynomials） g<sup>α<sub>l</sub></sup> 和 g<sup>β<sub>l</sub></sup>是在verification key里的，为什么prover能拿得到？<br><strong>Q2</strong>：（Non-Malleability） 作为verification key，这里的g<sup>γ</sup>是否就是类似与Q1里的g ? 这样的区别在哪里？</p>
<h4 id="4-10-Constraints"><a href="#4-10-Constraints" class="headerlink" title="4.10 Constraints"></a>4.10 Constraints</h4><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">However, the protocol is not actually “computing” but rather is checking that the output value is the correct result of an operation for the operand’s values. That is why it is called a constraint, i.e., a verifier is constraining a prover to provide valid values for the predefined “program” no matter what are they. </span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-11-Public-Inputs-and-One-限定常量的值。"><a href="#4-11-Public-Inputs-and-One-限定常量的值。" class="headerlink" title="4.11 Public Inputs and One 限定常量的值。"></a>4.11 Public Inputs and One 限定常量的值。</h3><p><strong>Solution</strong>:<br>L(x)=L<sub>v</sub>(x)+L<sub>p</sub>(x)，其中verifier提供L<sub>v</sub>(x) = l<sub>0</sub>(x) + l<sub>1</sub>(x) + . . . + l<sub>m</sub>(x)。限定了0阶（即常量）的值v<sub>one</sub></p>
<ul>
<li><strong>Setup</strong>  <ul>
<li>. . . separate all n variable polynomials into two groups:<ul>
<li>verifier’s m + 1:<br>L<sub>v</sub>(x) = l<sub>0</sub>(x) + l<sub>1</sub>(x) + . . . + l<sub>m</sub>, and alike for R<sub>v</sub>(x) and O<sub>v</sub>(x), where index 0 is reserved for the value of v<sub>one</sub> = 1</li>
<li>prover’s n − m:<br>L<sub>p</sub>(x) = l<sub>m+1</sub>(x) + . . . + l<sub>n</sub>(x), and alike for R<sub>p</sub>(x) and O<sub>p</sub>(x)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Effectively this is taking some variables from the prover into the hands of verifier while still preserving the balance of the equation. Therefore the valid operations check should still hold, but only if the prover has used the same values that the verifier used for his input.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-12-Zero-Knowledge-Proof-of-Computation"><a href="#4-12-Zero-Knowledge-Proof-of-Computation" class="headerlink" title="4.12 Zero-Knowledge Proof of Computation"></a>4.12 Zero-Knowledge Proof of Computation</h3><p>零知识证明，各自加上变换值。 δ<sub>l</sub>, δ<sub>r</sub>,  δ<sub>o</sub>。通过加法实现同态加密。<br>L(s) + δ<sub>l</sub>t(s)) · (R(s) + δ<sub>r</sub>t(s)) − (O(s) + δ<sub>o</sub>t(s)) = t(s) · (∆ + h(s))<br>∆ = δ<sub>r</sub>L(s) + δ<sub>l</sub>R(s) + δ<sub>l</sub>δ<sub>r</sub>t(s) − δ<sub>o</sub></p>
<p>只要满足以上关系，可以推导，在verification阶段可以就可以验证<br>L · R − O + t · ∆  = t(s)h + t(s) · ∆ </p>
<hr>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h3><ol>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIxNjkwODE5NQ==&amp;action=getalbum&amp;album_id=1432629901374636033&amp;subscene=159&amp;subscene=158&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxNjkwODE5NQ%3D%3D%26mid%3D2247484357%26idx%3D1%26sn%3Dc07ab2eab9fc81122f4788418eba2af1%26chksm%3D9780ab09a0f7221f0eb5049da5056bdbe9702a6fc03e3d053ad18ea60e9d75c2037ad545e1a0%26scene%3D158%23rd#wechat_redirect">从零开始学习 zk-SNARK</a> : 来自 安比实验室，翻译原文，并且加入理解和拓展，推荐</li>
<li><a href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-resource-list.md">零知识证明学习资源汇总</a></li>
</ol>
]]></content>
      <categories>
        <category>Consensus &amp; Cryptography</category>
      </categories>
  </entry>
  <entry>
    <title>大数据与区块链</title>
    <url>//articles/bigdata-and-blockchain/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4b4e3fa6c645048740f1d26d4256618251c171b923be80119f77e15863abd255">3175488eedc729df0c7d358c640da99ef6c8aa14b2be7cb6195cb77653a9e951f9f03e604cf0fd38f9abeb127d89fc235ee3ae13d4b572f5a052b5a1d48eddd2e682277e7bd8dd97b5a7e5bd403d7314ea64f0a970444713ea36c4943c3ca8671c8bf1c80f853ba61cdf38a009b35ccebfb8aac6ee794d84972f54eb4452d98e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Post is cheap, show me the password</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Hyperledger Fabric 2.0新特性</title>
    <url>//articles/fabric-2-0-new-feature/</url>
    <content><![CDATA[<p>Hyperledger Fabric升级到2.0大版本，主要以下有3个新特性。参看官网<a href="https://hyperledger-fabric.readthedocs.io/en/latest/whatsnew.html">What’s new in Hyperledger Fabric v2.0</a>。同时可以观看IBM员工也是Fabric开发者的系列视频讲座介绍新特性。参看<a href="https://v.qq.com/vplus/6a662f75e9a927ede370ba49c9e883e0#uin=6a662f75e9a927ede370ba49c9e883e0?page=video">超级账本Hyperledger频道</a>（超级账本网络研讨会2020年系列）。总体来说，2.0版本引入的新特性都是在实际应用过程中的痛点，增进了可用性。</p>
<ol>
<li>Decentralized governance for smart contracts<blockquote>
<p><a href="https://v.qq.com/x/page/s09376uefz5.html">视频</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/latest/chaincode_lifecycle.html">Fabric chaincode lifecycle</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/latest/deploy_chaincode.html">Deploying a smart contract to a channel</a></p>
</blockquote>
</li>
<li>Private data enhancements<blockquote>
<p><a href="https://v.qq.com/x/page/a09419gwu90.html">视频</a></p>
</blockquote>
</li>
<li><p>External chaincode launcher</p>
<blockquote>
<p><a href="https://v.qq.com/x/page/x0944c3pswy.html">视频</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/latest/cc_service.html">Chaincode as an external service</a></p>
</blockquote>
<p><img src="/images/fabric-2_0-external-chaincode-launcher.jpg" alt=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitcoin概念理解</title>
    <url>//articles/understanding-bitcoin/</url>
    <content><![CDATA[<ol>
<li>锁定脚本与解锁脚本<br>两者用于确定UTXO的所有权，其中，锁定脚本（sciptPubKey）存在于transaction的output，解锁脚本（scriptSig）存在于transaction的input。</li>
</ol>
<ul>
<li>具体规则如下：<br><img src="/images/understanding-bitcoin/bitcoin-script.jpg" alt=""></li>
</ul>
<span id="more"></span>
<ul>
<li>交易验证过程：<br><img src="/images/understanding-bitcoin/bitcoin-script-verification-1.jpg" alt=""><br><img src="/images/understanding-bitcoin/bitcoin-script-verification-2.jpg" alt=""></li>
</ul>
<blockquote>
<p>以上摘自<a href="https://zhuanlan.zhihu.com/p/33672729">比特币的交易过程-知乎</a></p>
</blockquote>
<ul>
<li>解锁脚本里签名的内容为：<br><img src="/images/understanding-bitcoin/bitcoin-transation.png" alt=""></li>
</ul>
<blockquote>
<p>We define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the next by digitally signing a hash of the previous transaction and the public key of the next owner and adding these to the end of the coin. A payee can verify the signatures to verify the chain of ownership. 摘自<a href="https://bitcoin.org/bitcoin.pdf">Bitcoin Whitepaper</a></p>
</blockquote>
<p>总的来说，校验过程先校验解锁脚本里公钥PubKey和锁定脚本里是吻合的，然后校验解锁脚本里的签名。使用对应的私钥，对来源（产生消费的该UTXO的transaction）和去处（转账接受者的pubkey）进行签名。校验过程只需要校验（签名，该UTXO的公钥，签名内容）这三者是吻合的。</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric实战（2）- Commercial Paper的Fabric-Java-SDK客户端</title>
    <url>//articles/fabric-inpractice-commercialpaper-java-sdk/</url>
    <content><![CDATA[<p>到目前为止都是通过在cli容器执行<code>peer chaincode</code>命令调用chaincode，实际上官方提供<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/fabric-sdks.html">SDK</a>（当前只有Node.js和Java两种）。这里提供基于Fabric Java SDK的commercial paper客户端，设置使用TLS，详细项目代码在<a href="https://github.com/simplexity-ckcclc/fabric-learning/tree/master/java-sdk/commercial-paper">github</a>。项目采用Springboot，swagger提供网页调用。注意，这里只是demo，不能作为生产环境使用。具体步骤大致拆解如下：</p>
<ol>
<li>构建HFClient<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HFClient <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 使用Org1的admin用户身份。由于使用TSL，这里提供keyFile：admin的私钥和certFile：由ca.org1.example.com签发的证书</span></span><br><span class="line">    <span class="comment">// 也可以通过使用HFCAClient向ca发送enroll和register请求用于新增注册和登记身份证书。具体可以参看参考文档。</span></span><br><span class="line">    Enrollment enrollment = PaperUser.createEnrollmentFromPemFile(keyFile, certFile);</span><br><span class="line">    PaperUser admin = <span class="keyword">new</span> PaperUser(name, mspId, enrollment);</span><br><span class="line"></span><br><span class="line">    HFClient client = HFClient.createNewInstance();</span><br><span class="line">    client.setCryptoSuite(CryptoSuite.Factory.getCryptoSuite());</span><br><span class="line">    client.setUserContext(admin);</span><br><span class="line">    initChannel();</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Enrollment <span class="title">createEnrollmentFromPemFile</span><span class="params">(String keyFile, String certFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] keyPem = Files.readAllBytes(Paths.get(keyFile));     <span class="comment">//载入私钥PEM文本</span></span><br><span class="line">    <span class="keyword">byte</span>[] certPem = Files.readAllBytes(Paths.get(certFile));   <span class="comment">//载入证书PEM文本</span></span><br><span class="line">    CryptoPrimitives suite = <span class="keyword">new</span> CryptoPrimitives();            <span class="comment">//载入密码学套件</span></span><br><span class="line">    PrivateKey privateKey = suite.bytesToPrivateKey(keyPem);    <span class="comment">//将PEM文本转换为私钥对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> X509Enrollment(privateKey,<span class="keyword">new</span> String(certPem));  <span class="comment">//创建并返回X509Enrollment对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用TSL，需要提供peerTLScaCertFile：tlsca.org1.example.com的证书和ordererTLScaCertFile：tlsca.example.com的证书</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Channel channel = client.newChannel(channelID);</span><br><span class="line">    Properties peerProps = <span class="keyword">new</span> Properties();</span><br><span class="line">    peerProps.put(<span class="string">&quot;pemFile&quot;</span>, peerTLScaCertFile);</span><br><span class="line">    peerProps.setProperty(<span class="string">&quot;sslProvider&quot;</span>, <span class="string">&quot;openSSL&quot;</span>);</span><br><span class="line">    peerProps.setProperty(<span class="string">&quot;negotiationType&quot;</span>, <span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">    Peer peer = client.newPeer(peerName, peerURL, peerProps);</span><br><span class="line">    channel.addPeer(peer);</span><br><span class="line"></span><br><span class="line">    Properties ordererProps = <span class="keyword">new</span> Properties();</span><br><span class="line">    ordererProps.put(<span class="string">&quot;pemFile&quot;</span>, ordererTLScaCertFile);</span><br><span class="line">    ordererProps.setProperty(<span class="string">&quot;sslProvider&quot;</span>, <span class="string">&quot;openSSL&quot;</span>);</span><br><span class="line">    ordererProps.setProperty(<span class="string">&quot;negotiationType&quot;</span>, <span class="string">&quot;TLS&quot;</span>);</span><br><span class="line">    Orderer orderer = client.newOrderer(ordererName, ordererURL, ordererProps);</span><br><span class="line">    channel.addOrderer(orderer);</span><br><span class="line"></span><br><span class="line">    channel.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>peerURL</code>设置为<code>grpcs://peer0.org1.example.com:7051</code>。首先，TLS需要设置使用<code>grpcs</code>。其次，只能使用<code>peer0.org1.example.com</code>（同时需要配置hosts文件），不能使用  <code>127.0.0.1</code>或者<code>localhost</code>(报错<code>Caused by: java.security.cert.CertificateException: No subject alternative DNS name matching IP address 127.0.0.1/localhost found</code>) 。因为peer0返回的证书的CN是peer0.org1.example.com，java ssl会校验这个域名。</li>
</ul>
<ol>
<li><p>chaincode - query</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">query</span><span class="params">(String issuer, String paperNumber)</span> </span>&#123;</span><br><span class="line">    QueryByChaincodeRequest req = client.newQueryProposalRequest();</span><br><span class="line">    ChaincodeID cid = ChaincodeID.newBuilder().setName(chaincodeName).build();</span><br><span class="line">    req.setChaincodeID(cid);</span><br><span class="line">    req.setFcn(QUERY_FUNC);</span><br><span class="line">    req.setArgs(issuer, paperNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Channel对象已在上面构建</span></span><br><span class="line">    Channel channel = client.getChannel(channelID);</span><br><span class="line">    Collection&lt;ProposalResponse&gt; propResps = channel.queryByChaincode(req);</span><br><span class="line">    <span class="comment">// endorser返回的ProposalResponse需要保持一致</span></span><br><span class="line">    Collection&lt;Set&lt;ProposalResponse&gt;&gt; proposalConsistencySets = SDKUtils.getProposalConsistencySets(propResps);</span><br><span class="line">    <span class="keyword">if</span> (proposalConsistencySets.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(ErrorCode.CHAINCOED_SERVICE_ERROR)</span><br><span class="line">                .withErrorMsg(<span class="string">&quot;Expected only one set of consistent proposal responses but got more&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    FabricProposalResponse.Response res = propResps.iterator().next().getProposalResponse().getResponse();</span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success().withResponse(res.getPayload().toStringUtf8());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(ErrorCode.CHAINCOED_SERVICE_ERROR).withErrorMsg(res.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chaincode - invoke</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">issue</span><span class="params">(IssueRequest request)</span> </span>&#123;</span><br><span class="line">    TransactionProposalRequest proposalRequest = client.newTransactionProposalRequest();</span><br><span class="line">    ChaincodeID cid = ChaincodeID.newBuilder().setName(chaincodeName).build();</span><br><span class="line">    proposalRequest.setChaincodeID(cid);</span><br><span class="line">    proposalRequest.setFcn(ISSUE_FUNC);</span><br><span class="line">    proposalRequest.setArgs(request.getIssuer(), request.getPaperNumber(), issueDate, maturityDate,</span><br><span class="line">            String.valueOf(request.getFaceValue()));</span><br><span class="line"></span><br><span class="line">    Channel channel = client.getChannel(channelID);</span><br><span class="line">    <span class="comment">// Endorsing(simulate) phase</span></span><br><span class="line">    Collection&lt;ProposalResponse&gt; propResps = channel.sendTransactionProposal(proposalRequest);</span><br><span class="line">    <span class="comment">// endorser返回的ProposalResponse需要保持一致</span></span><br><span class="line">    Collection&lt;Set&lt;ProposalResponse&gt;&gt; proposalConsistencySets = SDKUtils.getProposalConsistencySets(propResps);</span><br><span class="line">    <span class="keyword">if</span> (proposalConsistencySets.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(ErrorCode.CHAINCOED_SERVICE_ERROR)</span><br><span class="line">                .withErrorMsg(<span class="string">&quot;Expected only one set of consistent proposal responses but got more&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Orderer phase</span></span><br><span class="line">    <span class="comment">// 这里同步调用，需要等到提交orderer并且orderer排序后发送到各个peer，peer处理了block里的交易后才返回。</span></span><br><span class="line">    <span class="comment">// 或者同步返回txid。可以配置eventHub异步接收和执行block，通过txid来返回最终的执行结果</span></span><br><span class="line">    BlockEvent.TransactionEvent event = channel.sendTransaction(propResps).get();</span><br><span class="line">    <span class="keyword">if</span> (event.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.success().withResponse(<span class="string">&quot;txid : &quot;</span> + event.getTransactionID());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(ErrorCode.CHAINCOED_SERVICE_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="WIP"><a href="#WIP" class="headerlink" title="WIP:"></a>WIP:</h4><ol>
<li>eventHub</li>
</ol>
<h4 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/63511862">Fabric Java SDK最新教程【201904】</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric实战（1） - 基础篇，基于byfn的Commercial Paper案例</title>
    <url>//articles/fabric-inpractice-commercialpaper-byfn/</url>
    <content><![CDATA[<p>之前分享过<a href="https://simplexity.cn/2019/04/19/fabric-commercial-paper-go/">Fabric官网Commercial Paper案例chaincode的golang实现</a>，现在基于官网<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/build_network.html">Building Your First Network</a>再次记录过程，同时添加部分新操作及分析，以此作为以后的进阶实战基础。</p>
<ol>
<li><p>使用命令<code>./byfn.sh up</code>启动网络</p>
</li>
<li><p>查看配置文件<code>/fabric-samples/first-network/docker-compose-cli.yaml</code>,可见cli的挂载volume设置  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cli:</span><br><span class="line">  volume:</span><br><span class="line">    - ./../chaincode/:/opt/gopath/src/github.com/chaincode</span><br></pre></td></tr></table></figure></li>
<li><p>将编写的chaincode源文件放置在该挂载的路径<code>/chaincode/go</code>下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp commercial_paper.go /chaincode/go</span><br><span class="line">cp paper.go /chaincode/go</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>docker exec -it cli bash</code>登入容器cli</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 执行peer chaincode install -n commercialpaper -v 0 -p github.com/chaincode/commercial_paper/go</span><br><span class="line">- 执行echo $CORE_PEER_MSPCONFIGPATH。可见当前角色为admin</span><br><span class="line">    ---</span><br><span class="line">    /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line">- 执行peer chaincode list -C mychannel --installed</span><br><span class="line">    ---</span><br><span class="line">    Get installed chaincodes on peer:</span><br><span class="line">    Name: commercialpaper, Version: 0, Path: github.com/chaincode/commercial_paper/go, Id: f033307bf72f876fb5a95883d53ed5209e6639386e21361eed65f459d8a9f276</span><br></pre></td></tr></table></figure>
</li>
</ol>
<span id="more"></span>
<ol>
<li><p>登入peer0.org1.example.com(容器cli内CORE_PEER_ADDRESS=peer0.org1.example.com:7051，也就是其endorser节点)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 执行ll var/hyperledger/production/chaincodes，存在文件commercialpaper.0（即$&#123;chaincodeName&#125;.$&#123;version&#125;）</span><br><span class="line">- 执行peer chaincode list -C mychannel --installed</span><br><span class="line">    ---</span><br><span class="line">    Error: Bad response: 500 - access denied for [getinstalledchaincodes]: Failed verifying that proposal&#x27;s creator satisfies local MSP principal during channelless check policy with policy [Admins]: [This identity is not an admin]</span><br></pre></td></tr></table></figure>
<p> 实际上，<code>docker inspect peer0.org1.example.com</code>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;HostConfig&quot;: &#123;</span><br><span class="line">    &quot;Binds&quot;: [</span><br><span class="line">        &quot;/Users/meitu/Project/github/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls:rw&quot;,</span><br><span class="line">        &quot;/Users/meitu/Project/github/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp:rw&quot;,</span><br><span class="line">        &quot;/var/run:/host/var/run:rw&quot;,</span><br><span class="line">        &quot;net_peer0.org1.example.com:/var/hyperledger/production:rw&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 没有将Admin@org1.example.com/msp挂载进来，当然可以修改启动配置文件<code>base/docker-compose-base.yaml</code>，或者后续添加到挂载的volume上，设置$CORE_PEER_MSPCONFIGPATH指向挂载的路径也可以赋予权限访问  </p>
</li>
<li><p>查看<code>/fabric-samples/first-network/scripts/</code>路径下<code>script.sh</code>和<code>util.sh</code>，包含设置CORE_PEER_LOCALMSPID=(“Org1MSP”/“Org2MSP”)</p>
</li>
<li><p>cli执行<code>chaincode instantiate</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peer chaincode instantiate -n commercialpaper -v 0 -c &#x27;&#123;&quot;Args&quot;:[]&#125;&#x27; -C mychannel -P &quot;AND (&#x27;Org1MSP.member&#x27;)&quot; \</span><br><span class="line">--tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br><span class="line"></span><br><span class="line">env</span><br><span class="line">---</span><br><span class="line">OLDPWD=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts</span><br><span class="line"></span><br><span class="line">peer0.org1.example.com:</span><br><span class="line">2019-10-22 14:28:19.931 UTC [endorser] callChaincode -&gt; INFO 1e62ef [mychannel][3156a1b7] Entry chaincode: name:&quot;lscc&quot;</span><br><span class="line">2019-10-22 14:28:19.936 UTC [endorser] callChaincode -&gt; INFO 1e630e [mychannel][3156a1b7] Exit chaincode: name:&quot;lscc&quot;  (5ms)</span><br><span class="line">2019-10-22 14:28:19.940 UTC [comm.grpc.server] 1 -&gt; INFO 1e631b unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T14:28:19.927Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:51012&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;12.4301ms&quot;&#125;</span><br><span class="line">2019-10-22 14:28:21.993 UTC [gossip.privdata] StoreBlock -&gt; INFO 1e647d [mychannel] Received block [5] from buffer</span><br><span class="line">2019-10-22 14:28:22.022 UTC [committer.txvalidator] Validate -&gt; INFO 1e64c9 [mychannel] Validated block [5] in 28ms</span><br><span class="line">2019-10-22 14:28:22.033 UTC [cceventmgmt] HandleStateUpdates -&gt; INFO 1e64db Channel [mychannel]: Handling deploy or update of chaincode [commercialpaper]</span><br><span class="line">2019-10-22 14:28:22.065 UTC [kvledger] CommitWithPvtData -&gt; INFO 1e6506 [mychannel] Committed block [5] with 1 transaction(s) in 40ms (state_validation=15ms block_commit=18ms state_commit=4ms)</span><br><span class="line">2019-10-22 14:28:31.257 UTC [endorser] callChaincode -&gt; INFO 1e6ed6 [mychannel][b206b359] Entry chaincode: name:&quot;lscc&quot;</span><br><span class="line">2019-10-22 14:28:31.262 UTC [endorser] callChaincode -&gt; INFO 1e6efc [mychannel][b206b359] Exit chaincode: name:&quot;lscc&quot;  (4ms)</span><br><span class="line">2019-10-22 14:28:31.263 UTC [comm.grpc.server] 1 -&gt; INFO 1e6f09 unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T14:28:31.255Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.4:55986&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;7.5554ms&quot;&#125;</span><br><span class="line"></span><br><span class="line">peer1.org1.example.com:</span><br><span class="line">2019-10-22 14:28:22.009 UTC [gossip.privdata] StoreBlock -&gt; INFO 1e0540 [mychannel] Received block [5] from buffer</span><br><span class="line">2019-10-22 14:28:22.011 UTC [committer.txvalidator] Validate -&gt; INFO 1e0588 [mychannel] Validated block [5] in 2ms</span><br><span class="line">2019-10-22 14:28:22.017 UTC [cceventmgmt] HandleStateUpdates -&gt; INFO 1e05a0 Channel [mychannel]: Handling deploy or update of chaincode [commercialpaper]</span><br><span class="line">2019-10-22 14:28:22.018 UTC [ccprovider] ExtractStatedbArtifactsForChaincode -&gt; INFO 1e05a3 Error while loading installation package for ccname=commercialpaper, ccversion=0. Err=open /var/hyperledger/production/chaincodes/commercialpaper.0: no such file or directory</span><br><span class="line">2019-10-22 14:28:22.018 UTC [cceventmgmt] HandleChaincodeDeploy -&gt; INFO 1e05a4 Channel [mychannel]: Chaincode [Name=commercialpaper, Version=0, Hash=[]byte&#123;0xf0, 0x33, 0x30, 0x7b, 0xf7, 0x2f, 0x87, 0x6f, 0xb5, 0xa9, 0x58, 0x83, 0xd5, 0x3e, 0xd5, 0x20, 0x9e, 0x66, 0x39, 0x38, 0x6e, 0x21, 0x36, 0x1e, 0xed, 0x65, 0xf4, 0x59, 0xd8, 0xa9, 0xf2, 0x76&#125;] is not installed hence no need to create chaincode artifacts for endorsement</span><br><span class="line">2019-10-22 14:28:22.041 UTC [kvledger] CommitWithPvtData -&gt; INFO 1e05c1 [mychannel] Committed block [5] with 1 transaction(s) in 27ms (state_validation=5ms block_commit=13ms state_commit=6ms)</span><br><span class="line"></span><br><span class="line">orderer：</span><br><span class="line">2019-10-22 14:28:19.969 UTC [comm.grpc.server] 1 -&gt; INFO 027 streaming call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T14:28:19.947Z&quot;, &quot;grpc.service&quot;: &quot;orderer.AtomicBroadcast&quot;, &quot;grpc.method&quot;: &quot;Broadcast&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:53034&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;23.1002ms&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>peer1.org1.example.com上没有install这个chaincode</li>
</ul>
<ol>
<li>cli执行<code>peer chaincode invoke -c &#39;&#123;&quot;Args&quot;:[&quot;issue&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;, &quot;2020-05-31&quot;, &quot;2020-11-30&quot;, &quot;5000000&quot;]&#125;&#39; -C mychannel -n commercialpaper&quot;</code>，失败。看日志是cli与orderer之间tls失败 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cli:</span><br><span class="line">Error: error sending transaction for invoke: could not send: EOF - proposal response: version:1 response:&lt;status:200 payload:&quot;&#123;\&quot;PaperNumber\&quot;:\&quot;00004\&quot;,\&quot;Issuer\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;Owner\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;IssueDateTime\&quot;:\&quot;2020-05-31\&quot;,\&quot;MaturityDateTime\&quot;:\&quot;2020-11-30\&quot;,\&quot;FaceValue\&quot;:5000000,\&quot;Status\&quot;:0&#125;&quot; &gt; payload:&quot;\n /!\373\020OI\024\270_1\267\251\332\337\037 $\370\347\356\004aEXZ\345\332/\366|&#x27;7\022\306\003\n\204\002\022\340\001\n\017commercialpaper\022\314\001\n\022\n\020MagnetoCorp00004\032\265\001\n\020MagnetoCorp00004\032\240\001&#123;\&quot;PaperNumber\&quot;:\&quot;00004\&quot;,\&quot;Issuer\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;Owner\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;IssueDateTime\&quot;:\&quot;2020-05-31\&quot;,\&quot;MaturityDateTime\&quot;:\&quot;2020-11-30\&quot;,\&quot;FaceValue\&quot;:5000000,\&quot;Status\&quot;:0&#125;\022\037\n\004lscc\022\027\n\025\n\017commercialpaper\022\002\010\005\032\246\001\010\310\001\032\240\001&#123;\&quot;PaperNumber\&quot;:\&quot;00004\&quot;,\&quot;Issuer\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;Owner\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;IssueDateTime\&quot;:\&quot;2020-05-31\&quot;,\&quot;MaturityDateTime\&quot;:\&quot;2020-11-30\&quot;,\&quot;FaceValue\&quot;:5000000,\&quot;Status\&quot;:0&#125;\&quot;\024\022\017commercialpaper\032\0010&quot; endorsement:&lt;endorser:&quot;\n\007Org1MSP\022\252\006-----BEGIN CERTIFICATE-----\nMIICKDCCAc6gAwIBAgIQbaczcznil/PbPlby6iZKsjAKBggqhkjOPQQDAjBzMQsw\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\nYW5jaXNjbzEZMBcGA1UEChMQb3JnMS5leGFtcGxlLmNvbTEcMBoGA1UEAxMTY2Eu\nb3JnMS5leGFtcGxlLmNvbTAeFw0xOTEwMjIwODU0MDBaFw0yOTEwMTkwODU0MDBa\nMGoxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1T\nYW4gRnJhbmNpc2NvMQ0wCwYDVQQLEwRwZWVyMR8wHQYDVQQDExZwZWVyMC5vcmcx\nLmV4YW1wbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAESYh6SwhdBrUf\nsekjyFVukFQXI4q5O4DCnaTwARTlHffruISr0wnM1UkCI/OlrApnr/1Y3jagLiko\nkgwZbeVrgqNNMEswDgYDVR0PAQH/BAQDAgeAMAwGA1UdEwEB/wQCMAAwKwYDVR0j\nBCQwIoAgnPSDYZGp0kd3Lamn88Z/R0vxSeMxwJp/FKSVeVOsmsMwCgYIKoZIzj0E\nAwIDSAAwRQIhAO3ASI59+lSdlcY9RgDUlRWMe3qzXwI870wWI+ozpscLAiBf4MIV\nUcGoLpoB5GPnRxOY++CabOCmYDBZMfYAE+SKlA==\n-----END CERTIFICATE-----\n&quot; signature:&quot;0E\002!\000\257D\303\234\024\210C&gt;\203\215-\204\257 \304*\367sL9\223\207\233\312\351\277\270LR\231\236&amp;\002 )\331\334\006\025\214\337\355\262\252\305\345\214\315ae\3527\317y\274\336\352oX\037F\220\3036%\025&quot; &gt;</span><br><span class="line"></span><br><span class="line">orderer: </span><br><span class="line">2019-10-22 15:58:14.380 UTC [core.comm] ServerHandshake -&gt; ERRO 034 TLS handshake failed with error tls: first record does not look like a TLS handshake &#123;&quot;server&quot;: &quot;Orderer&quot;, &quot;remote address&quot;: &quot;172.25.0.7:53104&quot;&#125;</span><br><span class="line">2019-10-22 15:58:15.383 UTC [core.comm] ServerHandshake -&gt; ERRO 035 TLS handshake failed with error tls: first record does not look like a TLS handshake &#123;&quot;server&quot;: &quot;Orderer&quot;, &quot;remote address&quot;: &quot;172.25.0.7:53106&quot;&#125;</span><br><span class="line"></span><br><span class="line">peer0.org1.example.com:</span><br><span class="line">2019-10-22 15:58:15.391 UTC [endorser] callChaincode -&gt; INFO 2c3af6 [mychannel][89d96407] Entry chaincode: name:&quot;commercialpaper&quot;</span><br><span class="line">2019-10-22 15:58:15.398 UTC [endorser] callChaincode -&gt; INFO 2c3b04 [mychannel][89d96407] Exit chaincode: name:&quot;commercialpaper&quot;  (7ms)</span><br><span class="line">2019-10-22 15:58:15.398 UTC [comm.grpc.server] 1 -&gt; INFO 2c3b11 unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T15:58:15.389Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:51082&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;9.4211ms&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>cli执行<code>chaincode invoke</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peer chaincode invoke -c &#x27;&#123;&quot;Args&quot;:[&quot;issue&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;, &quot;2020-05-31&quot;, &quot;2020-11-30&quot;, &quot;5000000&quot;]&#125;&#x27; -C mychannel -n commercialpaper \</span><br><span class="line">--tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem</span><br><span class="line"></span><br><span class="line">cli:</span><br><span class="line">2019-10-22 15:55:07.564 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 0c9 Chaincode invoke successful. result: status:200 payload:&quot;&#123;\&quot;PaperNumber\&quot;:\&quot;00003\&quot;,\&quot;Issuer\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;Owner\&quot;:\&quot;MagnetoCorp\&quot;,\&quot;IssueDateTime\&quot;:\&quot;2020-05-31\&quot;,\&quot;MaturityDateTime\&quot;:\&quot;2020-11-30\&quot;,\&quot;FaceValue\&quot;:5000000,\&quot;Status\&quot;:0&#125;&quot;</span><br><span class="line"></span><br><span class="line">peer0.org1.example.com:</span><br><span class="line">2019-10-22 15:55:07.497 UTC [endorser] callChaincode -&gt; INFO 2ba6d0 [][7b225797] Entry chaincode: name:&quot;cscc&quot;</span><br><span class="line">2019-10-22 15:55:07.502 UTC [endorser] callChaincode -&gt; INFO 2ba6ec [][7b225797] Exit chaincode: name:&quot;cscc&quot;  (5ms)</span><br><span class="line">2019-10-22 15:55:07.502 UTC [comm.grpc.server] 1 -&gt; INFO 2ba6ef unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T15:55:07.494Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:51076&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;7.6522ms&quot;&#125;</span><br><span class="line">2019-10-22 15:55:07.553 UTC [endorser] callChaincode -&gt; INFO 2ba716 [mychannel][443bff3e] Entry chaincode: name:&quot;commercialpaper&quot;</span><br><span class="line">2019-10-22 15:55:07.557 UTC [endorser] callChaincode -&gt; INFO 2ba724 [mychannel][443bff3e] Exit chaincode: name:&quot;commercialpaper&quot;  (4ms)</span><br><span class="line">2019-10-22 15:55:07.559 UTC [comm.grpc.server] 1 -&gt; INFO 2ba731 unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T15:55:07.545Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:51076&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;14.7305ms&quot;&#125;</span><br><span class="line">2019-10-22 15:55:09.574 UTC [gossip.privdata] StoreBlock -&gt; INFO 2ba941 [mychannel] Received block [8] from buffer</span><br><span class="line">2019-10-22 15:55:09.584 UTC [committer.txvalidator] Validate -&gt; INFO 2ba96b [mychannel] Validated block [8] in 9ms</span><br><span class="line">2019-10-22 15:55:09.619 UTC [kvledger] CommitWithPvtData -&gt; INFO 2ba99e [mychannel] Committed block [8] with 1 transaction(s) in 33ms (state_validation=19ms block_commit=7ms state_commit=5ms)</span><br><span class="line"></span><br><span class="line">orderer:</span><br><span class="line">2019-10-22 15:55:07.569 UTC [orderer.common.broadcast] Handle -&gt; WARN 032 Error reading from 172.25.0.7:53098: rpc error: code = Canceled desc = context canceled</span><br><span class="line">2019-10-22 15:55:07.569 UTC [comm.grpc.server] 1 -&gt; INFO 033 streaming call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-22T15:55:07.545Z&quot;, &quot;grpc.service&quot;: &quot;orderer.AtomicBroadcast&quot;, &quot;grpc.method&quot;: &quot;Broadcast&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:53098&quot;, &quot;error&quot;: &quot;rpc error: code = Canceled desc = context canceled&quot;, &quot;grpc.code&quot;: &quot;Canceled&quot;, &quot;grpc.call_duration&quot;: &quot;24.1982ms&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>从peer0.org1.example.com日志可见，先后调用了cscc（system chaincode。 调用GetConfigBlock方法，获取channel config，从而获取orderer地址提供给cli建立orderer client）和commercialpaper。后续收到orderer传来的block后再验证和提交本地。</p>
</li>
<li><p><code>docker network inspect net_byfn</code>,发现 172.25.0.7 &lt;-&gt; cli<br>登入cli，<code>netstat -anp</code>如下。估计是端口过早关闭</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 127.0.0.11:35373        0.0.0.0:*               LISTEN      -</span><br><span class="line">udp        0      0 127.0.0.11:36128        0.0.0.0:*</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>peer0.org1.example.com/cli执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peer chaincode list -C mychannel --instantiated</span><br><span class="line">---</span><br><span class="line">Get instantiated chaincodes on channel mychannel:</span><br><span class="line">Name: commercialpaper, Version: 0, Path: github.com/chaincode/commercial_paper/go, Escc: escc, Vscc: vscc</span><br></pre></td></tr></table></figure>
</li>
<li><p>cli执行<code>chaincode query</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peer chaincode query -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;]&#125;&#x27; -C mychannel -n commercialpaper</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前commeicialpaper只install在peer0.org1.example.com，此时cli执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CORE_PEER_ADDRESS=peer1.org1.example.com:8051</span><br><span class="line">peer chaincode query -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;]&#125;&#x27; -C mychannel -n commercialpaper</span><br><span class="line">---</span><br><span class="line">Error: endorsement failure during query. response: status:500 message:&quot;cannot retrieve package for chaincode commercialpaper/0, error open /var/hyperledger/production/chaincodes/commercialpaper.0: no such file or directory&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cli在peer1.org1.example.com:8051上<code>chaincode install</code>，并且<code>chaincode query</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peer chaincode query -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;]&#125;&#x27; -C mychannel -n commercialpaper \</span><br><span class="line">--peerAddresses peer1.org1.example.com:8051 \</span><br><span class="line">--tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/server.crt</span><br><span class="line">或者（`CORE_PEER_TLS_ROOTCERT_FILE`可不修改，因为同org相同的ca证书）</span><br><span class="line">CORE_PEER_ADDRESS=peer1.org1.example.com:8051</span><br><span class="line">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt</span><br><span class="line">peer chaincode install -n commercialpaper -v 0 -p github.com/chaincode/commercial_paper/go</span><br><span class="line">peer chaincode query -c &#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;]&#125;&#x27; -C mychannel -n commercialpaper</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">&#123;&quot;PaperNumber&quot;:&quot;00001&quot;,&quot;Issuer&quot;:&quot;MagnetoCorp&quot;,&quot;Owner&quot;:&quot;MagnetoCorp&quot;,&quot;IssueDateTime&quot;:&quot;2020-05-31&quot;,&quot;MaturityDateTime&quot;:&quot;2020-11-30&quot;,&quot;FaceValue&quot;:5000000,&quot;Status&quot;:0&#125;</span><br><span class="line"></span><br><span class="line">peer1.org1.example.com:</span><br><span class="line">2019-10-23 04:43:39.847 UTC [endorser] callChaincode -&gt; INFO 5078dd [][e21cf78b] Entry chaincode: name:&quot;lscc&quot;</span><br><span class="line">2019-10-23 04:43:39.891 UTC [lscc] executeInstall -&gt; INFO 5078ea Installed Chaincode [commercialpaper] Version [0] to peer</span><br><span class="line">2019-10-23 04:43:39.892 UTC [endorser] callChaincode -&gt; INFO 5078ee [][e21cf78b] Exit chaincode: name:&quot;lscc&quot;  (45ms)</span><br><span class="line">2019-10-23 04:43:39.892 UTC [comm.grpc.server] 1 -&gt; INFO 5078f1 unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-23T04:43:39.846Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:50220&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;46.0634ms&quot;&#125;</span><br><span class="line">2019-10-23 04:43:54.861 UTC [endorser] callChaincode -&gt; INFO 5084f7 [mychannel][b060b92a] Entry chaincode: name:&quot;commercialpaper&quot;</span><br><span class="line">2019-10-23 04:43:54.914 UTC [chaincode.platform.golang] GenerateDockerBuild -&gt; INFO 508508 building chaincode with ldflagsOpt: &#x27;-ldflags &quot;-linkmode external -extldflags &#x27;-static&#x27;&quot;&#x27;</span><br><span class="line">2019-10-23 04:44:19.578 UTC [endorser] callChaincode -&gt; INFO 509732 [mychannel][b060b92a] Exit chaincode: name:&quot;commercialpaper&quot;  (24751ms)</span><br><span class="line">2019-10-23 04:44:19.581 UTC [comm.grpc.server] 1 -&gt; INFO 50973f unary call completed &#123;&quot;grpc.start_time&quot;: &quot;2019-10-23T04:43:54.857Z&quot;, &quot;grpc.service&quot;: &quot;protos.Endorser&quot;, &quot;grpc.method&quot;: &quot;ProcessProposal&quot;, &quot;grpc.peer_address&quot;: &quot;172.25.0.7:50224&quot;, &quot;grpc.code&quot;: &quot;OK&quot;, &quot;grpc.call_duration&quot;: &quot;24.7588062s&quot;&#125;</span><br><span class="line"></span><br><span class="line">orderer日志无变化</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>此时<code>docker ps</code>，新启动了容器<code>dev-peer1.org1.example.com-commercialpaper-0</code>。</p>
<blockquote>
<p><strong><em>Fabric Documents</em></strong>: If you want additional peers to interact with ledger, then you will need to join them to the channel, and install the same name, version and language of the chaincode source onto the appropriate peer’s filesystem. <strong>A chaincode container will be launched for each peer as soon as they try to interact with that specific chaincode.</strong> Again, be cognizant of the fact that the Node.js images will be slower to compile.</p>
</blockquote>
</li>
</ul>
<ol>
<li>以下对peer0.org2.example.com节点重复实验（从属不同的org）。在cli容器install/invoke chaincode。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peer chaincode install -n commercialpaper -v 0 -p github.com/chaincode/commercial_paper/go \ </span><br><span class="line">--peerAddresses peer0.org2.example.com:9051 \</span><br><span class="line">--tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt</span><br><span class="line">* 指定--peerAddresses和--tlsRootCertFiles参数。或者修改环境变量（对应关系）</span><br><span class="line">CORE_PEER_ADDRESS=peer0.org2.example.com:9051</span><br><span class="line">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line">peer chaincode install -n commercialpaper -v 0 -p github.com/chaincode/commercial_paper/go</span><br><span class="line"></span><br><span class="line">---报错</span><br><span class="line">Error: error getting channel (mychannel) orderer endpoint: error endorsing GetConfigBlock: rpc error: code = Unknown desc = access denied: channel [] creator org [Org1MSP]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>这是因为<code>CORE_PEER_LOCALMSPID</code>和<code>CORE_PEER_MSPCONFIGPATH</code>这两个参数的设置使当前cli的msp证书从属于Org1。修改使用Org2的msp以及Admin或者User角色即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CORE_PEER_LOCALMSPID=Org2MSP</span><br><span class="line">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/User1@org2.example.com/msp</span><br><span class="line">peer chaincode install -n commercialpaper -v 0 -p github.com/chaincode/commercial_paper/go \ </span><br><span class="line">--peerAddresses peer0.org2.example.com:9051 \</span><br><span class="line">--tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h4><blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-hyperledger-fabric-practice-analysis/index.html?ca=drs-#icomments">分步详解 Fabric 区块链网络的部署</a> : IBM员工，相当棒的系列实践文章</p>
</blockquote>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4 chaincode lifecycle(install &amp; instantiate)</title>
    <url>//articles/fabric-chaincode-lifecycle-uml/</url>
    <content><![CDATA[<p>chaincode install &amp; instantiate的大致流程，其中install无需order流程。具体细节可参考之前的源码分析系列。</p>
<p><img src="/images/chaincode-lifecycle-uml.png" alt=""></p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - orderer的raft实现</title>
    <url>//articles/fabric-source-orderer-etcdraft/</url>
    <content><![CDATA[<p>Raft可以说是Fabric 1.X系列的首个真正意义的共识算法。Fabric的实现主要涉及到三个类，<code>chain.go &lt;-&gt; etcdraft/node.go &lt;-&gt; raft/node.go</code>, 其中<code>raft/node.go</code>是etcd的开源包，<code>chain.go</code>是实现共识算法的主要类，<code>etcdraft/node.go</code>则是相当于适配模式下的适配器，用于连接两者，对实现屏蔽Raft的具体实现方案。</p>
<span id="more"></span>
<p>首先看<code>chain.go</code>的struct（略去部分field），包含<code>etcdraft/node.go</code>对象。调用<code>chain.go#Start</code>方法时（省略），内部调用了<code>etcdraft/node.go#start</code>方法。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Chain <span class="keyword">struct</span> {</span><br><span class="line">    rpc RPC</span><br><span class="line"></span><br><span class="line">    raftID    <span class="keyword">uint64</span></span><br><span class="line">    channelID <span class="keyword">string</span></span><br><span class="line">    lastKnownLeader <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    submitC  <span class="keyword">chan</span> *submit</span><br><span class="line">    applyC   <span class="keyword">chan</span> apply</span><br><span class="line">    observeC <span class="keyword">chan</span>&lt;- raft.SoftState <span class="comment">// Notifies external observer on leader change (passed in optionally as an argument for tests)</span></span><br><span class="line">    snapC    <span class="keyword">chan</span> *raftpb.Snapshot <span class="comment">// Signal to catch up with snapshot</span></span><br><span class="line">    gcC      <span class="keyword">chan</span> *gc              <span class="comment">// Signal to take snapshot</span></span><br><span class="line"></span><br><span class="line">    configInflight       <span class="keyword">bool</span> <span class="comment">// this is true when there is config block or ConfChange in flight</span></span><br><span class="line">    blockInflight        <span class="keyword">int</span>  <span class="comment">// number of in flight blocks</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// needed by snapshotting</span></span><br><span class="line">    sizeLimit        <span class="keyword">uint32</span> <span class="comment">// SnapshotIntervalSize in bytes</span></span><br><span class="line">    accDataSize      <span class="keyword">uint32</span> <span class="comment">// accumulative data size since last snapshot</span></span><br><span class="line">    lastSnapBlockNum <span class="keyword">uint64</span></span><br><span class="line">    confState        raftpb.ConfState <span class="comment">// Etcdraft requires ConfState to be persisted within snapshot</span></span><br><span class="line"></span><br><span class="line">    createPuller CreateBlockPuller <span class="comment">// func used to create BlockPuller on demand</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this is exported so that test can use `Node.Status()` to get raft node status.</span></span><br><span class="line">    Node *node</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start instructs the orderer to begin serving the chain and keep it current.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chain)</span> <span class="title">Start</span><span class="params">()</span></span> {</span><br><span class="line">    c.Node.start(c.fresh, isJoin)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应c.gcC channel的信号，进行c.Node.takeSnapshot操作，并且将过期的可配置个数前的消息和snapshot清空</span></span><br><span class="line">    <span class="keyword">go</span> c.gc()</span><br><span class="line">    <span class="keyword">go</span> c.serveRequest()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    es := c.newEvictionSuspector()</span><br><span class="line">    interval := DefaultLeaderlessCheckInterval</span><br><span class="line">    c.periodicChecker.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> {</span><br><span class="line">    chainID <span class="keyword">string</span></span><br><span class="line">    storage *RaftStorage    <span class="comment">// raft的wal, ram等持久化或者暂存内存实现类</span></span><br><span class="line">    config  *raft.Config</span><br><span class="line">    rpc RPC     <span class="comment">// 负责节点间的grpc通信，管理与各个节点的grpc client/stream</span></span><br><span class="line">    chain *Chain</span><br><span class="line">    raft.Node   <span class="comment">// 开源库etcd的raft节点实现</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>etcdraft/node.go#run</code>是其主要逻辑。(以下截取展示部分逻辑)。实际上可以看到，开源库etcd的raft节点实现只管理raft相关的propose, commit, election等过程，而把其他的业务相关留给使用方，包括节点间通信等。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> {</span><br><span class="line">    <span class="comment">//// n为来自开源库etcd的raft节点raft.Node，通知消息</span></span><br><span class="line">    <span class="keyword">case</span> rd := &lt;-n.Ready():</span><br><span class="line">        <span class="comment">// wal </span></span><br><span class="line">        <span class="keyword">if</span> err := n.storage.Store(rd.Entries, rd.HardState, rd.Snapshot); err != <span class="literal">nil</span> {</span><br><span class="line">            n.logger.Panicf(<span class="string">"Failed to persist etcd/raft data: %s"</span>, err)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 落后和新加入节点需要同步的snapshot</span></span><br><span class="line">        <span class="keyword">if</span> !raft.IsEmptySnap(rd.Snapshot) {</span><br><span class="line">            n.chain.snapC &lt;- &amp;rd.Snapshot</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// skip empty apply。 来自raft节点的新消息（提议的提交信息rd.CommittedEntries，或者状态变换rd.SoftState，如新leader，节点数量变化等等）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(rd.CommittedEntries) != <span class="number">0</span> || rd.SoftState != <span class="literal">nil</span> {</span><br><span class="line">            n.chain.applyC &lt;- apply{rd.CommittedEntries, rd.SoftState}</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        n.Advance()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(jay_guo) leader can write to disk in parallel with replicating to the followers and them writing to their disks. Check 10.2.1 in thesis</span></span><br><span class="line">        <span class="comment">// 调用rpc RPC，交由管理的grpc client发送</span></span><br><span class="line">        n.send(rd.Messages)</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Orderer消息的入口还是<code>chain.go#Order</code>和<code>chain.go#Configure</code>，实际上最后调用<code>chain.go#Submit</code>，其如注释所说，如果本节点是leader则发送到submitC channel内，否则通过rpc发送到leader节点。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Submit forwards the incoming request to:</span></span><br><span class="line"><span class="comment">// - the local serveRequest goroutine if this is leader</span></span><br><span class="line"><span class="comment">// - the actual leader via the transport mechanism</span></span><br><span class="line"><span class="comment">// The call fails if there's no leader elected yet.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chain)</span> <span class="title">Submit</span><span class="params">(req *orderer.SubmitRequest, sender <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    leadC := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">uint64</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> c.submitC &lt;- &amp;submit{req, leadC}:</span><br><span class="line">        lead := &lt;-leadC</span><br><span class="line">        <span class="keyword">if</span> lead != c.raftID {</span><br><span class="line">            <span class="keyword">if</span> err := c.rpc.SendSubmit(lead, req); err != <span class="literal">nil</span> {</span><br><span class="line">                c.Metrics.ProposalFailures.Add(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>chain.go</code>的运行主体在<code>chain.go#serveRequest</code>，其中主要是<code>select</code>。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> {</span><br><span class="line">    <span class="comment">// 来自于`chain.go#Submit`，也就是提交的proposal，这里主要是判断当前是leader才会进行propose。</span></span><br><span class="line">    <span class="comment">// 如果当前节点是leader，则调用`consensus.ConsenterSupport#ProcessConfigMsg/ProcessNormalMsg`，然后调用`support.BlockCutter().Ordered`切割batch。</span></span><br><span class="line">    <span class="comment">// 对切割后还有pending的消息启动timer，也就是下面的`&lt;-timer.C():`分支，到期后在进行切割。</span></span><br><span class="line">    <span class="keyword">case</span> s := &lt;-submitC:</span><br><span class="line">        <span class="comment">// 与orderer的其他实现一致，可参考[Fabric 1.4源码分析 - chaincode instantiate(8）orderer的排序过程]</span></span><br><span class="line">        batches, pending, err := c.ordered(s.req)</span><br><span class="line">        <span class="keyword">if</span> pending {</span><br><span class="line">            startTimer() <span class="comment">// no-op if timer is already started</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            stopTimer()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        c.propose(propC, bc, batches...)</span><br><span class="line">    <span class="comment">// 来自上文提到的`etcdraft/node.go#run`，也就是开源库etcd的raft节点raft.Node的通知消息</span></span><br><span class="line">    <span class="comment">// 这部分消息可能包含leader的切换，最新的记录在消息的`chain.go/apply/raft.SoftState/Lead`字段，进而相应的`propC, cancelProp = becomeLeader()`或者`becomeFollower()`。</span></span><br><span class="line">    <span class="comment">// propC即上面的propose方法的参数，在becomeLeader内处理，即调用`raft.go#Node.Propose`进行propose</span></span><br><span class="line">    <span class="keyword">case</span> app := &lt;-c.applyC:</span><br><span class="line">        <span class="comment">// 这里的entries是CommittedEntries，即需要commit的entry，也就是leader当初propose的block</span></span><br><span class="line">        <span class="comment">// n.chain.applyC &lt;- apply{rd.CommittedEntries, rd.SoftState}</span></span><br><span class="line">        c.apply(app.entries)</span><br><span class="line">    <span class="keyword">case</span> &lt;-timer.C():</span><br><span class="line">    <span class="comment">// snapC    chan *raftpb.Snapshot // Signal to catch up with snapshot</span></span><br><span class="line">    <span class="comment">// 来自于`etcdraft/node.go#run`, select-case的`rd := &lt;-n.Ready():`内`n.chain.snapC &lt;- &amp;rd.Snapshot`，即底层raft的需要同步的snapshot。</span></span><br><span class="line">    <span class="comment">// 用于落后或者新加入的节点追上当前的消息状态</span></span><br><span class="line">    <span class="keyword">case</span> sn := &lt;-c.snapC:</span><br><span class="line">        c.catchUp(sn); err != <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-c.doneC:</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chain)</span> <span class="title">propose</span><span class="params">(ch <span class="keyword">chan</span>&lt;- *common.Block, bc *blockCreator, batches ...[]*common.Envelope)</span></span> {</span><br><span class="line">    <span class="comment">// 如果前面调用的c.ordered(s.req)切割出来的batches非空，则创建一个新block，并且在becomeLeader里的propC里调用c.Node.Propose()</span></span><br><span class="line">    <span class="keyword">for</span> _, batch := <span class="keyword">range</span> batches {</span><br><span class="line">        b := bc.createNextBlock(batch)</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> ch &lt;- b:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// if it is config block, then we should wait for the commit of the block</span></span><br><span class="line">        <span class="keyword">if</span> utils.IsConfigBlock(b) {</span><br><span class="line">            c.configInflight = <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">        c.blockInflight++</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">becomeLeader := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">chan</span>&lt;- *common.Block, </span></span></span><br><span class="line"><span class="params"><span class="function">    // Leader should call Propose in <span class="keyword">go</span> routine, because this method may be blocked</span></span></span><br><span class="line"><span class="params"><span class="function">    // <span class="keyword">if</span> node is leaderless (this can happen when leader steps down in a heavily</span></span></span><br><span class="line"><span class="params"><span class="function">    // loaded network)</span>. <span class="title">We</span> <span class="title">need</span> <span class="title">to</span> <span class="title">make</span> <span class="title">sure</span> <span class="title">applyC</span> <span class="title">can</span> <span class="title">still</span> <span class="title">be</span> <span class="title">consumed</span> <span class="title">properly</span>.</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, ch &lt;-<span class="keyword">chan</span> *common.Block)</span></span> {</span><br><span class="line">        <span class="keyword">for</span> {</span><br><span class="line">            <span class="keyword">select</span> {</span><br><span class="line">            <span class="keyword">case</span> b := &lt;-ch:</span><br><span class="line">                data := utils.MarshalOrPanic(b)</span><br><span class="line">                <span class="keyword">if</span> err := c.Node.Propose(ctx, data); err != ni</span><br><span class="line">                {...}</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }(ctx, ch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch, cancel</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chain)</span> <span class="title">apply</span><span class="params">(ents []raftpb.Entry)</span></span> {</span><br><span class="line">    <span class="keyword">var</span> position <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ents {</span><br><span class="line">        <span class="keyword">switch</span> ents[i].Type {</span><br><span class="line">        <span class="comment">// 调用writeBlock，将commitEntry里的block写入账本</span></span><br><span class="line">        <span class="comment">// accDataSize是累计的block数据大小</span></span><br><span class="line">        <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">            position = i</span><br><span class="line">            c.accDataSize += <span class="keyword">uint32</span>(<span class="built_in">len</span>(ents[i].Data))</span><br><span class="line">            block := utils.UnmarshalBlockOrPanic(ents[i].Data)</span><br><span class="line">            c.writeBlock(block, ents[i].Index)</span><br><span class="line">        <span class="keyword">case</span> raftpb.EntryConfChange:</span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ents[i].Index &gt; c.appliedIndex {</span><br><span class="line">            c.appliedIndex = ents[i].Index</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accDataSize是累计的block数据大小，大于配置的sizeLimit后，写入c.gcC channel,在`chain.go#gc`内处理c.Node.takeSnapshot</span></span><br><span class="line">    <span class="keyword">if</span> c.accDataSize &gt;= c.sizeLimit {</span><br><span class="line">        b := utils.UnmarshalBlockOrPanic(ents[position].Data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> c.gcC &lt;- &amp;gc{index: c.appliedIndex, state: c.confState, data: ents[position].Data}:</span><br><span class="line">            c.accDataSize = <span class="number">0</span></span><br><span class="line">            c.lastSnapBlockNum = b.Header.Number</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br><code>chain.go#gc</code><br><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Chain)</span> <span class="title">gc</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> g := &lt;-c.gcC:</span><br><span class="line">            c.Node.takeSnapshot(g.index, g.state, g.data)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>总体架构流程如上，具体细节可以参考以下，这些参考比较详细都描述了实现细节。</p>
<h4 id="Ref"><a href="#Ref" class="headerlink" title="Ref."></a>Ref.</h4><p><a href="https://www.jianshu.com/p/667c3cf7cb76">Hyperledger-Fabric源码分析（orderer-consensus-etcdraft）</a><br><a href="https://tinywell.com/2019/05/15/fabric-raft-source/">Fabric raft 共识源码浅析</a></p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitcoin性能扩容</title>
    <url>//articles/bitcoin-performance-scaleup-concern/</url>
    <content><![CDATA[<h3 id="区块大小扩容-Block-size"><a href="#区块大小扩容-Block-size" class="headerlink" title="区块大小扩容(Block size)"></a>区块大小扩容(Block size)</h3><p>比特币引入1MB区块大小的背景是大量的粉尘攻击导致区块巨大，区块需要同步的时间长，从而引发DOS（Denial of Service）。同时全节点的带宽，存储要求增高，导致性能不足的节点无法及时与主链同步。</p>
<h4 id="Pros"><a href="#Pros" class="headerlink" title="Pros"></a>Pros</h4><ol>
<li>提高TPS</li>
<li>更多的交易得到确认（当前限制下，交易手续费低的费用可能无法得到确认）</li>
</ol>
<h4 id="Cons"><a href="#Cons" class="headerlink" title="Cons"></a>Cons</h4><ol>
<li>节点性能要求增高准入门槛提高，导致网络全节点数量减少，挖矿中心化趋势</li>
<li>升级配置带来的硬分叉风险</li>
<li>区块全网同步时间增加，上一个区块的矿工周围节点比网络边缘节点（相对的）更早同步更早开始挖矿，中心化趋势。同时出块时间保持不变的前提下（同步时间占区块时间比重上升），会增加分叉，孤块（stale block）的可能性，以及增加交易回滚，双花等风险。类似的，减小区块时间提高出块速度也面临这个问题。</li>
<li>存在其他的性能提升替代方案，如隔离见证，侧链等</li>
</ol>
<span id="more"></span>
<h3 id="隔离见证（SegWit）"><a href="#隔离见证（SegWit）" class="headerlink" title="隔离见证（SegWit）"></a>隔离见证（SegWit）</h3><p>这个是针对比特币的改进，提出主要是要解决Transaction Malleability（交易延展性）这个问题。（因为早期的transactionId是由utxo的来源，目的以及签名计算得到的。根据密码学的特性，可以从签名通过计算得到新的的签名，并且也是密码学意义上有效的（比如椭圆曲线数字签名算法（ECDSA），这种算法下签名（r，s）和签名（r，-s （mod n））都是有效的）。因此恶意节点可以从正常交易复制出新交易，签名有效，从而生成新的transactionId。当撤回前一个交易再换utxo输入重发时，后一个交易仍然是有效的，可能会导致重复转账的欺诈行为）。此外，第三方增加Push data到验证信息的起始位置，改变交易ID(txid)同时验证结果也通过。因此，将签名信息（见证）从交易抽离出来放到交易的后面（锁定脚本，这部分是不包含在1MB块大小的计算限制里），即Hash出来的transactionId是不包括签名的，这时就无法通过改变签名计算生成新的交易。<br><img src="/images/bitcoin-performance-scaleup-concern/bitcoin-segwit.png" alt=""></p>
<h4 id="Pros-1"><a href="#Pros-1" class="headerlink" title="Pros"></a>Pros</h4><ol>
<li>解决Transaction Malleability这个问题</li>
<li>闪电网络的技术基础</li>
<li>区块大小限制并没有打破，旧节点仍然可以接受新的块格式（一个隔离见证的输出看起来像一个任何人都能花费的输出，该输出可以被一个空的签名见证，所以一个交易里面没有签名（签名被隔离）也可以通过旧节点的验证）。后相兼容的软分叉。</li>
</ol>
<h4 id="Cons-1"><a href="#Cons-1" class="headerlink" title="Cons"></a>Cons</h4><ol>
<li>每笔交易平均250字节，见证部分的数据约为150字节。这样相当于实际上增大了区块大小，隔离见证的整个区块大小为2.5到3MB左右。增加区块实际大小带来的风险依然存在（当然，也有通过将见证信息放在侧链上，交易主链通过引用的方式）。</li>
</ol>
<blockquote>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki">bips/bip-0062.mediawiki</a> ：Transaction Malleability的官方文档<br><a href="https://www.bitdegree.org/tutorials/what-is-segwit/">What is SegWit and How it Works Explained</a></p>
</blockquote>
<h3 id="侧链（Sidechain）"><a href="#侧链（Sidechain）" class="headerlink" title="侧链（Sidechain）"></a>侧链（Sidechain）</h3><p>侧链只需符合侧链协议，能够与主链进行安全的资产/数据转移的都可以成为侧链，可以作为二层网络分担主链上的压力（例如比特币闪电网络进行结算），或者实现更复杂的逻辑功能，将主链作为最后的清算链，另外也可以实现异构链间的资产转移。实现的技术基础是双向锚定（Two-way Peg），通过双向锚定技术，可以实现暂时的将数字资产在主链中锁定，同时将等价的数字资产在侧链中释放，同样当等价的数字资产在侧链中被锁定的时候，主链的数字资产也可以被释放。具体有多种实现方式，常见的是SPV（Simplified Payment Verification）。SPV主要涉及到两个东西, 第一个是Merkle Tree，另一个是布隆过滤器（Bloom Filter）。譬如说转账后watch event，如果不在乎隐私的话, 可以直接告诉全节点所关注的地址就可以；但是如果不想暴露隐私, 那就把关注的信息映射到BF上, 然后全节点返回所有命中BF的event。</p>
<p>双向锚定分为以下几个阶段：</p>
<ol>
<li>用户在主链上将数字资产发送到主链的一个特殊的地址，把数字资产锁定在主链上。</li>
<li>该锁定会等待一个确认期，确认期的作用是等待锁定交易被更多区块确认，可防止假冒锁定交易和拒绝服务攻击。</li>
<li>确认期结束后，用户在侧链上创建一个对应的带有SPV证明的交易，同时验证主链上的数字资产已经被锁住，然后就可以在侧链上打开具有相同价值的另一种数字资产。该交易称为赎回交易，SPV工作量证明是指赎回交易所在区块的工作量证明。</li>
<li>当这种数字资产返回到主链上时，该过程会进行重复。它们被发送到侧链上锁定的输出中，锁定一个竞争期，竞争期的作用是防止双花。然后就可以创建一个SPV证明，来将其发送回主区块链上，以解锁主链上的数字资产。<br><img src="/images/bitcoin-performance-scaleup-concern/side-chain-two-way-peg.png" alt=""></li>
</ol>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/42769604">全面理解区块链侧链技术</a> ： 提及多种侧链实现方式</p>
</blockquote>
<h4 id="闪电网络（Bitcoin-lightning-network）"><a href="#闪电网络（Bitcoin-lightning-network）" class="headerlink" title="闪电网络（Bitcoin lightning network）"></a>闪电网络（Bitcoin lightning network）</h4><p>在侧链建立点对点通道channel，进行小额和持续多次的资产往来，然后等达成共识后关闭通道，将资产合约发主链上完成结算。核心思想是提高欺诈成本，进行惩罚。<br><img src="/images/bitcoin-performance-scaleup-concern/lightning-network.png" alt=""></p>
<p>参考 <a href="https://www.zhihu.com/question/46515457">什么是比特币的闪电网络？</a>一文中的例子，在双方达成C2a共识后(C1a和C2a始终由Alice持有，达成c2a时Alice需要将Alice2秘钥给到Bob。这里C1a只有Alice持有，因此Bob即使拥有Alcie2秘钥也无法签发经过双方原始秘钥Alice和Bob签名的合同)，若然Alice广播C1a并且关闭通道（主动关闭通道方需要等待指定seq数量的块后才能执行RD1a），此时Bob监控到Alice广播旧的分配合约(这需要Bob节点在线，或者事先构建好BR1a交付给信任的第三方或者机器人在Alice欺诈时自动触发)，可以使用Alice2秘钥对BR1a签名并广播，这个是无需等待即时结算的，所以原本属于Alice的都分配给Bob。这就是欺诈作恶成本。</p>
<p>之所以说Segwit隔离见证是闪电网络的基础，是因为Funding Tx只有在第一个Commitment Tx完成签名并交换之后，才会继续签名和广播（否则，广播Funding Tx后若Bob拒绝提供第一个Commitment的签名，这笔资金将被永久锁定，无法消费。拥有Commitment Tx后可以广播赎回）。此时第一个Commitment Tx消费的Funding Tx未曾广播入链，因此需要保证该Funding Tx未被篡改，即txid的固定性。</p>
<p>而对于多方中转交易，在上文中描述有误。根据<a href="https://www.youtube.com/watch?v=SUfBq2nwPek">Bitcoin Lightning Network Payment Channels Explained - Thaddeus Dryja</a>（Youtube视频，需要梯子），在上文的例子中，Alice和Bob之间没有建立直接支付通道，需要经过第三方Charlie中转（与Alice和Bob各自建立支付通道，非可信第三方），同时Alice与Bob之间需要建立正常的TCP/IP等通信通道。若Alice需要向Bob转账，Bob选择随机数R，并且生成哈希H，将H通过通信信道发给Alice。Alice与Charlie之间达成合约，即Charlie能在指定时间内展示出正确的R值，Alice即支付指定金额，否则撤回该合约。同理Charlie与Bob间也是如此。</p>
<p>实际上，这样的Charlie相当于目前金融系统里的支付宝角色，一个持久而且大多数节点建立支付通道的节点（或者节点群，类似与Alice与Bob间经过多个节点，这些节点群之间建立支付通道，因此Alice与Bob之间能比较容易找到路由）。同时，对于频繁支付或者大额支付的节点（假设Bob是商家），则Bob与Charlie间的通道容量需要足够大，也就是双方在主链上锚定的资产价值足够高，否则需要经常的关闭（主动方提现需要等一定区块时间）和建立多个通道。这样的并非极端意义的分布式去中心化，但已经利用了区块链的无需信任属性。</p>
]]></content>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>共识算法(3) - PoS</title>
    <url>//articles/consensus-pos/</url>
    <content><![CDATA[<h3 id="PoS-Proof-of-Stake权益证明-相对于PoW的优点："><a href="#PoS-Proof-of-Stake权益证明-相对于PoW的优点：" class="headerlink" title="PoS(Proof of Stake权益证明)相对于PoW的优点："></a>PoS(Proof of Stake权益证明)相对于PoW的优点：</h3><ol>
<li>不需要消耗大量电力成本</li>
<li>发动51%攻击成本更高（PoW矿池或者大量租用矿机集中算力发动攻击，或者快速算法，硬件升级带来的算力提升等，都可能会增加攻击风险。PoS需要收购全网51%的Token，并且持有者的权益在于所持有的Token也更大动力维护系统安全）<blockquote>
<p><a href="https://36kr.com/p/5173291">PoS为什么比PoW更能避免51%攻击？</a></p>
</blockquote>
</li>
</ol>
<h3 id="PoS运行过程"><a href="#PoS运行过程" class="headerlink" title="PoS运行过程"></a>PoS运行过程</h3><ol>
<li>质押stake，声明为验证节点（区别于全节点拥有出块的权利，会有一定的门槛，如持有stake量，占有比例，或者top n等条件，意在控制验证节点数量，缩小选举的范围以及达成bft共识的节点数）</li>
<li>选举 （周期性选举，以之前已出块的值作为随机种子，选取下一周期的出块节点和顺序，选举算法包含Follow-the-Satoshi选择随机stake的持有节点和RR-BFT轮询算法）</li>
<li>打包交易 （该论的出块节点从交易缓存池选择，通常为交易手续费高，时间早等，验证，包括签名，账户余额等。如果该论的出块节点没有出块，则跳过该论，并且惩罚）</li>
<li>广播交易，确认（PoS分为基于链的PoS和BFT风格的PoS。在<strong>基于链的PoS</strong>中，最长链原则，随机算法选出验证者创建新区块，但是验证者要确保该块指向最长链，通常也需要一定数量的验证节点背书签名后上链。在<strong>BFT风格的PoS</strong>中，分配给验证者相对的权力，以RR的方式提出块并且给被提出的块投票，从而决定哪个块是新块，并在每一轮选出一个新块加入区块链。在每一轮中，每一个验证者都为某一特定的块进行投票，最后所有在线和诚实的验证者都将商量被给定的块是否可以添加到区块链中，并且意见不能改变）</li>
</ol>
<blockquote>
<p><a href="https://www.chainnews.com/articles/547932547984.htm">一文读懂 PoS 共识运行七大步骤</a></p>
</blockquote>
<span id="more"></span>
<h3 id="PoS的攻击风险"><a href="#PoS的攻击风险" class="headerlink" title="PoS的攻击风险"></a>PoS的攻击风险</h3><p>比较突出的是<strong>Nothing-at-stake</strong>(无利害关系)和<strong>Long-range-atack</strong>(长程攻击）两种  </p>
<ol>
<li><p>无利害关系 Nothing-at-stake  </p>
<p> Nothing At Stake, a situation where someone loses nothing when behaving badly, but stands to gain everything. 在出现多条区块链相互竞争的情况下，会激励验证者在每条链上都创造区块，以确保利益最大化。因为PoS创造新区块基本上无需成本，只受持有的资产（token）影响，这样使得双花攻击更加容易，而PoW则受算力影响，分散算力反而降低收益期望值，即经济学意义上的机会成本。这个可以一个例子说明。</p>
<blockquote>
<p>如下图所示，仍然是 A、B、C 三个出块节点，假如 A是攻击节点，它在产生分叉时创造两笔交易。一笔将X个币发给自己的一个钱包地址，同时在另外一个分叉上将X个币发到交易所。B、C出块节点因 Nothing At Stake 所以同时会在两条分叉链上出块。当交易被交易所确认后， A 将 X 个币出售兑换成隐私币种，移出交易所。之后 A 通过增加质押币量，或创建多个其他出块节点的方式提升出块权重，只在分叉链继续出块。此时最长链很明显，且逐渐拉开差距，会最终成为最长链，A 成功将 X 个币双花。</p>
<p><img src="/images/token-double-spend.png" alt=""></p>
<p>摘自 ：<a href="http://www.gongxiangcj.com/posts/19085">PoS背后的Nothing At Stake与Long-Range Attack</a></p>
</blockquote>
<p> 解决方案 ： 无成本攻击则引入惩罚机制。验证节点提前抵押一定的stake做为保证金，如果发现验证节点“在多条链上同时出块” 或者 “在错误的链上出块”，立即惩罚扣除一定保证金。只要保证金设置合理，使“双挖”的收益期望值降低，可以从经济学意义上消除这个风险。</p>
</li>
<li><p>长程攻击 Long-range-atack</p>
<p> 恶意节点从很早以前的甚至是创世块开始重新建造一条链，目的来代替正常运行的主链。由于PoS创建区块的成本极小，新链的构造速度可以很快，赶上主链的高度。如果不考虑timestamp，那么恶意节点可以超前当前时刻，创造大量的未来区块时间，从而增加链高度代替正常链。这种情况加上timestamp即可避免。</p>
<p> 考虑timestamp的主要有两种形态，一种是<strong>Posterior Corruption</strong>。譬如如果当前区块高度为X，想从之前的区块K开始分支。那么从K到X之间所有的区块的签发者联合起来（或者通过贿赂，盗窃秘钥等方式），将质押的stake全部撤回，然后创建从K开始创建新链（没有质押就不存在签发X之后的新的区块，但是可以签发之前的，而且避开了双签的惩罚措施），此时创建的新链长度就赶上甚至替代正常链。Casper通过“检查点”（checkpoint）机制来应对这种方案。取消抵押保证金有一个“解冻”时期。同时限制区块分叉上限，节点拒绝回滚比保证金被锁定时间更久的区块，特定的上限区块称之为“检查点”，这样这些撤回的stake在可以用来重签时已经过了检查点。（要理解这段需要了解节点随机选举过程的Follow-the-Satoshi算法，选择随机stake的持有节点）。另外也有研究KEC（Key-Evolving Cryptography）即秘钥签发一次即失效的方案防止二次签发。还有的方案是在交易时也带上前任区块的hash值，这样通过检查交易的这个值，可以避免链的中途恶意分叉。</p>
<p> 另一种方式是<strong>Stake Bleeding</strong>。如图，恶意节点M在正常链选择在M的出块时刻不出块，即Liveness Denial attack，则该轮被跳过，链高度不变，M被惩罚，逐渐的演变下去stake减少，出块机会减少。而在恶意链，M在其时刻出块，其他的则不可能出块，导致M的出块机会增加，演变到最后只有其出块。随着时间的推移会赶上主链。但是研究表明，拥有30%stake的攻击者也需要6年才能实现，现实可行性比较低。</p>
<p> <img src="/images/pos-stake-bleeding.png" alt=""></p>
<p> 长程攻击通常与<strong>Weak Subjectivity</strong>(弱主观性)相关联。区块链网络中的新节点或是长期离线的节点加入到网络中时，会收到当前区块链上所有公开的分支，但是节点并不能分辨出哪些分支是从属于主链的（PoS里最长链原则并不足够，因为PoS里创建区块成本极小，可能存在多条等长链，这与PoW是区别的）。因此，在PoS里，新节点要求验证链外最新状态来解决，节点可以通过询问他们的朋友、区块浏览器等进行区块同步，离线的节点要求在“还原上限”时间内至少要登录同步一次。在线节点因为一直与主链同步，则不存在这个风险。</p>
<blockquote>
<p><a href="https://blog.positive.com/rewriting-history-a-brief-introduction-to-long-range-attacks-54e473acdba9">Rewriting History: A Brief Introduction to Long Range Attacks</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Consensus &amp; Cryptography</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Consensus</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum概念理解</title>
    <url>//articles/understanding-ethereum/</url>
    <content><![CDATA[<blockquote>
<p>必读：</p>
<ul>
<li><strong><a href="https://github.com/ethereum/wiki/wiki/White-Paper">Ethereum White Paper</a></strong></li>
<li><strong><a href="https://ethereum.github.io/yellowpaper/paper.pdf">Ethereum Yellow Paper</a></strong></li>
</ul>
</blockquote>
<h2 id="Block-transaction-account-state-objects-and-Ethereum-tries"><a href="#Block-transaction-account-state-objects-and-Ethereum-tries" class="headerlink" title="Block, transaction, account state objects and Ethereum tries"></a>Block, transaction, account state objects and Ethereum tries</h2><p><img src="/images/understanding-ethereum/ethereum-all-structure.jpg" alt=""></p>
<ul>
<li><strong>The world state trie contains the mapping between addresses and account states.</strong> The hash of the root node of the world state trie is included in a block (in the stateRoot field) to represent the current state when that block was created. <strong>We only have one world state trie.</strong></li>
<li><strong>The account storage trie contains the data associated to a smart contract.</strong> The hash of the root node of the Account storage trie is included in the sccount state (in the storageRoot field). <strong>We have one Account storage trie for each account.</strong></li>
<li><strong>The transaction trie contains all the transactions included in a block.</strong> The hash of the root node of the Transaction trie is included in the block header (in the transactionsRoot field). <strong>We have one transaction trie per block.</strong></li>
<li><strong>The transaction receipt trie contains all the transaction receipts for the transactions included in a block.</strong> The hash of the root node of the transaction receipts trie is included in also included in the block header (in the receiptsRoot field); <strong>We have one transaction receipts trie per block.</strong></li>
</ul>
<p>摘自: <a href="https://www.lucassaldanha.com/ethereum-yellow-paper-walkthrough-2/">Merkle Tree and Ethereum Objects - Ethereum Yellow Paper Walkthrough (2/7)</a></p>
<h2 id="Externally-owned-account-EOA-VS-Contract-account"><a href="#Externally-owned-account-EOA-VS-Contract-account" class="headerlink" title="Externally owned account(EOA) VS. Contract account"></a>Externally owned account(EOA) VS. Contract account</h2><p>两者都使用20字节的地址。EOA外部拥有账户是由用户通过公钥/私钥秘钥对控制的，通过以太坊客户端创建，由秘钥对生成的账户地址。而Contract account则是EOA通过调用创建合约的方法创建的账户，账户内包含合约代码，由调用方EOA的地址和调用方等nonce（该值针对EOA递增，目的为防止重放攻击）经过PLP编码和KEC散列生成账户地址。交易只能由EOA发起，目的方可以是EOA（常见的转账行为，交易transaction的data字段为空），也可以是合约账户（调用执行智能合约，一次调用中也可能包含跨合约调用，即合约账户到另一个合约账户，此时交易transaction的data字段存放的是合约调用的方法名，参数等二进制数据），还有合约部署（目的地址为0，交易transaction的data字段存放）。 </p>
<p><img src="/images/understanding-ethereum/ethereum-account.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>nonce</strong></td>
<td>A scalar value equal to the number of transactions sent from this address or, in the case of accounts with associated code, the number of contract-creations made by this account.</td>
</tr>
<tr>
<td><strong>balance</strong></td>
<td>A scalar value equal to the number of Wei owned by this address.</td>
</tr>
<tr>
<td><strong>storageRoot</strong></td>
<td>A 256-bit hash of the root node of a Merkle Patricia tree that encodes the storage contents of the account (a mapping between 256-bit integer values), encoded into the trie as a mapping from the Keccak 256-bit hash of the 256-bit integer keys to the RLP-encoded 256-bit integer values.</td>
</tr>
<tr>
<td><strong>codeHash</strong></td>
<td>The hash of the EVM code of this account—this is the code that gets executed should this address receive a message call; it is immutable and thus, unlike all other fields, cannot be changed after construction. All such code fragments are contained in the state database under their corresponding hashes for later retrieval.</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>It is not the code that is executed on subsequent transactions sent to the contract. That code is returned by the initialization code. Essentially, the code in the data field is a program that is going to write a program that gets deployed as a smart contract.（部署字节码 + 合约字节码 + AUXDATA + Swarm hash） The standard initialization code generated by the Solidity compiler does the following:</p>
<ol>
<li>Runs the code in the contract’s constructor, setting storage values, etc.</li>
<li>Copies the code for the rest of the contract into memory and returns it.  </li>
</ol>
</blockquote>
<p>新部署的合约代码被打包提交到链上后，所有到运行节点都会执行data字段里的部署代码（特殊情况是部分节点只按需存储部分数据），其合约存在于各运行节点各自的EVM内，并且对应的地址都是一致，即地址与合约对应，保证后续的合约调用。合约代码存放在EVM的virtual rom内，code hash值为代码的哈希值，storage hash存放的是账户的MPT树的root hash。简之，部署合约三个步骤：1. 创建合约账户 2. 执行合约的初始化 3. 拷贝到virtual rom</p>
<blockquote>
<p><a href="https://programtheblockchain.com/posts/2017/12/29/how-ethereum-transactions-work/">How Ethereum Transactions Work</a><br><a href="https://programtheblockchain.com/posts/2018/01/09/how-smart-contract-deployment-works/">How Smart Contract Deployment Works</a></p>
</blockquote>
<span id="more"></span>
<h2 id="MPT"><a href="#MPT" class="headerlink" title="MPT"></a>MPT</h2><p>MPT(Merkle Patricia Tries)是以太坊中存储区块数据的核心数据结构，它是 Merkle Tree 和 Patricia Tree 融合一个树形结构。附上经典的官方结构示例。具体的代码分析网上资料详细。</p>
<p><img src="/images/understanding-ethereum/ethereum-mpt.png" alt=""></p>
<p>以太坊采用改进的Merkle树，因为前后两个block的数据绝大部分都是相同的，不需要同时存储两份。新block的树可以引用上一个block，加上新block内的交易修改的账户。<br><img src="/images/understanding-ethereum/ethereum-mpt-block.png" alt=""></p>
<blockquote>
<p><a href="https://www.yuanxuxu.com/2018/08/17/ethereum-code-analysis-mpt/">以太坊源码分析—MPT树</a><br><a href="https://zhuanlan.zhihu.com/p/50242014">Ethereum以太坊源码分析（三）Trie树源码分析（上）</a><br><a href="https://zhuanlan.zhihu.com/p/50244166">Ethereum以太坊源码分析（三）Trie树源码分析（下）</a>  </p>
</blockquote>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>In Ethereum, when a transaction is mined, smart contracts can emit events and write logs to the blockchain that the frontend can then process. Event在Ethereum里主要有三种用途：  </p>
<ol>
<li><em>smart contract return values for the user interface</em><br> 发送交易调用合约的返回结果是交易的哈希值，而不是合约的返回值（只有在被打包进区块时才执行合约）。执行合约产生的结果可以作为时间写入区块，调用方可以根据合约哈希值相应获取。</li>
<li><em>asynchronous triggers with data</em><br> 异步时间触发，类似于观察者模式。</li>
<li><em>a cheaper form of storage</em><br> 称为log（通过LOG这个EVM操作码）。相比stroage耗费的gas小得多，可以用作存储，但是不能在合约中被调用。例如可以存放历史数据，前端可以通过遍历区块去获取。</li>
</ol>
<blockquote>
<p><a href="https://media.consensys.net/technical-introduction-to-events-and-logs-in-ethereum-a074d65dd61e">Technical Introduction to Events and Logs in Ethereum</a></p>
</blockquote>
<h2 id="GHOST"><a href="#GHOST" class="headerlink" title="GHOST"></a>GHOST</h2><p>GHOST协议（Greedy Heaviest Observed Subtree protocol）。同样是POW，比特币由于出块时间10min，取最长链。而Ethereum出块时间短（6s），不足扩撒至全网，如果取最长链，则地域优势明显。因此，Ethereum选择最重的链，也就是兄弟节点之间子树节点最多的被选为主链。例子可以参考 <a href="http://www.jouypub.com/2018/9b19cff7135411bd37356e6c4f5f63b7/">以太坊Ghost协议和叔块</a>。主要是要解决 1. 出块速度快，存在多个节点同时出块，但是在自身出块后才接收到别的节点传输的块，浪费算力。2. 更严重的是因为出块速度块带来的地域优势，越早接收到合法块的节点出下一个块的可能性更大，从而造成的中心化风险。通过增加叔块选择最重的链，也就是选择工作量最大的链，降低地域优势。同时奖励叔块，激励节点出块。</p>
<blockquote>
<p><a href="https://github.com/ethereum/wiki/wiki/White-Paper#modified-ghost-implementation">官方文档 - Modified GHOST Implementation</a> ： 详细介绍了GHOST稀释风险，以及叔块的选择标准和奖励方案。</p>
</blockquote>
<h2 id="Transaction-Structure"><a href="#Transaction-Structure" class="headerlink" title="Transaction Structure"></a>Transaction Structure</h2><div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>nonce</strong></td>
<td>A scalar value equal to the number of transactions sent by the sender</td>
</tr>
<tr>
<td><strong>gasPrice</strong></td>
<td>A scalar value equal to the number of Wei to be paid per unit of gas for all computation costs incurred as a result of the execution of this transation</td>
</tr>
<tr>
<td><strong>gasLimit</strong></td>
<td>A scalar value equal to the maximum amount of gas that should be used in executing this transaction. This is paid up-front, before any computation is done and may not be increased later</td>
</tr>
<tr>
<td><strong>to</strong></td>
<td>The 160-bit address of the message call’s recipient or, for a contract creation transaction, ∅, used here to denote the only member of B0</td>
</tr>
<tr>
<td><strong>value</strong></td>
<td>A scalar value equal to the number of Wei to be transferred to the message call’s recipient or, in the case of contract creation, as an endowment to the newly created account</td>
</tr>
<tr>
<td><strong>v, r, s</strong></td>
<td>Values corresponding to the signature of the transaction and used to determine the sender of the transaction.<br>For the signing, Ethereum uses the same elliptic curve as Bitcoin’s, which is <a href="https://en.bitcoin.it/wiki/Secp256k1">secpk256k1</a>.<br>用于从签名中恢复ECDSA公钥，从而得到发送方from的地址<br>Ref: <a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v">ECDSA: (v, r, s), what is v?</a></td>
</tr>
<tr>
<td><strong>data</strong></td>
<td>An unlimited size byte array specifying the input data of the message</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><a href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/design/protocol_description.html">FISCO BCOS 2.0+ 的交易结构</a>在原以太坊的交易结构的基础上，有所增减字段。比较重要的新增字段是<strong>blockLimit</strong>，表示 交易生命周期，该交易最晚被处理的块高.</p>
</blockquote>
<h2 id="Geth-Sync-Modes"><a href="#Geth-Sync-Modes" class="headerlink" title="Geth Sync Modes"></a>Geth Sync Modes</h2><p><img src="/images/understanding-ethereum/sync-modes.jpeg" alt=""></p>
<ul>
<li><strong>Archive nodes</strong>： 存储创世块至今的所有区块历史数据，包括每个区块的状态。适合对历史状态的快速查找。</li>
<li><strong>Full sync mode(Full nodes)</strong>: 从创始块开始按以下步骤下载和重放执行交易以验证每个区块。周期性的创建checkpoint。只保留最近的128个区块的状态树，过期的区块状态树将被修剪。<ol>
<li>download and verify headers</li>
<li>download block bodies and receipts. In parallel, download raw state data and build state trie</li>
<li>heal state trie to account for newly arriving data</li>
</ol>
</li>
<li><strong>Snap sync mode(Full nodes)</strong>: 与Full sync mode类似，差别在于从相对近期的checkpoint开始以上的下载执行校验步骤。</li>
<li><strong>Light nodes</strong>: 只下载和校验区块头。非常依赖于无私的全节点提供数据服务，接收全节点的凭证，与本地的区块头校验。常用于提交交易。<blockquote>
<p><a href="https://geth.ethereum.org/docs/fundamentals/sync-modes#main-content">Geth官方文档 - Sync Modes</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum设计理念Design Rationale学习心得</title>
    <url>//articles/ethereum-design-rationale/</url>
    <content><![CDATA[<p>本文为Ethereum设计理念官方文档<a href="https://github.com/ethereum/wiki/wiki/Design-Rationale">Design Rationale</a>的阅读理解，并非完整的中文翻译，可参考<a href="https://ethfans.org/posts/510">中文翻译</a>。而这个官方文档阐述的是Ethereum演进过程中区别于传统加密货币之处，包含优点，一些有争议性的话题，以及各自的风险。</p>
<h3 id="基本准则"><a href="#基本准则" class="headerlink" title="基本准则"></a>基本准则</h3><ol>
<li><strong>三文治式的复杂度模型</strong>  </li>
</ol>
<ul>
<li>尽量简单的底层结构（如核心共识算法）以及易于使用理解的接口层（developers and users）。复杂度在中间层（serialization and deserialization scripts, storage data structure models, the leveldb storage interface and the wire protocol, etc）。也就是，底层基本的核心思想维持稳定和简单，将易变的可替换的具体实现放在中间层。</li>
<li>尽可能的包含底层概念，使得可以任意方式去组合。同时当剥离不必要的功能也能使底层运行得更有效率。</li>
<li>核心层拒绝内嵌高层应用特性，而鼓励以合约的方式来模拟实现高层应用协议。</li>
</ul>
<ol>
<li><p><strong>自由度</strong><br>保持”net neutrality”网络中性。对contracts or transactions没有先天的偏好性。通过设置费用引入激励。这里涉及到gas的概念，基本理念就是对需要计算和存储的操作需要付出代价。对计算，对存储的字节数等计算一个gas值，而每个发送方指定一个gas值所等值的Ether(即gas fee)，相乘得出为当前的交易费用。交易费用高的当然优先被确认。这就是所谓的将自由度交还给交易发起方，而Ethereum本身保持中性无偏好。引入计算和存储费用，也可以防止DOS攻击。</p>
</li>
<li><p><strong>高风险承受力</strong><br>可以接受高收益带来的高风险（例如出块速度提升50倍，共识效率等），意味着协议演进过程可能会变动较大</p>
</li>
</ol>
<span id="more"></span>
<h3 id="使用Account模型而非UTXO"><a href="#使用Account模型而非UTXO" class="headerlink" title="使用Account模型而非UTXO"></a>使用Account模型而非UTXO</h3><p>unspent transaction outputs (UTXOs)在数字货币内广泛使用，即所有者关联着多笔UTXO，其和为所有者对账户余额，每次交易以单笔或者多笔UTXO为输入，输出也为UTXO。主要符合三个约束：</p>
<ol>
<li>输入的UTXO有效，并且未被消费</li>
<li>交易者能证实UTXO的所有权（签名）</li>
<li>输入UTXO等于或者超过输出UTXO（消费，转账等）  </li>
</ol>
<p>UTXO的好处在于：</p>
<ol>
<li><strong>高隐私度</strong> - 每次交易都使用新地址，则这些账户很难被关联起来。但是dapp反而通常需要关联用户状态。</li>
<li><strong>潜在的高扩展度</strong> - 用户自身保管UTXO，全网丢失只会影响当前用户。而账户模型下，是记录在merkle tree内的，如果全网丢失该账户记录，则永久影响该账户。</li>
</ol>
<p>（实际上，UTXO模型还有以下特点）  </p>
<ol>
<li>账户数据库会不断膨胀，因为账户不会被删除，而UTXO数据库体积会小很多。</li>
<li>由于只有未花费的输出会被保留，所以每一个比特币用户可以拥有几乎无限多的地址，提高了匿名性。</li>
<li>UTXO为高并发的交易带来可能，试想传统的账户模型，每个人的账户交易必须是线性的，无法并发。而现在每个人可能拥有多个UTXO，可同时发起多笔交易，实现了并发。</li>
</ol>
<p>而Account模型好处在于：</p>
<ol>
<li><strong>节约存储空间</strong> - 多个UTXO的存储合并成一个Account</li>
<li>可以判断来源，从而建立红黑名单</li>
<li>理解和编程模型简单，而且light client可以直接跟踪特定的account，而不用跟踪每笔交易带来的影响</li>
</ol>
<p>Account的问题在于重放攻击，因此可以每个交易添加nonce，每次交易nonce递增加1。同时，交易包含区块号，定期的修剪删除不再使用的账户。</p>
<h3 id="Gas-and-Fee"><a href="#Gas-and-Fee" class="headerlink" title="Gas and Fee"></a>Gas and Fee</h3><p>Bitcoin等数字货币操作比较简单和单一的交易转账行为，而Ethereum则是图灵完备，具有很高的合约自由度。引入费用防止合约执行无限循环的DOS，实际上就是引入作恶成本。</p>
<ol>
<li>发起调用合约会预缴startGas * gasPrice（即一个gas等价于的Ether），途中每个交易操作会相应扣除gas，合约结束后剩余的gas退还到发起账户，消耗的gas奖励给miner。如果中途gas已消耗完，则该次交易内之前已执行的操作回滚，交易失败，gas奖励给miner。合约间调用也需要消耗gas，由发起合约设置值。</li>
<li>按照计算复杂度（opcode），数据的字节数，存储的字节数等计算gas值。此外还有基础gas，用以支付计算椭圆曲线从签名确认身份等。也即是按消耗付款。</li>
<li>删除存储的空间的操作有gas refund奖励，鼓励减少存储空间。</li>
<li>gasPrice的设置则变成经济供求关系，自由竞争最终达到动态平衡。出价高收益大的交易会被优先执行和确认。</li>
</ol>
<h3 id="RLP"><a href="#RLP" class="headerlink" title="RLP"></a>RLP</h3><p><a href="https://github.com/ethereum/wiki/wiki/RLP">RLP</a> (“recursive length prefix”) encoding is the main serialization format used in Ethereum。例如，Account等数据从内存写入持久化存储时会将Hex16进制转换成RLP持久化(结合MPT树，将Extension node, Leaf node, Branch node等数据结构进行RLP编码)，紧凑节省空间。相比protocol buffer和BSON等现存的序列化方案，从新开发RLP序列化方案的目的是，1）实现简单。目的就是要高度简化，存储嵌套的字节序列，由上层应用决定这些字节序列的含义。2）保证字节级的绝对一致性（Key/value maps的有序性，浮点数的精度问题等）。RLP将 1）字符串（字节序列）作为item，2）item列表也看作一个item，针对这些item使用其定义的序列化编解码方式。</p>
<h3 id="EVM虚拟机"><a href="#EVM虚拟机" class="headerlink" title="EVM虚拟机"></a>EVM虚拟机</h3><p>设计理念：</p>
<ol>
<li>简单 尽量少的数据类型，尽量少的操作指令。尽量节省的空间。结合起gas消费模型，也从根本上保证安全不被无限制利用。</li>
<li>定制化 针对以太坊常见应用，对20字节地址，32字节对加密算法，加密算法中的数学运算，读取存储区块及交易信息等，作虚拟机层面的定制化的优化</li>
</ol>
<p><img src="/images/ethereum-evm.png" alt=""></p>
<p>具体的设计：</p>
<ol>
<li>存储模型 EVM是基于栈的计算模型。stack（32字节，运行堆栈，所有运算在栈上执行，算子和执行中间结果都从栈存储和读取），memory（byte数组，存储函数调用的参数，本地变量，返回值等），storage（KV持久化存储，256-bit words to 256-bit words）</li>
<li>合约间调用内存隔离，区分临时存储和持久化存储，递归调用每次都使用独立的实例，拥有独立的内存地址空间。具体实例参看原文。</li>
<li>32字节的位宽 加密算法使用32字节，因此32字节位宽不需要分开存储，也不至于浪费空间。</li>
<li>1024层的栈调用深度，并且单个操作码最多只能操作栈顶的16个元素</li>
<li>定制化VM 没有使用JVM等原因在于：1）EVM相对简单，避免复杂带来的安全性等风险；2）可以针对性定制化设计；3）不存在部署的外部依赖；4）不需要改造其他VM时带来的安全性审核工作</li>
</ol>
<blockquote>
<p><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">EVM详解</a> : 详细的ppt版本<br><a href="https://www.mayowatudonu.com/blockchain/deep-dive-into-evm-memory-and-storage">A Deep Dive into the Ethereum Virtual Machine (EVM) - part 2: Memory and Storage</a> : 包含EVM的操作指令opcodes</p>
</blockquote>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric的configtxgen工具生成区块及配置文件分析</title>
    <url>//articles/fabric-configtxgen-tool/</url>
    <content><![CDATA[<p>本节主要基于<a href="https://github.com/hyperledger/fabric-samples/tree/release-1.4/basic-network">fabric-samples/basic-network</a>分析。查看<code>generate.sh</code>这个脚本，里面主要执行了如下四个命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 生成msp模块需要的证书</span><br><span class="line">cryptogen generate --config=./crypto-config.yaml</span><br><span class="line"></span><br><span class="line">// 生成创世块</span><br><span class="line">configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block</span><br><span class="line"></span><br><span class="line">// 生成创建channel的配置</span><br><span class="line">configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID <span class="variable">$CHANNEL_NAME</span></span><br><span class="line"></span><br><span class="line">// 生成设置anchor节点的配置</span><br><span class="line">configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID <span class="variable">$CHANNEL_NAME</span> -asOrg Org1MSP</span><br></pre></td></tr></table></figure></p>
<p><code>cryptogen</code>和<code>configtxgen</code>分别用于加密和配置的工具，其代码路径为<code>hyperledger/fabric/common/tools/cryptogen</code>和<code>hyperledger/fabric/common/tools/configtxgen</code>。cryptogen产生了各级msp，在peer，orderer里皆有用到，包括后面介绍的configtxgen里包含msp信息这些也是由此产生。这里暂且不展开分析。</p>
<p>在<code>configtxgen/main.go</code>里，依然使用viper作为命令行管理工具。代码比较直观，阅读简单不展开分析，感兴趣可以参考<a href="https://www.chaindesk.cn/witbook/30/503">Hyperledger Fabric（V1.2）源码深度解析－configtxgen命令解析</a>，写的比较概述。其中读取配置文件的<code>common/tools/configtxgen/localconfig/config.go#Load</code>方法里，主要由以下几行<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Prefix <span class="keyword">string</span> = <span class="string">&quot;CONFIGTX&quot;</span></span><br><span class="line"><span class="keyword">var</span> configName = strings.ToLower(Prefix)</span><br><span class="line"></span><br><span class="line">viper.SetConfigName(configName)</span><br></pre></td></tr></table></figure><br>可见，默认读取的是当前目录的<code>configtx.yaml</code>配置文件。生成创世块和创建channel的配置对应的分别是<code>doOutputBlock</code>和<code>doOutputChannelCreateTx</code>这两个方法。<code>doOutputBlock</code>生成<code>cb.Block</code>对象，这个对象通过<code>ioutil.WriteFile(outputBlock, utils.MarshalOrPanic(genesisBlock), 0644)</code>写到指定的<code>genesis.block</code>这个文件。这个对象可以使用<code>configtxgen -inspectBlock genesis.block</code>这个命令查看。生成的JSON格式文件可参见<a href="https://github.com/simplexity-ckcclc/gofabric/blob/master/doc/fabric-samples/basic-network/genesis_block.json">JSON结构</a>。其中ChannelHeaderType设置为HeaderType_CONFIG，block.number为0，previousHash为nil。payload里主要是ConfigGroup对象，包含有序号sequence，以及channel_group对象。channel_group主要是Consortium（包含version，policies，configtx.yaml里定义的orgs，此处orgs里又包含MSP和policies）和Orderer（包含policies，msp）。同时ConfigGroup还包含OrdererAddress,hashAlgorithm,BlockDataHashiungStructure这些。从中，还可以看出，每一级的设置，都包含不同的polocies。</p>
<p><code>doOutputChannelCreateTx</code>生成<code>cb.Envelope</code>对象，写到<code>channel.tx</code>。ChannelHeaderType设置为HeaderType_CONFIG_UPDATE，channel_id为命令后参数$CHANNEL_NAME。payload里是<code>cb.ConfigUpdateEnvelope</code>对象，包含channel_id, read_set, write_set. 这里，read_set里policies为空，version为0；write_set里version为1，并且定义了policies。所以当使用该channel.tx文件再次创建已经存在的channel时，会报错verifyReadset失败。同样的可以用<code>configtxgen --inspectChannelCreateTx channel.tx</code>这个命令查看其<a href="https://github.com/simplexity-ckcclc/gofabric/blob/master/doc/fabric-samples/basic-network/channel_tx.json">JSON结构</a>。</p>
<p>查看<code>start.sh</code>脚本，实际上在peer节点使用Admin角色执行了创建channel命令。<code>peer channel create -o orderer.example.com:7050 -c mychannel -f /etc/hyperledger/configtx/channel.tx</code>。当顺利执行后，结果返回一个当前channel的首个block，名称为<code>$&#123;CHANNEL_NAME&#125;.block</code>。这里block的number为0，pre_hash为null，channel_header里的channel_id是当前channel名称，ChannelHeaderType还是HeaderType_CONFIG。这里因为使用了Admin角色创建，因此signature_header里记录了creator的信息。而payload同时包含了创世块genesis.block和创建channel配置文件channel.tx的信息，特别的是，里面last_update字段则完整记录了<code>channel.tx</code>。同样的可以用<code>configtxgen -inspectBlock $&#123;CHANNEL_NAME&#125;.block</code>这个命令查看其<a href="https://github.com/simplexity-ckcclc/gofabric/blob/master/doc/fabric-samples/basic-network/mychannel.json">JSON结构</a>。这个区块在<code>start.sh</code>脚本里后续用于<code>channel join -b mychannel.block</code>将节点加入到该channel。</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><blockquote>
<p><a href="https://tech.lock-in.cn/news/a74a120208ac49c0a457e54e9efed4bb">Hyperledger Fabric权限进阶篇</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学基础知识汇总及Fabric的MSP体系</title>
    <url>//articles/fabric-cryptography-msp-summary/</url>
    <content><![CDATA[<p>这篇只是汇总在学习密码学和Fabric的MSP体系过程中的阅读，方便日后回头翻阅，可以迅速回忆。涉及内容较多主体较为分散，挂一漏万。仍有待深入研究学习。</p>
<ol>
<li><p>密码学的基础知识概述（Hash算法，对称加密算法，X.509证书）</p>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/ckcclc/article/details/89361898">CSDN笔记 - MD5, SHA, AES, DES, X.509, PKCS概述</a> : 记录基础知识 </li>
<li><a href="https://knowledge.digicert.com/solution/SO4583.html">Structure of X509 Certificates</a> : X.509结构  </li>
</ul>
</blockquote>
</li>
<li><p>RSA</p>
<blockquote>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">RSA算法原理(一)</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理(二)</a> : 数学原理介绍，欧拉函数，大数因数分解</li>
</ul>
</blockquote>
</li>
<li><p>ECC（椭圆曲线）</p>
<blockquote>
<ul>
<li><a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic Curve Cryptography: a gentle introduction</a> : 英文介绍系列，原理解释。非欧式几何，有限域离散对数问题。强力推荐  </li>
<li><a href="https://www.ssl.com/article/comparing-ecdsa-vs-rsa/">Comparing ECDSA vs RSA</a> : ECDSA和RSA的全方位对比。RSA历史更悠久更成熟，部分CA还不支持ECDSA。在提供相同安全程度上，ECDSA需要的bit更少。同时，RSA seems to be significantly faster than ECDSA in verifying signatures, though it is slower while signing. Higher security level require more bits, this results in RSA’s performance to decline dramatically, whereas ECDSA is only slightly affected.</li>
</ul>
</blockquote>
<p>当前，Fabric的签名算法只支持ECDSA（The signing key used for signing by the node <strong>(currently only ECDSA keys are supported)</strong>），摘自<a href="https://hyperledger-fabric.readthedocs.io/en/master/msp.html#how-to-generate-msp-certificates-and-their-signing-keys">Fabric官网-Membership Service Providers (MSP)</a></p>
<p>Ref: Bitcoin和Ethereum中的vrs（v：recovery id）</p>
<blockquote>
<ul>
<li><a href="https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v">ECDSA: (v, r, s), what is v?</a> ： Strictly speaking the recid is not necessary, as we can just cycle through all the possible coordinate pairs and check if any of them match the signature. The recid just speeds up this verification.</li>
<li><a href="https://crypto.stackexchange.com/questions/18105/how-does-recovering-the-public-key-from-an-ecdsa-signature-work">How does recovering the public key from an ECDSA signature work?</a></li>
</ul>
</blockquote>
</li>
<li><p>零知识证明 Zero-Knowledge-Proof</p>
<blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Zero-knowledge_proof">Zero-Knowledge-Proof Wikipedia</a>  </li>
<li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/idemix.html">MSP Implementation with Identity Mixer</a> : Fabric里对零知识证明的使用  </li>
</ul>
</blockquote>
</li>
<li><p>Fabric官网的MSP相关文档汇总</p>
<blockquote>
<ul>
<li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/identity/identity.html">Identity</a> : 最基本的概念，PKI体系，X.509证书，CA，CRL，概念介绍  </li>
<li><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/membership/membership.html">Membership</a> : 概念介绍，MSP的层次设计（Local MSP，Channel MSP），MSP的结构（主要是在节点内的证书存放目录），以及与Org的关系  </li>
<li><a href="https://hyperledger-fabric.readthedocs.io/en/master/msp.html#how-to-generate-msp-certificates-and-their-signing-keys">Membership Service Providers (MSP)</a> : 配置，偏实践应用  </li>
</ul>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>Consensus &amp; Cryptography</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
        <tag>Cryptography</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric官网Commercial Paper案例chaincode的golang实现</title>
    <url>//articles/fabric-commercial-paper-go/</url>
    <content><![CDATA[<p>官网上描述了<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/developapps/developing_applications.html">Commercial Paper</a>这个应用场景，并且提供了<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/tutorial/commercial_paper.html#">nodejs实现</a>。这里补充chaincode的golang实现，保持逻辑一致，以及记录实际操作中的一些步骤和要点。实现的源码已上传<a href="https://github.com/simplexity-ckcclc/gofabric/tree/master/chaincode/commercial-paper/go">github</a>。</p>
<ol>
<li><p>按照官网Commercial Paper nodejs实现里的步骤，启动<code>net_basic</code>网络，并且启动了<code>peer0.org1.example.com</code>, <code>couchdb</code>, <code>ca.example.com</code>, <code>orderer.example.com</code>, <code>cliDigiBank</code>, <code>cliMagnetoCorp</code>这些容器（按照步骤里执行下来，docker ps能看到这些容器）。</p>
</li>
<li><p>install chaincode。执行<code>docker inspect cliMagnetoCorp</code>，能看到<code>/Users/ckcclc/github/fabric-samples/commercial-paper/organization/magnetocorp:/opt/gopath/src/github.com</code>这个路径绑定。在<code>/Users/ckcclc/github/fabric-samples/commercial-paper/organization/magnetocorp</code>创建目录<code>gocontract</code>，将golang实现放在这个目录里。这时候登录到<code>cliMagnetoCorp</code>容器，可以看到容器内<code>/opt/gopath/src/github.com/application</code>下有<code>gocontract</code>这个目录，并且go实现在内。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer chaincode install -n gopapercontract -v 0 -p github.com/gocontract</span><br></pre></td></tr></table></figure>
<p> 同时，<code>docker inspect cliMagnetoCorp</code>(或者<code>cliMagnetoCorp</code>容器执行<code>env</code>查看），<code>GOPATH=/opt/gopath, CORE_PEER_ADDRESS=peer0.org1.example.com:7051</code>。<code>install</code>会到<code>$&#123;GOPATH&#125;/src</code>下寻找source code。然后install chaincode到<code>$&#123;CORE_PEER_ADDRESS&#125;</code>。</p>
<p> 登录<code>peer0.org1.example.com</code>容器。<code>env</code>出来<code>FABRIC_CFG_PATH=/etc/hyperledger/fabric</code>，查看改路径下的<code>core.yaml</code>配置文件，其中<code>peer.fileSystemPath : /var/hyperledger/production</code>。查看<code>/var/hyperledger/production/chaincodes</code>目录，存在文件<code>gopapercontract.0</code>(即${chaincodeName}.${chaincodeVersion}).</p>
</li>
<li><p>instantiate chaincode。登录<code>cliMagnetoCorp</code>容器，执行</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer chaincode instantiate -n gopapercontract -v 0 -c <span class="string">&#x27;&#123;&quot;Args&quot;:[]&#125;&#x27;</span> -C mychannel -P <span class="string">&quot;AND (&#x27;Org1MSP.member&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
<p> 此时，<code>docker ps</code>可以看到dev-peer0.org1.example.com-gopapercontract-0这个容器。可以在<code>cliMagnetoCorp</code>容器执行。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer chaincode invoke -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;issue&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;, &quot;2020-05-31&quot;, &quot;2020-11-30&quot;, &quot;5000000&quot;]&#125;&#x27;</span> -C mychannel -n gopapercontract</span><br><span class="line">peer chaincode query -c <span class="string">&#x27;&#123;&quot;Args&quot;:[&quot;query&quot;,&quot;MagnetoCorp&quot;, &quot;00001&quot;]&#125;&#x27;</span> -C mychannel -n gopapercontract</span><br></pre></td></tr></table></figure>
<p> 如果后续更新chaincode，假设更新版本为1，则执行</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">peer chaincode upgrade -n gopapercontract -v 1 -c <span class="string">&#x27;&#123;&quot;Args&quot;:[]&#125;&#x27;</span> -C mychannel -P <span class="string">&quot;AND (&#x27;Org1MSP.member&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>fabric-samples/commercial-paper/organization/magnetocorp/application/issue.js</code>这个文件</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 63行 const contract = await network.getContract(&#x27;papercontract&#x27;, &#x27;org.papernet.commercialpaper&#x27;);</span></span><br><span class="line">    <span class="keyword">const</span> contract = <span class="keyword">await</span> network.getContract(<span class="string">&#x27;gopapercontract&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 73行 let paper = CommercialPaper.fromBuffer(issueResponse);</span></span><br><span class="line">    <span class="keyword">let</span> paper = <span class="built_in">JSON</span>.parse(issueResponse);</span><br></pre></td></tr></table></figure>
<p> 然后，就可以正常调用<code>node issue.js</code>访问刚启动的golang commercial paper容器了。在整个流程中，可以执行<code>./monitordocker.sh net_basic</code>查看chaincode的日志。</p>
</li>
</ol>
<span id="more"></span>
<p>另外，在peer0.org1.example.com节点上可以使用<code>peer chaincode list</code>命令查询channel内instantiated的chaincode以及peer上installed的chaincode。</p>
<ol>
<li>查询channel内instantiated的chaincode。   <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ peer chaincode list -C mychannel --instantiated</span><br><span class="line"></span><br><span class="line">Get instantiated chaincodes on channel mychannel:</span><br><span class="line">Name: gopapercontract, Version: 1, Path: github.com/gocontract, Escc: escc, Vscc: vscc</span><br><span class="line">Name: papercontract, Version: 0, Path: /opt/gopath/src/github.com/contract, Escc: escc, Vscc: vscc</span><br></pre></td></tr></table></figure></li>
<li>查询peer上installed的chaincode。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ peer chaincode list  -C mychannel --installed</span><br><span class="line"></span><br><span class="line">Error: Bad response: 500 - access denied <span class="keyword">for</span> [getinstalledchaincodes]: Failed verifying that proposal<span class="string">&#x27;s creator satisfies local MSP principal during channelless check policy with policy [Admins]: [This identity is not an admin]</span></span><br></pre></td></tr></table></figure>
 从返回结果可以看出，当前使用的角色并非Admin（这与MSP相关，使用的非Admin的X509证书）。因此可以指定使用Admin。 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认使用的MSP config</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$CORE_PEER_MSPCONFIGPATH</span></span><br><span class="line">/etc/hyperledger/msp/peer/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区别在于keystore存放的用来签名请求的私钥。</span></span><br><span class="line">$ ls <span class="variable">$CORE_PEER_MSPCONFIGPATH</span></span><br><span class="line">admincerts  cacerts  keystore  signcerts  tlscacerts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置使用Admin的MSP config</span></span><br><span class="line">$ CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">$ peer chaincode list  -C mychannel --installed</span><br><span class="line"></span><br><span class="line">Get installed chaincodes on peer:</span><br><span class="line">Name: gopapercontract, Version: 0, Path: github.com/gocontract, Id: 44777e9463329c5b03a93abd48975980a795152907d0c6226b0b85589f4a0ca7</span><br><span class="line">Name: gopapercontract, Version: 1, Path: github.com/gocontract, Id: d000a5b0e4ed415ae1739e716c13a481096b947cb31dd5f25ab1d67633d18bb0</span><br><span class="line">Name: papercontract, Version: 0, Path: /opt/gopath/src/github.com/contract, Id: f09e75abcf455f6fb83257080ebd739f1d2397cf50ce2e52cd805d992a64bc03</span><br></pre></td></tr></table></figure></li>
<li>使用openssl查看X.509证书。下面是Admin证书的示例 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ openssl x509 -noout -text -<span class="keyword">in</span> Admin\@org1.example.com-cert.pem</span><br><span class="line"></span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            15:2c:67:2c:01:ac:bb:4e:33:ac:59:00:13:0c:e7:eb</span><br><span class="line">    Signature Algorithm: ecdsa-with-SHA256</span><br><span class="line">        Issuer: C=US, ST=California, L=San Francisco, O=org1.example.com, CN=ca.org1.example.com</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Aug 31 09:14:32 2017 GMT</span><br><span class="line">            Not After : Aug 29 09:14:32 2027 GMT</span><br><span class="line">        Subject: C=US, ST=California, L=San Francisco, CN=Admin@org1.example.com</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: id-ecPublicKey</span><br><span class="line">                Public-Key: (256 bit)</span><br><span class="line">                pub:</span><br><span class="line">                    04:57:57:5f:98:ac:6c:14:a5:a8:ee:8e:83:34:12:</span><br><span class="line">                    1a:21:57:9b:08:23:c0:33:d0:bf:b0:b0:6d:e2:92:</span><br><span class="line">                    51:ad:ef:69:58:4f:7c:ec:38:d7:66:86:77:82:57:</span><br><span class="line">                    38:f8:3a:0f:32:d4:e6:05:1a:9b:3d:5c:18:71:4b:</span><br><span class="line">                    e9:6d:86:3c:a7</span><br><span class="line">                ASN1 OID: prime256v1</span><br><span class="line">                NIST CURVE: P-256</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Digital Signature</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:FALSE</span><br><span class="line">            X509v3 Authority Key Identifier:</span><br><span class="line">                keyid:42:39:AA:0D:CD:76:DA:EE:B8:BA:0C:DA:70:18:51:D1:45:04:D3:1A:AD:1B:2D:DD:DB:AC:6A:57:36:5E:49:7C</span><br><span class="line"></span><br><span class="line">    Signature Algorithm: ecdsa-with-SHA256</span><br><span class="line">        30:44:02:20:5c:cc:b6:e8:01:14:<span class="built_in">fc</span>:65:0c:3d:f0:8c:b3:f9:</span><br><span class="line">        d0:8d:03:04:d5:9c:41:1c:06:19:b4:a1:2e:45:1d:fa:d4:9b:</span><br><span class="line">        02:20:48:3d:04:e6:5d:22:88:a8:46:2b:c9:0b:e6:54:ce:f2:</span><br><span class="line">        54:9e:45:ee:a3:61:e4:5a:2b:b1:2e:c8:9b:1b:1b:44</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>共识算法(2) - Practical Byzantine Fault Tolerance论文学习笔记</title>
    <url>//articles/consensus-pbft-paper/</url>
    <content><![CDATA[<h3 id="Service-Properties"><a href="#Service-Properties" class="headerlink" title="Service Properties"></a>Service Properties</h3><ol>
<li>算法的适用范围<blockquote>
<p>Our algorithm can be used to implement any deterministic replicated service with a state and some operations.</p>
</blockquote>
</li>
</ol>
<ul>
<li><em>deterministic</em> ：确定性服务，即相同的参数执行相同操作，每次得到的结果都是一致的，不存在随机性（the execution of an operation in a given state and with a given set of arguments must always produce the same result）</li>
<li><em>replicated</em> : 多副本</li>
<li><em>a state and some operations</em> : 服务有相同的初始状态及相同的操作，保证当按相同顺序执行完相同的操作，各个副本的即时状态是完全一致的 (must start in the same state)</li>
</ul>
<ol>
<li>在异步系统中要容忍<code>f</code>个恶意节点，则至少需要<code>3f+1</code>个节点才能提供safety and liveness（<em>Asynchronous Consensus and Broadcast Protocols</em>这篇论文中证明）。</li>
</ol>
<ul>
<li><em>safety</em> : 副本服务满足线性一致性，像在中心化服务中同时原子性的执行操作。不受恶意client数量影响，恶意client的操作可以通过被正常client感知，利用access control来限制。</li>
<li><em>liveness</em> : 利用同步提供liveness（论文证明）。只要满足<code>3f+1</code>个节点，可以保证client持续重传，并且到达destination的传输时间没有无限的增长情况下，client最终会收到回复。</li>
</ul>
<ol>
<li>算法不提供隐私容错性，即隐私信息会泄漏给恶意节点<blockquote>
<p>The algorithm does not address the problem of fault- tolerant privacy: a faulty replica may leak information to an attacker.</p>
</blockquote>
</li>
</ol>
<span id="more"></span>
<h3 id="The-Algorithm"><a href="#The-Algorithm" class="headerlink" title="The Algorithm"></a>The Algorithm</h3><h4 id="0-术语"><a href="#0-术语" class="headerlink" title="0. 术语"></a>0. 术语</h4><ul>
<li><em>view</em> ：类似raft的term，view number在变更时+1</li>
<li><em>primary</em> ：在一个view中只有单独一个节点p成为primary，选择的方式为<code>p = v mod |R|</code>(p为节点的id，v是当前view number，|R| = 3f+1)</li>
<li><em>backup</em> ： 一个view内除primary外的其他所有节点，与primary都称为replica<br>算法的粗略过程：<blockquote>
<ol>
<li>A client sends a request to invoke a service operation to the primary</li>
<li>The primary multicasts the request to the backups</li>
<li>Replicas execute the request and send a reply to the client</li>
<li>The client waits for <strong><em>f + 1</em></strong> replies from different replicas with the <strong><em>same result</em></strong>; this is the result of the operation.</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="1-The-Client"><a href="#1-The-Client" class="headerlink" title="1. The Client"></a>1. The Client</h4><p>client <code>c</code>点对点发送<code>&lt;REQUEST,o,t,c&gt;$c</code>到primary，然后由primary广播到所有backup。<code>o</code>是操作，<code>t</code>是时间（如本地机器时间），用来保证exactly-once语义，<code>&lt;&gt;$c</code>表示对消息签名（下同）。replica <code>i</code>相应的回复<code>&lt;REPLY,v,t,c,i,r&gt;$i</code>。<code>v</code>是当前view number（存在view-change情况），<code>r</code>是执行结果，然后各自对消息签名。client可以根据回复的view number跟踪当前view，相应的得知当前primary。client接收到f+1个相同结果的有效回复（校验签名），则结果有效，完成。</p>
<p>如果client在有效时间内没法收到f+1个有效结果，则广播request到所有的replica。如果该request已经被处理过，replica就简单的重新发送reply到client。如果没有，backup会将改request重定向到primary。如果primary没有再次将该request广播，则会被认为是异常节点，最终触犯view change。</p>
<h4 id="2-Normal-Case-Operation"><a href="#2-Normal-Case-Operation" class="headerlink" title="2. Normal-Case Operation"></a>2. Normal-Case Operation</h4><p>replica记录的状态</p>
<blockquote>
<p>The state of each replica includes <strong>the state of the service</strong>, a <strong>message log</strong> containing messages the replica has accepted, and an integer denoting the replica’s <strong>current view</strong>.</p>
</blockquote>
<p>整个流程分为三阶段，<em>pre-prepare</em>, <em>prepare</em>, <em>commit</em> (<em>pre-prepare</em>, <em>prepare</em>用于保持同一个view内request的有序性，<em>prepare</em>, <em>commit</em>用于保证跨view的reqeust的有序性）。</p>
<p><img src="/images/pbft-normal-case-operation.png" alt=""></p>
<ol>
<li><p><em>pre-prepare</em> 阶段<br> primary广播<code>&lt;&lt;PRE-PREPARE,v,n,d&gt;$p, m&gt;</code>到所有的backup。<code>n</code>是primary分配给该消息的序号，全局递增，<code>m</code>是client的请求消息，<code>d</code>是消息的digest摘要。然后签名。</p>
<p> 如果满足以下条件，则backup会接受该pre-prepare请求，并且进入prepare阶段(The last condition prevents a faulty primary from exhausting the space of sequence numbers by selecting a very large one.):</p>
 <figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">* the signatures in the request and the pre-prepare message are correct and `d` is the digest for `m`;</span><br><span class="line">* it is in view `v`;</span><br><span class="line">* it has not accepted a pre-prepare message for view `v` and sequence number `n` containing a different digest; </span><br><span class="line">* the sequence number in the pre-prepare message is between a low water mark, `h`, and a high water mark, `H`.</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><em>prepare</em> 阶段<br> backup广播<code>&lt;PREPARE,v,n,d,i&gt;$i</code>消息到所有replica（包含primary和backup），<code>i</code>为该节点id。并且将<code>&lt;PRE-PREPARE&gt;</code>和<code>PREPARE</code>消息保存到本地log。replica接收到prepare消息后，校验签名正确，<code>v</code>是当前view，<code>n</code>在水位<code>h</code>和<code>H</code>之间，摘要<code>d</code>和本地保存的<code>PRE-PREPARE</code>消息里的<code>d</code>相等。当replica i收到<code>2f</code>个这样的<code>PREPARE</code>消息后，就达到了<code>prepared(m,v,n,i)</code> 状态，进入commit阶段。</p>
</li>
<li><p><em>commit</em> 阶段<br> replica i广播<code>&lt;COMMIT,v,n,D(m),i&gt;$i</code>消息到所有replica。replica收到后校验通过后，写入log。如果replica i达到了<code>prepared(m,v,n,i)</code> 状态，并且收到<code>2f+1</code>个（包括自身的commit消息）校验通过的commit（<code>v</code>,<code>n</code>,<code>d</code>相同且与log里记录的prepare吻合），则达到<code>committed-local(m,v,n,i)</code>状态，并且其当前状态是消息序号小于<code>n</code>的之前所有消息按序执行后的最新最全结果，则该replica执行<code>m</code>里指定的操作。操作的结果返回到client。</p>
<blockquote>
<p>The commit phase ensures the following invariant: if committed-local(m,v,n,i) is true for some non-faulty then committed(m,v,n) is true. This invariant and the view-change protocol described in Section 4.4 ensure that non-faulty replicas agree on the sequence numbers of requests that commit locally even if they commit in different views at each replica. Furthermore, it ensures that any request that commits locally at a non-faulty replica will commit at <strong>f+1 or more</strong> non-faulty replicas eventually.</p>
</blockquote>
<p> 这里指的是，达到committed(m,v,n)只能保证至少f+1个正常节点被最终commit，而并不是所有正常节点都执行。这就造成正常节点间都状态不一致，需要最终同步状态。或者使用上文提到Section 4.4里提到都view-change场景下重走commit流程最终达成状态一致。[引用2:Fabric0.6里的最终状态同步方案,3:介绍实时全正常节点同步的方案]</p>
</li>
</ol>
<h4 id="3-Garbage-Collection"><a href="#3-Garbage-Collection" class="headerlink" title="3. Garbage Collection"></a>3. Garbage Collection</h4><p>replica周期性对其本地状态生成快照，称为checkpoint。当replica i生成checkpoint同时，广播<code>&lt;CHECKPOINT,n,d,i&gt;$i</code>消息到其他所有replica，其中，<code>n</code>是生成该状态执行的最后的请求消息的序号，<code>d</code>是该状态的摘要digest。replica接收checkpoint消息，并且记录到log里，当收到<code>2f+1</code>个相同的checkpoint消息（<code>n</code>,<code>d</code>）相同，则该checkpoint变成<strong>stable checkpoint</strong>。此时，小于等于<code>n</code>的消息（pre-prepare, prepare, commit）都会被丢弃，同时，之前的stable checkpoint也被丢弃。</p>
<p>实际上，一个replica会同时持有这样几个状态副本：一个stable checkpoint，若干个未达到稳定状态的checkpoint（生成后暂未收集到2f+1个该状态的checkpoint消息），以及当前状态。stable checkpoint的最后的消息序号<code>n</code>就是低水位<code>h</code>,高水位<code>H = h + k</code>(where   is big enough so that replicas do not stall waiting for a checkpoint to become stable).</p>
<h4 id="4-View-Changes"><a href="#4-View-Changes" class="headerlink" title="4. View Changes"></a>4. View Changes</h4><p>client在有效时间内没法收到f+1个有效结果，则广播request到所有的replica。backup收到后，若该请求从未执行，则转发给primary，并且启动timer，在timer到期前若没有收到primary发出的pre-prepare，则判断该primary异常，发出view-change消息。backup i,<code>&lt;VIEW-CHANGE,v+1,n,C,P,i&gt;$i</code>，<code>v+1</code>是新的view number，<code>n</code>是该backup的stable checkpoint <code>s</code>的最后消息序号，<code>C</code>是证明<code>s</code>的2f+1个checkpoint消息，<code>P</code>是<code>Pm</code>的集合，<code>Pm</code>是达到<code>prepared(m,v,n,i)</code> 状态的消息（包含pre-prepare消息和2f个来自其他replica的matching消息，其中消息<code>m</code>的序号大于<code>n</code>）。</p>
<p><code>v+1</code>的primary（通过<code>p = （v+1）mod |R|</code>计算）收到2f个有效view-change消息后，广播<code>&lt;NEW-VIEW,v+1,V,O&gt;$p</code>，<code>V</code>是收到的和primary自身的view-change消息的集合，<code>O</code>是pre-prepare消息的集合。计算如下，比较复杂<br></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">1. The primary determines the sequence number `min-s` of the latest stable checkpoint in `V` and the highest sequence number `max-s` in a prepare message in `V`.</span><br><span class="line">2. The primary creates a new pre-prepare message for view `v+1` for each sequence number `n` between `min-s` and `max-s`.</span><br><span class="line"> There are two cases: (1) there is at least one set in the component of some view-change message in with sequence number `n`, or (2) there is no such set. </span><br><span class="line"> In the first case, the primary creates a new message `&lt;PRE-PREPARE,v+1,n,d&gt;$p` where `d` is the request digest in the pre-prepare message for sequence number `n` with the highest view number in `V`. </span><br><span class="line"> In the second case, it creates a new pre-prepare message `&lt;PRE-PREPARE,v+1,n,d(null)&gt;$p` where `d(null)` is the digest of a special null request; a null request goes through the protocol like other requests, but its execution is a no-op. (Paxos [18] used a similar technique to fill in gaps.)</span><br></pre></td></tr></tbody></table></figure><br>也就是说，primary从latest stable checkpoint重放之后所有达到<code>prepared(m,v,n,i)</code>状态的消息（<code>min-s</code>&lt;<code>n</code>&lt;=<code>max-s</code>），重发pre-prepare。replica会对这些消息重走流程，prepare和commit阶段，但是不再重新执行请求，因为在上一个view内，对这些达到<code>prepared(m,v,n,i)</code>状态的消息已经执行过。<p></p>
<p>同时，replica记录收到的所有replica的view-change里最新的（<code>n</code>最大）stable checkpoint记录到log里，并且对缺失的消息m和最新的stable checkpoint（自身的stable checkpoint不是全局最新的stable checkpoint情况下）从其他的replica同步。</p>
<h4 id="5-Correctness（重点）"><a href="#5-Correctness（重点）" class="headerlink" title="5. Correctness（重点）"></a>5. Correctness（重点）</h4><ol>
<li>Safety<blockquote>
<p>if prepared(m,v,n,i) is true then prepared(m’,v,n,j) is false for any  non-faulty replica j(including i=j) and any m’ such that D(m’)!=D(m)  </p>
</blockquote>
</li>
</ol>
<ul>
<li><p>这是因为，到达prepare（m）意味着2f+1个replica选择发送prepare（m），假设异常节点个数为k(k&lt;=f), 则至少有2f+1-k个正常replica发送prepare（m），同时也意味着至少有2f+1-k个replica发送prepare（m’）。由于(2f+1-k)*2&gt;3f+1-k，说明这两部分正常节点有重叠，则至少有一个正常节点发送两个不同消息，矛盾。</p>
<blockquote>
<p>The view-change protocol ensures that non-faulty replicas also agree on the sequence number of requests that commit locally in different views at different replicas. committed(m,v,n) is true if and only if prepared(m,v,n,i) is true for all i in some set of f+1 non-faulty replicas. if committed-local(m,v,n,i) is true for some non-faulty i then committed(m,v,n) is true.</p>
</blockquote>
</li>
<li><p>这是因为，到达<code>committed-local(m,v,n,i)</code>状态，则意味着至少收到f+1个正常replica的commit消息，也就是至少有f+1个正常节点到达prepared（m,v,n,i)状态。而正常节点只有在接收到new-view消息才会从view v进入view v+1，而new-view消息里包含2f+1个view-change消息。与上面推导方式相似，则这两个集合必定有一个交集包含正常节点k。若然m已经包含在k的stable checkpont内，则最终被同步到所有正常节点；若然没有，则包含k的view-change消息内，然后在view v+1中被重新执行三阶段流程，最终也达到提交一致。</p>
</li>
</ul>
<ol>
<li>Liveness</li>
</ol>
<ul>
<li>replica广播view-change进入v+1，等待2f+1个view-change消息后启动计时器T。如果在T到时前没有收到new-view（新的primary是异常节点），则进入v+2，计时器时间扩大成2T，这是为了避免view改变的过快。</li>
<li>在定时器过期前，如果收到f+1个view-change消息，并且比自身的view number大，则发送这些大view number中最小的一个</li>
<li>f+1个view-change消息才能触发view变更，而且primary的轮流选择方案也限定连续最多f轮选择就能选举到正常的primary。</li>
</ul>
<h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><h4 id="1-Reducing-Communication"><a href="#1-Reducing-Communication" class="headerlink" title="1. Reducing Communication"></a>1. Reducing Communication</h4><ol>
<li><p>避免传输large result</p>
<blockquote>
<p>A client request designates a replica to send the result; all other replicas send replies containing just the digest of the result.(指定单个replca回复完整result，其他回复该result的摘要用以校验)。 If the client does not receive a correct result from the designated replica, it retransmits the request as usual, requesting all replicas to send full replies.</p>
</blockquote>
</li>
<li><p>减少流程步骤，replica提前返回reply。当replica收到足够prepare消息，达到了<code>prepared(m,v,n,i)</code> 状态，将要进入commit阶段。这时，如果小于该消息序号<code>n</code>的之前的消息都已经执行生成了当前状态，则replica执行该请求，并且直接返回到client，同时继续后续的commit阶段。</p>
<blockquote>
<ul>
<li>The client waits for 2f + 1 matching tentative replies. If it receives this many, the request is guaranteed to commit eventually. Otherwise, the client retransmits the request and waits for f + 1 non-tentative replies.   </li>
<li>A request that has executed tentatively may abort if there is a view change and it is replaced by a null request. In this case the replica reverts its state to the last stable checkpoint in the new-view message or to its last checkpointed state (depending on which one has the higher sequence number). </li>
</ul>
</blockquote>
</li>
<li><p>优化read-only操作。对于read-only请求，client直接发送到所有replica，replica直接返回结果到client。client收集2f+1个相同结果的回复，否则按照正常流程重新发起请求。</p>
<blockquote>
<p>They(replica) send the reply only after all requests reflected in the tentative state have committed; this is necessary to prevent the client from observing uncommitted state.</p>
</blockquote>
</li>
</ol>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>所有的replica间需要全联接并且多次交互通信，系统中这些消息随着节点数指数增长。单次请求的最少消息数为<code>1 + 3f + 3f(3f-f) + (3f-f+1)(3f+1) + 3f-1</code>.</p>
<blockquote>
<p><a href="https://medium.com/coinmonks/pbft-understanding-the-algorithm-b7a7869650ae">pBFT— Understanding the Consensus Algorithm</a></p>
</blockquote>
<h3 id="私货"><a href="#私货" class="headerlink" title="私货"></a>私货</h3><ol>
<li>为什么需要至少3f+1个节点？<br>首先最后达成共识的正常节点数需要大于f，否则这f个异常节点就可以达成错误的共识。即至少需要f+1个正常节点达成共识。而达成共识时，有可能给最后共识投票的包含这f个异常节点，所以需要至少2f+1个节点投票达成共识，这样可以保证其中至少含有f+1个正常节点。（例如P为异常节点向不同的正常节点提议不同的值，这也是造成上文提到3f+1个节点最后达成共识时只能保证多于f+1个）。而最后的共识只能有一个，即达成共识的正常节点应该超过所有正常节点数的过半，否则f个异常节点可以重复投票导致最后正常节点分裂成两组以上各自达成共识。因此，实际上最后的阈值<code>T&gt;=lower((R-f)/2)+1+f</code>，这样就保证了correctness正确性。接下来考虑liveness可用性。因为异常节点有可能不参与投票（P为正常节点），需要保证正常节点总数应该大于阈值，即<code>R-f&gt;=T</code>。</li>
</ol>
<p><strong>References</strong></p>
<blockquote>
<p>[1] M. Castro and B. Liskov.   <a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">Practical Byzantine Fault Tolerance</a>.  <em>Proceedings of the Third Symposium on Operating Systems Design and Implementation, New Orleans, USA, February 1999</em></p>
<p>[2] <a href="https://zhuanlan.zhihu.com/p/40684348">区块链PBFT共识算法节点主动恢复设计与实现</a><br>[3] <a href="https://www.8btc.com/article/70370">拜占庭将军问题深入探讨</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Consensus &amp; Cryptography</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Consensus</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - peer的deliver过程(1) peer与orderer的交互</title>
    <url>//articles/fabric-source-deliver-peer-to-order/</url>
    <content><![CDATA[<p>peer端的gossip和deliver是紧密结合的。在fabric的结构中，存在leader peer节点，负责与orderer交互，通过deliver服务从orderer得到block。然后通过gossip服务扩散到其他的普通peer，从而达到全网同步。这里先介绍deliver服务。</p>
<p>从前文<a href="https://simplexity.cn/2019/03/12/fabric-source-orderer-deliver/">orderer的deliver过程</a>可知，deliver的grpc服务是”/orderer.AtomicBroadcast/Deliver”,在源码中搜索并且一路回溯到方法<code>peer/node/start.go#serve</code>，这个方法是执行命令<code>peer node start</code>时的执行。（这里先介绍的当前peer重启的情况，新建立channel的情况后面介绍）。然后执行到<code>core/peer/peer.go:Initialize</code>，这里面执行<code>ledgermgmt.Initialize(ConfigTxProcessors)</code>恢复历史账本。然后从这些历史账本信息可以获取到ledgerId（即channelId）。然后对每个channel加载账本，并且从账本中获取最新的ConfigBlock，然后调用<code>createChain</code>重新构造channel信息。在<code>core/peer/peer.go:createChain</code>这个方法里，也是从ledger里获取到配置信息，从而得到orderer地址<code>ordererAddresses :=  bundle.ChannelConfig().OrdererAddresses()</code>,然后调用<code>service.GetGossipService().InitializeChannel</code>。在<code>gossip/service/gossip_service.go:InitializeChannel</code>里，启动deliver服务需要经过判断是否节点是leader peer，即<code>peer.gossip.useLeaderElection</code>（通过选举的方式动态决定leader peer）和<code>peer.gossip.orgLeader</code>（静态指定当前peer为leader peer），这两种方式是互斥的。前面提到过，只有leader才与orderer进行交互，如果不是，则返回，无需继续往下启动deliver服务。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Parameters:</span></span><br><span class="line"><span class="comment">//      - peer.gossip.useLeaderElection</span></span><br><span class="line"><span class="comment">//      - peer.gossip.orgLeader</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// are mutual exclusive, setting both to true is not defined, hence peer will panic and terminate</span></span><br><span class="line">leaderElection := viper.GetBool(<span class="string">"peer.gossip.useLeaderElection"</span>)</span><br><span class="line">isStaticOrgLeader := viper.GetBool(<span class="string">"peer.gossip.orgLeader"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> leaderElection &amp;&amp; isStaticOrgLeader {</span><br><span class="line">    logger.Panic(<span class="string">"Setting both orgLeader and useLeaderElection to true isn't supported, aborting execution"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> leaderElection {</span><br><span class="line">    logger.Debug(<span class="string">"Delivery uses dynamic leader election mechanism, channel"</span>, chainID)</span><br><span class="line">    g.leaderElection[chainID] = g.newLeaderElectionComponent(chainID, g.onStatusChangeFactory(chainID, support.Committer))</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> isStaticOrgLeader {</span><br><span class="line">    logger.Debug(<span class="string">"This peer is configured to connect to ordering service for blocks delivery, channel"</span>, chainID)</span><br><span class="line">    g.deliveryService[chainID].StartDeliverForChannel(chainID, support.Committer, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {})</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    logger.Debug(<span class="string">"This peer is not configured to connect to ordering service for blocks delivery, channel"</span>, chainID)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<span id="more"></span>
<p>假设当前节点是通过静态指定为leader，则进入创建deliver服务<code>g.deliveryService[chainID].StartDeliverForChannel</code>.在这个方法里主要分两部。</p>
<ol>
<li><p>调用<code>client := d.newClient(chainID, ledgerInfo)</code>构造client。</p>
 <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *deliverServiceImpl)</span> <span class="title">newClient</span><span class="params">(chainID <span class="keyword">string</span>, ledgerInfoProvider blocksprovider.LedgerInfo)</span> *<span class="title">broadcastClient</span></span> {</span><br><span class="line">    requester := &amp;blocksRequester{</span><br><span class="line">        tls:     viper.GetBool(<span class="string">"peer.tls.enabled"</span>),</span><br><span class="line">        chainID: chainID,</span><br><span class="line">    }</span><br><span class="line">    broadcastSetup := <span class="function"><span class="keyword">func</span><span class="params">(bd blocksprovider.BlocksDeliverer)</span> <span class="title">error</span></span> {</span><br><span class="line">        <span class="keyword">return</span> requester.RequestBlocks(ledgerInfoProvider)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    connProd := comm.NewConnectionProducer(d.conf.ConnFactory(chainID), d.conf.Endpoints)</span><br><span class="line">    bClient := NewBroadcastClient(connProd, d.conf.ABCFactory, broadcastSetup, backoffPolicy)</span><br><span class="line">    requester.client = bClient</span><br><span class="line">    <span class="keyword">return</span> bClient</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBroadcastClient</span><span class="params">(prod comm.ConnectionProducer, clFactory clientFactory, onConnect broadcastSetup, bos retryPolicy)</span> *<span class="title">broadcastClient</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;broadcastClient{prod: prod, onConnect: onConnect, shouldRetry: bos, createClient: clFactory, stopChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">1</span>)}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>构建<code>blocksProviderImpl</code>，并与channel对应存储<code>d.blockProviders[chainID] = blocksprovider.NewBlocksProvider</code>.然后调用<code>go d.launchBlockProvider(chainID, finalizer)</code>,进而调用了<code>core/deliverservice/blocksprovider/blocksprovider.go#DeliverBlocks</code>。在这里调用<code>core/deliverservice/client.go#Recv</code>方法，一路调用直到调用<code>client.go#connect</code>。</p>
 <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *broadcastClient)</span> <span class="title">doAction</span><span class="params">(action <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>{}, error)</span>, <span class="title">actionOnNewConnection</span> <span class="title">func</span><span class="params">()</span>) <span class="params">(<span class="keyword">interface</span>{}, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> bc.conn == <span class="literal">nil</span> {</span><br><span class="line">        err := bc.connect()</span><br><span class="line">        actionOnNewConnection()</span><br><span class="line">    }</span><br><span class="line">    resp, err := action()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        bc.Disconnect(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *broadcastClient)</span> <span class="title">connect</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    abc, err := bc.createClient(conn).Deliver(ctx)</span><br><span class="line">    err = bc.afterConnect(conn, abc, cf, endpoint)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *broadcastClient)</span> <span class="title">afterConnect</span><span class="params">(conn *grpc.ClientConn, abc orderer.AtomicBroadcast_DeliverClient, cf context.CancelFunc, endpoint <span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    bc.BlocksDeliverer = abc</span><br><span class="line">    err := bc.onConnect(bc)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<ul>
<li><p>这里先构建grpc client <code>abc, err := bc.createClient(conn).Deliver(ctx)</code>.这里的<code>createClient</code>即上面构造<code>broadcastClient</code>时传入的参数<code>d.conf.ABCFactory</code>。这个参数可以回溯到<code>gossip/service/gossip_service.go#Service</code>构造时（这个方法在前面提及的<code>InitializeChannel</code>里被调用），指定<code>ABCFactory:  deliverclient.DefaultABCFactory</code>。可见，这里对应的grpc方法即<code>/orderer.AtomicBroadcast/Deliver</code>.</p>
  <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DefaultABCFactory</span><span class="params">(conn *grpc.ClientConn)</span> <span class="title">orderer</span>.<span class="title">AtomicBroadcastClient</span></span> {</span><br><span class="line">    <span class="keyword">return</span> orderer.NewAtomicBroadcastClient(conn)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAtomicBroadcastClient</span><span class="params">(cc *grpc.ClientConn)</span> <span class="title">AtomicBroadcastClient</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;atomicBroadcastClient{cc}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *atomicBroadcastClient)</span> <span class="title">Deliver</span><span class="params">(ctx context.Context, opts ...grpc.CallOption)</span> <span class="params">(AtomicBroadcast_DeliverClient, error)</span></span> {</span><br><span class="line">    stream, err := grpc.NewClientStream(ctx, &amp;_AtomicBroadcast_serviceDesc.Streams[<span class="number">1</span>], c.cc, <span class="string">"/orderer.AtomicBroadcast/Deliver"</span>, opts...)</span><br><span class="line"></span><br><span class="line">    x := &amp;atomicBroadcastDeliverClient{stream}</span><br><span class="line">    <span class="keyword">return</span> x, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>然后在<code>connect</code>方法里设置<code>bc.BlocksDeliverer = abc</code>,并且调用<code>err = bc.afterConnect(conn, abc, cf, endpoint)</code>，进而调用了<code>err := bc.onConnect(bc)</code>.在上面的<code>broadcastClient</code>构造时传入参数<code>onConnect</code>为<code>broadcastSetup</code>,即执行<code>requester.RequestBlocks(ledgerInfoProvider)</code>。这里实际上是向orderer请求block，header为<code>common.HeaderType_DELIVER_SEEK_INFO</code>,同时分为两种情况，新的channel从oldest开始消费同步，而重启的channel则从指定的block开始（<code>ledgerInfoProvider.LedgerHeight()</code>）。以上为<code>start</code>值，<code>stop</code>选择math.MaxUint64,<code>Behavior</code>选择<code>orderer.SeekInfo_BLOCK_UNTIL_READY</code>.回顾前文，这里表明是一直同步。这里发出的Envelope也就是orderer接收。</p>
  <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *blocksRequester)</span> <span class="title">RequestBlocks</span><span class="params">(ledgerInfoProvider blocksprovider.LedgerInfo)</span> <span class="title">error</span></span> {</span><br><span class="line">    height, err := ledgerInfoProvider.LedgerHeight()</span><br><span class="line">    <span class="keyword">if</span> height &gt; <span class="number">0</span> {</span><br><span class="line">        <span class="keyword">if</span> err := b.seekLatestFromCommitter(height); err != <span class="literal">nil</span>{ <span class="keyword">return</span> err }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> err := b.seekOldest(); err != <span class="literal">nil</span> { <span class="keyword">return</span> err}</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *blocksRequester)</span> <span class="title">seekOldest</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">    seekInfo := &amp;orderer.SeekInfo{</span><br><span class="line">        Start:    &amp;orderer.SeekPosition{Type: &amp;orderer.SeekPosition_Oldest{Oldest: &amp;orderer.SeekOldest{}}},</span><br><span class="line">        Stop:     &amp;orderer.SeekPosition{Type: &amp;orderer.SeekPosition_Specified{Specified: &amp;orderer.SeekSpecified{Number: math.MaxUint64}}},</span><br><span class="line">        Behavior: orderer.SeekInfo_BLOCK_UNTIL_READY,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO- epoch and msgVersion may need to be obtained for nowfollowing usage in orderer/configupdate/configupdate.go</span></span><br><span class="line">    msgVersion := <span class="keyword">int32</span>(<span class="number">0</span>)</span><br><span class="line">    epoch := <span class="keyword">uint64</span>(<span class="number">0</span>)</span><br><span class="line">    tlsCertHash := b.getTLSCertHash()</span><br><span class="line">    env, err := utils.CreateSignedEnvelopeWithTLSBinding(common.HeaderType_DELIVER_SEEK_INFO, b.chainID, localmsp.NewSigner(), seekInfo, msgVersion, epoch, tlsCertHash)</span><br><span class="line">    <span class="keyword">return</span> b.client.Send(env)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *blocksRequester)</span> <span class="title">seekLatestFromCommitter</span><span class="params">(height <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    seekInfo := &amp;orderer.SeekInfo{</span><br><span class="line">        Start:    &amp;orderer.SeekPosition{Type: &amp;orderer.SeekPosition_Specified{Specified: &amp;orderer.SeekSpecified{Number: height}}},</span><br><span class="line">        Stop:     &amp;orderer.SeekPosition{Type: &amp;orderer.SeekPosition_Specified{Specified: &amp;orderer.SeekSpecified{Number: math.MaxUint64}}},</span><br><span class="line">        Behavior: orderer.SeekInfo_BLOCK_UNTIL_READY,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ol>
<li>接下来转向消息的接收。真正处理<code>DeliverResponse</code>的地方在<code>blocksprovider.go#DeliverBlocks</code>，这里for循环判断<code>!b.isDone()</code>则使用<code>msg, err := b.client.Recv()</code>接收信息。<code>core/deliverservice/client.go#Recv</code>这个方法里，使用<code>try</code>方法，实际上就是重试机制，当失败时，并且没有达到重试阈值时（前文构造client时传入的参数<code>backoffPolicy</code>）则重新执行，这里包括先判断connection是否为nil，如果是则调用前面分析过的<code>connect</code>方法，然后调用<code>action</code>，也就是<code>b.client.Recv()</code>传入的方法参数，实际上是执行<code>bc.BlocksDeliverer.Recv()</code>。这里注意，在前面分析的<code>afterConnect</code>方法里，已经设置<code>bc.BlocksDeliverer=abc</code>(即<code>orderer.AtomicBroadcast_DeliverClient</code>)，所以这里就是从orderer的deliver grpc stream里读取，然后逐级返回到<code>blocksprovider.go#DeliverBlocks</code>。处理接收到的block这部分与gossip相关，留待后续再一起分析。</li>
</ol>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - orderer的deliver过程</title>
    <url>//articles/fabric-source-orderer-deliver/</url>
    <content><![CDATA[<p>在orderer端，deliver和broadcast是对等的，最初回溯到<code>protos/orderer/ab.pb.go</code>里的grpc定义，对应的grpc方法是<code>/orderer.AtomicBroadcast/Deliver</code>。对应源码<code>orderer/common/server/server.go#Deliver</code> -&gt; <code>common/deliver/deliver.go#Handle</code> -&gt; <code>deliver.go#deliverBlocks</code>。在<code>deliverBlocks</code>这个方法里，先反序列化cb.Envelope，获取并且校验Header，然后校验access control，判断client的identity证书是否过期，以及策略校验是否拥有读权限（policies.ChannelReaders，代码为<code>orderer/common/server/server.go#Deliver : sf := msgprocessor.NewSigFilter(policies.ChannelReaders, chain)</code>）。校验通过后，将envelope反序列化为<code>ab.SeekInfo</code>结构。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// SeekInfo specifies the range of requested blocks to return</span></span><br><span class="line"><span class="comment">// If the start position is not found, an error is immediately returned</span></span><br><span class="line"><span class="comment">// Otherwise, blocks are returned until a missing block is encountered, then behavior is dictated by the SeekBehavior specified.  </span></span><br><span class="line"><span class="comment">// If BLOCK_UNTIL_READY is specified, the reply will block until the requested blocks are available</span></span><br><span class="line"><span class="comment">// if FAIL_IF_NOT_READY is specified, the reply will return an error indicating that the block is not found.  </span></span><br><span class="line"><span class="comment">// To request that all blocks be returned indefinitely as they are created, behavior should be set to BLOCK_UNTIL_READY and the stop should be set to specified with a number of MAX_UINT64</span></span><br><span class="line"><span class="keyword">type</span> SeekInfo <span class="keyword">struct</span> {</span><br><span class="line">    Start    *SeekPosition </span><br><span class="line">    Stop     *SeekPosition </span><br><span class="line">    Behavior SeekInfo_SeekBehavior </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">deliverBlocks</span><span class="params">(ctx context.Context, srv *Server, envelope *cb.Envelope)</span> <span class="title">error</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 校验，略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据seekInfo.Stop计算range的终止block number</span></span><br><span class="line">    cursor, number := chain.Reader().Iterator(seekInfo.Start)</span><br><span class="line">    <span class="keyword">defer</span> cursor.Close()</span><br><span class="line">    <span class="keyword">switch</span> stop := seekInfo.Stop.Type.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Oldest:</span><br><span class="line">        stopNum = number</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Newest:</span><br><span class="line">        stopNum = chain.Reader().Height() - <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Specified:</span><br><span class="line">        stopNum = stop.Specified.Number</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        <span class="comment">// 如果range超越当前到chain高度，fail fast</span></span><br><span class="line">        <span class="keyword">if</span> seekInfo.Behavior == ab.SeekInfo_FAIL_IF_NOT_READY {</span><br><span class="line">            <span class="keyword">if</span> number &gt; chain.Reader().Height()<span class="number">-1</span> {</span><br><span class="line">                <span class="keyword">return</span> srv.SendStatusResponse(cb.Status_NOT_FOUND)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        iterCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            <span class="comment">// 读取下一个block</span></span><br><span class="line">            block, status = cursor.Next()</span><br><span class="line">            <span class="built_in">close</span>(iterCh)</span><br><span class="line">        }()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// "context finished before block retrieved"</span></span><br><span class="line">            <span class="keyword">return</span> errors.Wrapf(ctx.Err(), <span class="string">"context finished before block retrieved"</span>)</span><br><span class="line">        <span class="keyword">case</span> &lt;-erroredChan: <span class="comment">// "Aborting deliver for request because of background error"</span></span><br><span class="line">            <span class="keyword">return</span> srv.SendStatusResponse(cb.Status_SERVICE_UNAVAILABLE)</span><br><span class="line">        <span class="keyword">case</span> &lt;-iterCh:</span><br><span class="line">            <span class="comment">// Iterator has set the block and status vars，完成读取</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// increment block number to support FAIL_IF_NOT_READY deliver behavior</span></span><br><span class="line">        number++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次通过权限校验 access control</span></span><br><span class="line">        <span class="keyword">if</span> err := accessControl.Evaluate(); err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> srv.SendStatusResponse(cb.Status_FORBIDDEN)</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个block发送</span></span><br><span class="line">        <span class="keyword">if</span> err := srv.SendBlockResponse(block); err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> stopNum == block.Header.Number {</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部block发送完成后，再回复当前deliver rpc请求</span></span><br><span class="line">    <span class="keyword">if</span> err := srv.SendStatusResponse(cb.Status_SUCCESS); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<span id="more"></span>
<p>在配置文件<code>orderer.yaml</code>里指定了<code>General.LedgerType: file</code>(可选有file，json，ram三种模式)，这里以file为例分析orderer的本地账本，实现在<code>common/ledger/blockledger/file/impl.go</code>。<code>file/imple.go#Next</code>方法里调用的<code>i.commonIterator.Next()</code>，如注释里所述，将会block直到可以获取到下一个block，因此只要client的请求里seekInfo.stop为最大值MAX_UINT64，SeekInfo_SeekBehavior选择BLOCK_UNTIL_READY，则新产生的block会源源不断的发送到client。(使用标准包的sync.cond)，<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fl *FileLedger)</span> <span class="title">Iterator</span><span class="params">(startPosition *ab.SeekPosition)</span> <span class="params">(blockledger.Iterator, <span class="keyword">uint64</span>)</span></span> {</span><br><span class="line">    <span class="keyword">var</span> startingBlockNumber <span class="keyword">uint64</span></span><br><span class="line">    <span class="keyword">switch</span> start := startPosition.Type.(<span class="keyword">type</span>) {</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Oldest:</span><br><span class="line">        <span class="comment">// 结合deliverBlocks里的stopNum，得知SeekPosition_Oldest返回最早的一个block，start=stop=0</span></span><br><span class="line">        startingBlockNumber = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Newest:</span><br><span class="line">        <span class="comment">// 结合deliverBlocks里的stopNum，得知SeekPosition_Newest返回最新的一个block，start=stop=chain.height-1</span></span><br><span class="line">        info, err := fl.blockStore.GetBlockchainInfo()</span><br><span class="line">        newestBlockNumber := info.Height - <span class="number">1</span></span><br><span class="line">        startingBlockNumber = newestBlockNumber</span><br><span class="line">    <span class="keyword">case</span> *ab.SeekPosition_Specified:</span><br><span class="line">        startingBlockNumber = start.Specified.Number</span><br><span class="line">        height := fl.Height()</span><br><span class="line">        <span class="keyword">if</span> startingBlockNumber &gt; height {</span><br><span class="line">            <span class="keyword">return</span> &amp;blockledger.NotFoundErrorIterator{}, <span class="number">0</span></span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;blockledger.NotFoundErrorIterator{}, <span class="number">0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    iterator, err := fl.blockStore.RetrieveBlocks(startingBlockNumber)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;fileLedgerIterator{ledger: fl, blockNumber: startingBlockNumber, commonIterator: iterator}, startingBlockNumber</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next blocks until there is a new block available, or until Close is called.</span></span><br><span class="line"><span class="comment">// It returns an error if the next block is no longer retrievable.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *fileLedgerIterator)</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(*cb.Block, cb.Status)</span></span> {</span><br><span class="line">    <span class="comment">// 使用标准包sync.cond</span></span><br><span class="line">    result, err := i.commonIterator.Next()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        logger.Error(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, cb.Status_SERVICE_UNAVAILABLE</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Cover the case where another thread calls Close on the iterator.</span></span><br><span class="line">    <span class="keyword">if</span> result == <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, cb.Status_SERVICE_UNAVAILABLE</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result.(*cb.Block), cb.Status_SUCCESS</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>具体跟踪下这个等待对新block的机制，<br><code>impl.go#Next : result, err := i.commonIterator.Next()</code><br>-&gt;<code>fsblkstorage/blocks_itr.go#Next() : itr.waitForBlock(itr.blockNumToRetrieve)</code><br>-&gt;<code>fsblkstorage/blocks_itr.go#waitForBlock()</code>，这里执行了<code>itr.mgr.cpInfoCond.Wait()</code>，就是等待新block。  </p>
<p>而相应的在添加block时，以solo方式为例，<br><code>orderer/consensus/solo/consensus.go#main : ch.support.WriteBlock(block, nil)</code><br>-&gt;<code>orderer/common/multichannel/blockwriter.go#WriteBlock : bw.commitBlock(encodedMetadataValue)</code><br>-&gt;<code>blockwriter.go#commitBlock :  bw.support.Append(bw.lastBlock)</code><br>-&gt;<code>common/ledger/blockledger/file/impl.go#Append : fl.blockStore.AddBlock(block)</code><br>-&gt;<code>fsblkstorage/fs_blockstore.go#AddBlock</code><br>-&gt;<code>fsblkstorage/blockfile_mgr.go#addBlock : mgr.updateCheckpoint(newCPInfo)</code><br>-&gt;<code>/fsblkstorage/blockfile_mgr.go#updateCheckpoint</code>里，执行了<code>mgr.cpInfoCond.Broadcast()</code>，也就是当写入block后，通知到前面的wait，实现了产生每一个新block，立刻deliver该block的逻辑。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>A Kafka-based Ordering Service for Fabric （orderer的应用kafka设计思想）学习笔记</title>
    <url>//articles/fabric-orderer-kafka-design/</url>
    <content><![CDATA[<p><a href="https://docs.google.com/document/d/19JihmW-8blTzN99lAubOfseLUZqdrB6sBR0HsRgCAnY/edit">A Kafka-based Ordering Service for Fabric</a>这篇文章是orderer的kafka设计文档，详细介绍orderer应用kafka的设计思想演进过程，从基本点逐步深入，由问题到解决方案，值得阅读。这里列举学习过程中的笔记。</p>
<ul>
<li><em>Solution 0（S0）</em> ： 单个tx（transaction）构成block。  </li>
<li><em>Problem 1（P1）</em> ： 单个block的size很小，当网络有大量tx时会产生大量的block。而OSN（ordering service node）需要对block进行打包，签名，client需要解包，验证签名。overhead太大，效率太低。  </li>
<li><em>S1</em> ：多个tx打包成一个block。  </li>
<li><em>P2</em> : 但是需要缓存到指定数量的tx，如果网络tx太少，可能需要等很长时间才产生一个block，tx需要等待很久才得以确认。</li>
<li><em>S2</em> ： 增加时钟，如果指定时间内没有达到数量要求，时钟到时切分block。  </li>
<li><em>P3</em> ： 各个OSN时钟不同步，可能导致block间切分的位置差异。</li>
<li><em>S3</em> ： OSN加入TTC-X（Time to Cut block-X），时钟到时发送该message到kafka，各个OSN收到改消息后切分block。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><ul>
<li><em>P4</em> ： Deliver服务需要读取指定block。</li>
<li><em>S4a</em> ： block头部加上metadata，从block X-1可以知道block X的开始的kafka offset。OSN从该offset开始重读kafka，replay重新构建block。</li>
<li><em>P4a</em> ： 如果client缺少block X-1，就无法得知block X的开始offset。</li>
<li><em>S4b</em> ： OSN保存table，block number &lt;-&gt; offset number。</li>
<li><em>P5</em> ： 读取block X需要从kafka重读消息，重新打包，签名。</li>
<li><em>P6</em> ： 网络中存在重复的消息，例如re-order的消息</li>
<li><em>S5a</em> ： kafka partition 0 保存tx，partition 1保存打包后的block，简历partition 1的table，block number &lt;-&gt; offset number。如果需要读取blcok X，则查表，从partition 1读取相应offset的block。但是，需要每次查表，而且无法解决P6。partiton 1中的每个block会被每个OSN都发送一次，大量重复的block。</li>
<li><em>S6a</em> ：OSN发送前判断partition 1中是否有重复的block number，如果已存在则不在发送。但是所有的OSN之间无法做到严格同步，可能有多个block副本（来自不同的OSN的同一个block同时发送）处在in-flight状态，仍然没有解决重复的问题。</li>
<li><em>S6b</em> ： 选举OSN leader，只有leader才能发送到partition 1。但是，如果就leader发送block X后crash，选举的新leader重发block X，导致重复（旧leader发的block X处在in flight状态）。无法使得block number = offset number，仍然需要存表查表。</li>
<li><p><em>S6c</em> ： 使用kafka的log压缩特性，保留key相同（可以使用block number X作为key）只有一个offset，删除冗余的。但是，OSN要保留table，block number &lt;-&gt; offset number，并且log压缩后删除旧值，表里如果更新不及时会读取到旧offset（实际上已经被删除）。而且压缩后的block与offset间是乱序的。</p>
</li>
<li><p><strong><em>S5b,S6d</em></strong> : OSN把block存储本地账本。无需使用table，从tx构建账本链可以保证顺序性，而且deliver也可以复用orderer broadcast代码。</p>
<blockquote>
<p>The OSN will need to keep track of the last offset number it read though, just so that it knows where to seek to when consuming from Kafka upon reconnection.</p>
<p>A downside of serving Deliver requests from the local ledger could be that it would be slower than serving them straight from Kafka. But we never serve straight from Kafka; there’s always some processing happening on the OSNs. (其他的方案在OSN也会引入开销)</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>Overall an ordering service that uses a single partition (per chain) for incoming client transactions and TTC-X messages (as shown in Solution 3), and which stores the resulting blocks in a local ledger (again, per chain) strikes a nice balance between performance and complexity.</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - orderer的kafka实现</title>
    <url>//articles/fabric-source-orderer-kafka/</url>
    <content><![CDATA[<p>在instantiate（8）里提到，orderer总共有solo和kafka,etcdraft三种方式，并且介绍了单orderer节点的solo方式。这里继续补充介绍多orderer节点下采用的kafka方式。kafka实现的代码放在<code>orderer/consensus/kafka/chain.go</code>里，与solo一样实现了<code>orderer/common/broadcast/broadcast.go#Consenter</code>这个接口。在orderer的处理消息时<code>orderer/common/broadcast/broadcast.go#Handle</code>，调用了其<code>Order</code>方法。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">Order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="keyword">return</span> chain.order(env, configSeq, <span class="keyword">int64</span>(<span class="number">0</span>))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>, originalOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    marshaledEnv, err := utils.Marshal(env)</span><br><span class="line">    <span class="keyword">if</span> !chain.enqueue(newNormalMessage(marshaledEnv, configSeq, originalOffset)) {</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"cannot enqueue"</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// enqueue accepts a message and returns true on acceptance, or false otheriwse.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">enqueue</span><span class="params">(kafkaMsg *ab.KafkaMessage)</span> <span class="title">bool</span></span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-chain.startChan: <span class="comment">// The Start phase has completed</span></span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> &lt;-chain.haltChan: <span class="comment">// The chain has been halted, stop here</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// The post path</span></span><br><span class="line">            payload, err := utils.Marshal(kafkaMsg)</span><br><span class="line"></span><br><span class="line">            message := newProducerMessage(chain.channel, payload)</span><br><span class="line">            <span class="keyword">if</span> _, _, err = chain.producer.SendMessage(message); err != <span class="literal">nil</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// Not ready yet</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newProducerMessage</span><span class="params">(channel channel, pld []<span class="keyword">byte</span>)</span> *<span class="title">sarama</span>.<span class="title">ProducerMessage</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;sarama.ProducerMessage{</span><br><span class="line">        Topic: channel.topic(),</span><br><span class="line">        Key:   sarama.StringEncoder(strconv.Itoa(<span class="keyword">int</span>(channel.partition()))), </span><br><span class="line">        Value: sarama.ByteEncoder(pld),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>首先构建了消息实体<code>orderer/consensus/kafka/chain.go:KafkaMessage</code>，入参为传递的消息<code>cb.Envelope</code>，当前配置序列号<code>configSeq</code>，固定的<code>originalOffset</code>值为0(这个值的含义后面会提到，表示的是是否当前消息是重新发送重排，值为0则说明当前消息是新消息)。然后构建传递kafka消息<code>sarama.ProducerMessage</code>，这里kafka相关的使用第三方库<a href="https://github.com/Shopify/sarama">Shopify/sarama</a>。消息里指定了topic，由partition构建key，然后就是将刚才构建的消息作为payload。后面可以看到topic和partition都是channel的配置参数（初始化或者后面的更新）。这里可以看出，所有的kafka消息的key都是相同的，意味这所有消息都发送到同一个partition内，按照key的算法也就是<code>channel.partition()</code>。这里保证了单个orderer发出的envelop的有序性，但同时从全局来说，只使用一个partition，并没有充分利用kafka多partition的带来的高性能。然后使用<code>sarama.SyncProducer</code>发送消息<code>chain.producer.SendMessage</code>。</p>
<span id="more"></span>
<p>接下来分析<code>sarama.SyncProducer</code>的初始化，以及相应的kafka consumer消费过程。kafka的初始化方法是<code>orderer/consensus/kafka/chain.go#startThread</code>。从这个一直回溯到<code>chainsupport.go#start</code>，总共有两个地方调用。一是<code>registar.go#NewRegistrar</code>，这里从ledgerFactory里的记录找出existingChains重建；二是<code>registar.go#newChain</code>,接收到消息的payload.Header.ChannelHeader.Type为<code>cb.HeaderType_ORDERER_TRANSACTION</code>时新建。这里以新建chain（channel）为例。<code>newChain</code>方法里调用了<code>newChainSupport</code>,里面初始化chainsupport的Chain参数<code>cs.Chain, err = consenter.HandleChain(cs, metadata)</code>。这里的consenter是<code>consensus.go#Consenter</code>接口,这里的实现类是<code>orderer/consensus/kafka/consenter.go:consenterImpl</code>.<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newChainSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	registrar *Registrar,</span></span></span><br><span class="line"><span class="params"><span class="function">	ledgerResources *ledgerResources,</span></span></span><br><span class="line"><span class="params"><span class="function">	consenters <span class="keyword">map</span>[<span class="keyword">string</span>]consensus.Consenter,</span></span></span><br><span class="line"><span class="params"><span class="function">	signer crypto.LocalSigner,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> *<span class="title">ChainSupport</span></span> {</span><br><span class="line">    <span class="comment">// Read in the last block and metadata for the channel</span></span><br><span class="line">    lastBlock := blockledger.GetBlock(ledgerResources, ledgerResources.Height()<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    metadata, err := utils.GetMetadataFromBlock(lastBlock, cb.BlockMetadataIndex_ORDERER)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct limited support needed as a parameter for additional support</span></span><br><span class="line">    cs := &amp;ChainSupport{</span><br><span class="line">        ledgerResources: ledgerResources,</span><br><span class="line">        LocalSigner:     signer,</span><br><span class="line">        cutter:          blockcutter.NewReceiverImpl(ledgerResources),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the msgprocessor</span></span><br><span class="line">    cs.Processor = msgprocessor.NewStandardChannel(cs, msgprocessor.CreateStandardChannelFilters(cs))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the block writer</span></span><br><span class="line">    cs.BlockWriter = newBlockWriter(lastBlock, registrar, cs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the consenter</span></span><br><span class="line">    cs.Chain, err = consenter.HandleChain(cs, metadata)</span><br><span class="line">    <span class="keyword">return</span> cs</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleChain creates/returns a reference to a consensus.Chain object for the given set of support resources. Implements the consensus.Consenter interface. </span></span><br><span class="line"><span class="comment">// Called by consensus.newChainSupport(), which is itself called by multichannel.NewManagerImpl() when ranging over the ledgerFactory's existingChains.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(consenter *consenterImpl)</span> <span class="title">HandleChain</span><span class="params">(support consensus.ConsenterSupport, metadata *cb.Metadata)</span> <span class="params">(consensus.Chain, error)</span></span> {</span><br><span class="line">    lastOffsetPersisted, lastOriginalOffsetProcessed, lastResubmittedConfigOffset := getOffsets(metadata.Value, support.ChainID())</span><br><span class="line">    <span class="keyword">return</span> newChain(consenter, support, lastOffsetPersisted, lastOriginalOffsetProcessed, lastResubmittedConfigOffset)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getOffsets</span><span class="params">(metadataValue []<span class="keyword">byte</span>, chainID <span class="keyword">string</span>)</span> <span class="params">(persisted <span class="keyword">int64</span>, processed <span class="keyword">int64</span>, resubmitted <span class="keyword">int64</span>)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> metadataValue != <span class="literal">nil</span> {</span><br><span class="line">        <span class="comment">// Extract orderer-related metadata from the tip of the ledger first</span></span><br><span class="line">        kafkaMetadata := &amp;ab.KafkaMetadata{}</span><br><span class="line">        proto.Unmarshal(metadataValue, kafkaMetadata);</span><br><span class="line">        <span class="keyword">return</span> kafkaMetadata.LastOffsetPersisted,</span><br><span class="line">            kafkaMetadata.LastOriginalOffsetProcessed,</span><br><span class="line">            kafkaMetadata.LastResubmittedConfigOffset</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sarama.OffsetOldest - <span class="number">1</span>, <span class="keyword">int64</span>(<span class="number">0</span>), <span class="keyword">int64</span>(<span class="number">0</span>) <span class="comment">// default</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol>
<li>从上一个区块<code>blockledger.GetBlock(ledgerResources, ledgerResources.Height()-1)</code>获取元数据，也就是<code>BlockMetadata.Metadata</code>内key为<code>cb.BlockMetadataIndex_SIGNATURES</code>的值，在instantiate（8）里提及其他三种。从<code>getOffsets</code>里看到，如果说当前channel已经存在也消费过数据，例如重启回复的情况下，则使用的是metadata里记录的值。如果是新建channel，则使用了默认<code>LastOffsetPersisted</code>,<code>LastOriginalOffsetProcessed</code>,<code>LastResubmittedConfigOffset</code>这三个值分别取<code>sarama.OffsetOldest - 1</code>,0,0。具体参数的含义后面分析。</li>
<li>接着调用<code>chain.go#newChain</code>，里面主要是构建了<code>orderer/consensus/kafka/chain.go:chainImpl</code>这个实体。其中需要关注的是<code>chainImpl.channel</code>这个参数初始化为<code>newChannel(support.ChainID(), defaultPartition)</code>.即kafka的topic为<code>support.ChainID()</code>（即channel名），partition为固定值0，这也就是前面提到的channel的topic和partition。<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// channel.go</span></span><br><span class="line"><span class="keyword">const</span> defaultPartition = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a new channel for a given topic name and partition number.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newChannel</span><span class="params">(topic <span class="keyword">string</span>, partition <span class="keyword">int32</span>)</span> <span class="title">channel</span></span> {</span><br><span class="line">    <span class="keyword">return</span> &amp;channelImpl{</span><br><span class="line">        tpc: fmt.Sprintf(<span class="string">"%s"</span>, topic),</span><br><span class="line">        prt: partition,</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<hr>
<p>下面再具体分析<code>chain.go#startThread</code><br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Called by Start().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startThread</span><span class="params">(chain *chainImpl)</span></span> {</span><br><span class="line">    <span class="comment">// Set up the producer</span></span><br><span class="line">    chain.producer, err = setupProducerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Have the producer post the CONNECT message</span></span><br><span class="line">    <span class="keyword">if</span> err = sendConnectMessage(chain.consenter.retryOptions(), chain.haltChan, chain.producer, chain.channel); err != <span class="literal">nil</span> {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the parent consumer</span></span><br><span class="line">    chain.parentConsumer, err = setupParentConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.SharedConfig().KafkaBrokers(), chain.consenter.brokerConfig(), chain.channel)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the channel consumer</span></span><br><span class="line">    chain.channelConsumer, err = setupChannelConsumerForChannel(chain.consenter.retryOptions(), chain.haltChan, chain.parentConsumer, chain.channel, chain.lastOffsetPersisted+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    chain.doneProcessingMessagesToBlocks = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{})</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(chain.startChan)                <span class="comment">// Broadcast requests will now go through</span></span><br><span class="line">    chain.errorChan = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}) <span class="comment">// Deliver requests will also go through</span></span><br><span class="line"></span><br><span class="line">    chain.processMessagesToBlocks() <span class="comment">// Keep up to date with the channel</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol>
<li><code>setupProducerForChannel</code>尝试用配置好的参数创建kafka的producer(<code>sarama.SyncProducer</code>)，并且加上了失败重试机制。配置在<code>orderer.yaml</code>文件里。</li>
<li><code>sendConnectMessage</code>使用刚创建的kafka producer发送<code>ab.KafkaMessage_Connect</code>消息，payload为nil，只是为了保证配置正确能正常返送。（<em>Post a CONNECT message to the channel using the given retry options. This prevents the panicking that would occur if we were to set up a consumer and seek on a partition that hadn’t been written to yet.</em> ）这里也加上失败重连机制。</li>
<li><code>setupParentConsumerForChannel</code>和<code>setupChannelConsumerForChannel</code>构造<code>sarama.PartitionConsumer</code>,只消费指定partition的数据，这里消费的就是初始化时设置的channle.Partition(),实际上是<code>const defaultPartition = 0</code>。失败重试。</li>
<li><code>processMessagesToBlocks</code>真正的<code>sarama.PartitionConsumer</code>消费数据，处理数据。这个方法里有比较多的<code>select-case</code>，首先是处理<code>case kafkaErr := &lt;-chain.channelConsumer.Errors():</code>，这里错误分两种，一种是<code>sarama.ErrOffsetOutOfRange:</code>,这类错误无法通过自动重试回复，则重新发送连接消息推进offset,<code>go sendConnectMessage(chain.consenter.retryOptions(), chain.haltChan, chain.producer, chain.channel)</code>；另一种错误则是可以通过自带的重试机制回复，这里有两个变量和case分支。1)<code>case &lt;-topicPartitionSubscriptionResumed:</code>错误时添加监听器，成功重连后打印日志；2）<code>case &lt;-deliverSessionTimedOut:</code>重连超时，则再次发送连接消息<code>go sendConnectMessage(...)</code>。这个<code>select-case</code>里交织着处理这两个变量分支的代码。</li>
</ol>
<hr>
<p> 接下来是重要的两个case。第一个<code>case &lt;-chain.timer:</code>这里是在当前channel设置的timer到期后，发送<code>&amp;ab.KafkaMessage_TimeToCut</code>消息到kafka通知所有orderer，这里的参数为下一个block的number（<code>chain.lastCutBlockNumber+1</code>）。第二个<code>case in, ok := &lt;-chain.channelConsumer.Messages():</code>里kafka收到的消息类型总共有三种。</p>
  <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> {</span><br><span class="line">   <span class="keyword">select</span> {</span><br><span class="line">   <span class="keyword">case</span> in, ok := &lt;-chain.channelConsumer.Messages():</span><br><span class="line">       <span class="keyword">switch</span> msg.Type.(<span class="keyword">type</span>) {</span><br><span class="line">       <span class="keyword">case</span> *ab.KafkaMessage_Connect:</span><br><span class="line">           _ = chain.processConnect(chain.ChainID())</span><br><span class="line">       <span class="keyword">case</span> *ab.KafkaMessage_TimeToCut:</span><br><span class="line">           <span class="keyword">if</span> err := chain.processTimeToCut(msg.GetTimeToCut(), in.Offset); err != <span class="literal">nil</span> {...}</span><br><span class="line">       <span class="keyword">case</span> *ab.KafkaMessage_Regular:</span><br><span class="line">           <span class="keyword">if</span> err := chain.processRegular(msg.GetRegular(), in.Offset); err != <span class="literal">nil</span> {...}</span><br><span class="line">       }</span><br><span class="line">   <span class="keyword">case</span> &lt;-chain.timer:</span><br><span class="line">       <span class="keyword">if</span> err := sendTimeToCut(chain.producer, chain.channel, chain.lastCutBlockNumber+<span class="number">1</span>, &amp;chain.timer); err != <span class="literal">nil</span> {...}</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><code>case *ab.KafkaMessage_Connect:</code>前面提到的在<code>startThread</code>启动时发送连接消息和遇到错误时尝试重联都回发送此类消息以推进offset。这里对这类消息不需要处理，仅仅作为记录。</li>
<li><p><code>case *ab.KafkaMessage_TimeToCut:</code>判断消息里要求cut的blocknum是否是当前节点本地block数据的下一个block，如果是的话，直接将当前汇集的batch切割，剩下的跟instantiate（8）里solo的流程一致，写入block。这里有所区别的是这里要提交kafka的metadata到block里，而这部分metadata写入了<code>bw.lastBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER</code>里，也就是上面提到在重启chain时候从block的<code>BlockMetadata.Metadata</code>内取key为<code>cb.BlockMetadataIndex_SIGNATURES</code>的值来获取kafka消费消息。回顾对比solo方式，在调用<code>chain.WriteBlock()</code>时，传入的第二个参数为nil。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">processTimeToCut</span><span class="params">(ttcMessage *ab.KafkaMessageTimeToCut, receivedOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">	ttcNumber := ttcMessage.GetBlockNumber()</span><br><span class="line">	<span class="keyword">if</span> ttcNumber == chain.lastCutBlockNumber+<span class="number">1</span> {</span><br><span class="line">		chain.timer = <span class="literal">nil</span></span><br><span class="line">		batch := chain.BlockCutter().Cut()</span><br><span class="line">		block := chain.CreateNextBlock(batch)</span><br><span class="line">		metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata{</span><br><span class="line">            LastOffsetPersisted:         receivedOffset,</span><br><span class="line">            LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">		})</span><br><span class="line">		chain.WriteBlock(block, metadata)</span><br><span class="line">		chain.lastCutBlockNumber++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> ttcNumber &gt; chain.lastCutBlockNumber+<span class="number">1</span> {</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(...)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">WriteBlock</span><span class="params">(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span></span> {</span><br><span class="line">	bw.committingBlock.Lock()</span><br><span class="line">	bw.lastBlock = block</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">		<span class="keyword">defer</span> bw.committingBlock.Unlock()</span><br><span class="line">		bw.commitBlock(encodedMetadataValue)</span><br><span class="line">	}()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">commitBlock</span><span class="params">(encodedMetadataValue []<span class="keyword">byte</span>)</span></span> {</span><br><span class="line">	<span class="comment">// Set the orderer-related metadata field</span></span><br><span class="line">	<span class="keyword">if</span> encodedMetadataValue != <span class="literal">nil</span> {</span><br><span class="line">		bw.lastBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = utils.MarshalOrPanic(&amp;cb.Metadata{Value: encodedMetadataValue})</span><br><span class="line">	}</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<ol>
<li><p><code>case *ab.KafkaMessage_Regular:</code>处理消息（envelop）</p>
 <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">processRegular</span><span class="params">(regularMessage *ab.KafkaMessageRegular, receivedOffset <span class="keyword">int64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When committing a normal message, we also update `lastOriginalOffsetProcessed` with `newOffset`. It is caller's responsibility to deduce correct value of `newOffset` based on following rules:</span></span><br><span class="line">    <span class="comment">// - if Resubmission is switched off, it should always be zero</span></span><br><span class="line">    <span class="comment">// - if the message is committed on first pass, meaning it's not re-validated and re-ordered, this value should be the same as current `lastOriginalOffsetProcessed`</span></span><br><span class="line">    <span class="comment">// - if the message is re-validated and re-ordered, this value should be the `OriginalOffset` of that Kafka message, so that `lastOriginalOffsetProcessed` is advanced</span></span><br><span class="line">    <span class="comment">// 其实，这个方法就是完成3件事情。</span></span><br><span class="line">    <span class="comment">// 1）如果不需要切割，并且如果chain.timer没有设置则重设timer（用以倒计时发送*ab.KafkaMessage_TimeToCut）；</span></span><br><span class="line">    <span class="comment">// 2）切割，更新KafkaMetadata.LastOffsetPersisted为这个block最后envelope的offset；</span></span><br><span class="line">    <span class="comment">// 3）更新chain.lastOriginalOffsetProcessed，并且用作KafkaMetadata.LastOriginalOffsetProcessed。</span></span><br><span class="line">    commitNormalMsg := <span class="function"><span class="keyword">func</span><span class="params">(message *cb.Envelope, newOffset <span class="keyword">int64</span>)</span></span> {</span><br><span class="line">        batches, pending := chain.BlockCutter().Ordered(message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(batches) == <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// If no block is cut, we update the `lastOriginalOffsetProcessed`, start the timer if necessary and return</span></span><br><span class="line">            chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">            <span class="keyword">if</span> chain.timer == <span class="literal">nil</span> {</span><br><span class="line">                <span class="comment">// configtx.yaml里的Orderer: &amp;OrdererDefaults.BatchTimeout</span></span><br><span class="line">                chain.timer = time.After(chain.SharedConfig().BatchTimeout())</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        chain.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        offset := receivedOffset</span><br><span class="line">        <span class="keyword">if</span> pending || <span class="built_in">len</span>(batches) == <span class="number">2</span> {</span><br><span class="line">            offset--</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            chain.lastOriginalOffsetProcessed = newOffset</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the first block</span></span><br><span class="line">        block := chain.CreateNextBlock(batches[<span class="number">0</span>])</span><br><span class="line">        metadata := utils.MarshalOrPanic(&amp;ab.KafkaMetadata{</span><br><span class="line">            <span class="comment">// LastOffsetPersisted记录的是这个block的最后envelope的offset，也就是消费的最后offset</span></span><br><span class="line">            LastOffsetPersisted:         offset,</span><br><span class="line">            <span class="comment">// LastOriginalOffsetProcessed记录指的是截止该block，originalOffset小于这个值的所有message都已经被排序，即最新处理的originalOffset</span></span><br><span class="line">            LastOriginalOffsetProcessed: chain.lastOriginalOffsetProcessed,</span><br><span class="line">            <span class="comment">// LastResubmittedConfigOffset这个记录的是最近提交的重新校验排序的configMsg的offset</span></span><br><span class="line">            LastResubmittedConfigOffset: chain.lastResubmittedConfigOffset,</span><br><span class="line">        })</span><br><span class="line">        chain.WriteBlock(block, metadata)</span><br><span class="line">        chain.lastCutBlockNumber++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the second block if exists</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(batches) == <span class="number">2</span> {...}</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    seq := chain.Sequence()</span><br><span class="line">    env := &amp;cb.Envelope{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这部分主要是为了兼容v1.1前的版本，前面的版本不支持re-submission</span></span><br><span class="line">    <span class="comment">// 这里的配置在configtx.yaml里，V1_1:true则`chain.SharedConfig().Capabilities().Resubmission()`返回为true。这里分析默认都使用V1.1后的版本</span></span><br><span class="line">    <span class="comment">//Capabilities:</span></span><br><span class="line">    <span class="comment">//  Orderer: &amp;OrdererCapabilities</span></span><br><span class="line">    <span class="comment">//      V1_1: true</span></span><br><span class="line">    <span class="keyword">if</span> regularMessage.Class == ab.KafkaMessageRegular_UNKNOWN || !chain.SharedConfig().Capabilities().Resubmission() {...}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> regularMessage.Class {</span><br><span class="line">    <span class="keyword">case</span> ab.KafkaMessageRegular_NORMAL:</span><br><span class="line">        <span class="comment">// This is a message that is re-validated and re-ordered</span></span><br><span class="line">        <span class="comment">// 普通消息的OriginalOffset为0，因为configSeq改变被重新验证和加入重排序</span></span><br><span class="line">        <span class="keyword">if</span> regularMessage.OriginalOffset != <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// chain.lastOriginalOffsetProcessed记录着最近的处理的重排消息的offset，意味着小于这个的消息都已经处理过，故返回不再重复处理。</span></span><br><span class="line">            <span class="comment">// 从下面的`regularMessage.ConfigSeq &lt; seq`可知，这是因为有多个orderer节点，每个节点都会往kafka重发消息，故可能会存在多条同样的消息（OriginalOffset相同但offset不同）</span></span><br><span class="line">            <span class="keyword">if</span> regularMessage.OriginalOffset &lt;= chain.lastOriginalOffsetProcessed {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 未处理的重排消息按照正常流程往下处理</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The config sequence has advanced，当前的配置已经更新，因此需要重新验证，重发kafka进行re-order</span></span><br><span class="line">        <span class="keyword">if</span> regularMessage.ConfigSeq &lt; seq {</span><br><span class="line">            configSeq, err := chain.ProcessNormalMsg(env)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">"discarding bad normal message because = %s"</span>, err)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新配置下重新校验通过</span></span><br><span class="line">            <span class="comment">// For both messages that are ordered for the first time or re-ordered, we set original offset to current received offset and re-order it.</span></span><br><span class="line">            <span class="keyword">if</span> err := chain.order(env, configSeq, receivedOffset); err != <span class="literal">nil</span> {...}</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的commitNormalMsg方法里可以看到用offset更新chain.lastOriginalOffsetProcessed，</span></span><br><span class="line">        <span class="comment">// 因此，offset或者保持原值chain.lastOriginalOffsetProcessed（当前消息不是re-order消息），或者采用当前消息的OriginalOffset（当前消息是re-order消息）</span></span><br><span class="line">        offset := regularMessage.OriginalOffset</span><br><span class="line">        <span class="keyword">if</span> offset == <span class="number">0</span> {</span><br><span class="line">            offset = chain.lastOriginalOffsetProcessed</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        commitNormalMsg(env, offset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ab.KafkaMessageRegular_CONFIG:</span><br><span class="line">        <span class="comment">// This is a message that is re-validated and re-ordered，同上</span></span><br><span class="line">        <span class="keyword">if</span> regularMessage.OriginalOffset != <span class="number">0</span> {</span><br><span class="line">            <span class="comment">// 同上, normalMsg</span></span><br><span class="line">            <span class="keyword">if</span> regularMessage.OriginalOffset &lt;= chain.lastOriginalOffsetProcessed {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lastResubmittedConfigOffset这个记录的是最近提交的被重新校验排序的configMsg的offset，如果消息的OriginalOffset等于该值，并且configSeq也相等，则说明已经本地已更新了配置，并且是最新的配置，可以关闭doneReprocessingMsgInFlight这个channel，继续消费（后面详述）</span></span><br><span class="line">            <span class="keyword">if</span> regularMessage.OriginalOffset == chain.lastResubmittedConfigOffset &amp;&amp; <span class="comment">// This is very last resubmitted config message</span></span><br><span class="line">                regularMessage.ConfigSeq == seq { <span class="comment">// AND we don't need to resubmit it again</span></span><br><span class="line">                <span class="built_in">close</span>(chain.doneReprocessingMsgInFlight) <span class="comment">// Therefore, we could finally close the channel to unblock broadcast</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Somebody resubmitted message at offset X, whereas we didn't. This is due to non-determinism where</span></span><br><span class="line">            <span class="comment">// that message was considered invalid by us during revalidation, however somebody else deemed it to</span></span><br><span class="line">            <span class="comment">// be valid, and resubmitted it. We need to advance lastResubmittedConfigOffset in this case in order</span></span><br><span class="line">            <span class="comment">// to enforce consistency across the network.</span></span><br><span class="line">            <span class="keyword">if</span> chain.lastResubmittedConfigOffset &lt; regularMessage.OriginalOffset {</span><br><span class="line">                chain.lastResubmittedConfigOffset = regularMessage.OriginalOffset</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The config sequence has advanced</span></span><br><span class="line">        <span class="keyword">if</span> regularMessage.ConfigSeq &lt; seq { </span><br><span class="line">            <span class="comment">// ProcessConfigUpdateMsg will attempt to apply the config impetus msg to the current configuration, and if successful</span></span><br><span class="line">            <span class="comment">// return the resulting config message and the configSeq the config was computed from.  If the config impetus message</span></span><br><span class="line">            <span class="comment">// is invalid, an error is returned.</span></span><br><span class="line">            <span class="comment">// 在这个方法里，将envelop里指定的配置尝试作用于本地</span></span><br><span class="line">            configEnv, configSeq, err := chain.ProcessConfigMsg(env)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同上, normalMsg。For both messages that are ordered for the first time or re-ordered, we set original offset to current received offset and re-order it.</span></span><br><span class="line">            <span class="keyword">if</span> err := chain.configure(configEnv, configSeq, receivedOffset); err != <span class="literal">nil</span> {</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">"error re-submitting config message because = %s"</span>, err)</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新lastResubmittedConfigOffset，最新的重新提交configMsg的offset</span></span><br><span class="line">            chain.lastResubmittedConfigOffset = receivedOffset      <span class="comment">// Keep track of last resubmitted message offset</span></span><br><span class="line">            chain.doneReprocessingMsgInFlight = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}) <span class="comment">// Create the channel to block ingress messages</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同上，normalMsg</span></span><br><span class="line">        offset := regularMessage.OriginalOffset</span><br><span class="line">        <span class="keyword">if</span> offset == <span class="number">0</span> {</span><br><span class="line">            offset = chain.lastOriginalOffsetProcessed</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同上，commitNormalMsg</span></span><br><span class="line">        commitConfigMsg(env, offset)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p> 回顾instantiate（8）里<code>orderer/common/broadcast/broadcast.go#Handle</code>提到的，orderer的broacast服务调用<code>processor.WaitReady()</code>, 这里<code>select-case case &lt;-chain.doneReprocessingMsgInFlight:</code>,也就是说，在configMsg进行re-order时，不再对外提供服务接收处理新数据，直到最新的配置已更新，关闭doneReprocessingMsgInFlight这个channel。</p>
 <figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Handle starts a service thread for a given gRPC connection and services the broadcast connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *handlerImpl)</span> <span class="title">Handle</span><span class="params">(srv ab.AtomicBroadcast_BroadcastServer)</span> <span class="title">error</span></span> {</span><br><span class="line"><span class="keyword">for</span> {</span><br><span class="line">    msg, err := srv.Recv()</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">if</span> err = processor.WaitReady(); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> srv.Send(&amp;ab.BroadcastResponse{Status: cb.Status_SERVICE_UNAVAILABLE, Info: err.Error()})</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !isConfig {</span><br><span class="line">        configSeq, err := processor.ProcessNormalMsg(msg)</span><br><span class="line">        err = processor.Order(msg, configSeq)</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">// isConfig</span></span><br><span class="line">        config, configSeq, err := processor.ProcessConfigUpdateMsg(msg)</span><br><span class="line">        err = processor.Configure(config, configSeq)</span><br><span class="line">    }</span><br><span class="line">    err = srv.Send(&amp;ab.BroadcastResponse{Status: cb.Status_SUCCESS})</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *chainImpl)</span> <span class="title">WaitReady</span><span class="params">()</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-chain.startChan: <span class="comment">// The Start phase has completed</span></span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> &lt;-chain.haltChan: <span class="comment">// The chain has been halted, stop here</span></span><br><span class="line">            <span class="keyword">return</span> error</span><br><span class="line">            <span class="comment">// Block waiting for all re-submitted messages to be reprocessed</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-chain.doneReprocessingMsgInFlight:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>总结来说，fabric的共识算法需要解决两个问题，一是交易消息的有序性，二是恶意节点的拜占庭问题。当前提供的两种共识机制单节点solo和多节点kafka。kafka在fabric的应用中，始终使用了单个partition，这样削弱了kafka本身提供的多分区带来的高性能。这样的考虑处于要最大程度保证交易排序和最后执行的有序性，虽然在v1.1版本后提供的可以re-validate和re-order特性在一定程度上违背了这种强有序性，但是在fabric里共识更重要的是全局一致性，即关键的是block是有序的，而且是一致的，而不在乎顺序是怎样的。但是最重要的是，kafka本身的共识算法并不能解决拜占庭问题，无法容忍网络里恶意节点的存在。这个通过fabric本身的准入审核，签名和策略等机制可以一定程度上预防这个问题。对于拜占庭问题，相对成熟的算法是pbft。在fabric的v0.6版本提供pbft共识机制，v1.0后采用了分割出orderer后，目前仍未提供pbft的相关实现。这个值得后续持续关注。</p>
<blockquote>
<p><a href="https://github.com/hyperledger/fabric/tree/release-1.4/orderer">Hyperledger Fabric Ordering Service</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/kafka.html">HyperLeger Fabric - Bringing up a Kafka-based Ordering Service</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/blockchain.html">HyperLeger Fabric - Introduction - Consensus</a><br><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/fabric_model.html#consensus">Hyperledger Fabric Model - Consensus</a><br><a href="https://docs.google.com/document/d/19JihmW-8blTzN99lAubOfseLUZqdrB6sBR0HsRgCAnY/edit">A Kafka-based Ordering Service for Fabric</a> : 详细介绍fabri orderer应用kafka的设计思想演进过程</p>
</blockquote>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>共识算法(1) - paxos &amp; raft</title>
    <url>//articles/consensus-paxos-raft/</url>
    <content><![CDATA[<ol>
<li><p>Paxos  </p>
<p> 算法的介绍在wikipedia里解释很清楚，可以结合example里的例子加深理解。概括来说，paxos分为prepare和accept两个阶段，将角色分为proposer，acceptor和learner，最基本的标准是majority quorum。每次proposer以（sequence number n, value v）的形式向acceptor提议（n为每个proposer节点自行管理的单增值，注意，这里会有多个proposer在并行的提议）。如果将prepare request到最终accept视作一轮，那么最终accept的提议是来自n最高的proposer，但是v是在prepare阶段最早得到quorum accept的，因为acceptor收到prepare request作出这样的promise（即承诺不再accept比该proposal的n更小或相等的值），并且返回收到并回复的prepare request的值。</p>
</li>
</ol>
<blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Paxos_%28computer_science%29">Paxos (computer science) - wiki</a></li>
<li><a href="https://angus.nyc/2012/paxos-by-example/">Paxos By Example</a></li>
</ul>
</blockquote>
<ol>
<li><p>Raft</p>
<p> 大致思路是，raft角色分为leader，follower和candidate（在leader election阶段）。每个leader的当选任期有全局统一且历史递增的term number。所有的写请求被路由或者follow重定向提交到leader，相当于将proposer缩减成唯一一个leader，leader给每个请求log entry添加index。整个过程也分为两个阶段，prepare阶段leader将log entry同步到所有follower，收到majority quorum回复同步后进入commit阶段，leader先commit本地，发送commit消息到follower，并且回复client。follower再commit本地执行，commit该index也意味着之前小于该index的消息都已同步并且全网一致。leader失败后则进入新一轮的选举（term值增加），最新最全数据的节点当选，新leader将其本地数据全网同步，follower相应补充或者剪枝，保证全局数据一致。</p>
</li>
</ol>
<blockquote>
<ul>
<li><a href="https://raft.github.io/">The Raft Consensus Algorithm</a> : Raft的github page</li>
<li><a href="http://thesecretlivesofdata.com/raft/">Raft example</a> : 国外的动画，非常形象</li>
<li><a href="https://medium.freecodecamp.org/in-search-of-an-understandable-consensus-algorithm-a-summary-4bc294c97e0d">Understanding the Raft consensus algorithm: an academic article summary</a></li>
<li><a href="https://infoq.cn/article/coreos-analyse-etcd">Raft 共识算法</a> ： 可以参看这篇etcd里介绍raft共识算法的节点异常情况</li>
</ul>
</blockquote>
<ol>
<li><p>综述</p>
<p> paxos最早的理论基础，但是工程上实现难度比较大，所以zookeeper（07年）自己设计了zab。13年raft出现，借鉴了zab的设计思想，同时工程上相对paxos更容易实现和理解。这些算法大量用于分布式应用及组件设计，假设前提是没有恶意节点，但并不能解决拜占庭将军问题（Paxos可以针对性扩展为Byzantine Paxos）。</p>
</li>
</ol>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/52617675">分布式系统的基石：深入浅出共识算法</a> ： 共识算法的综述，涵盖了paxos，raft，zab</li>
<li><a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab+vs.+Paxos">Zab vs. Paxos</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Consensus &amp; Cryptography</category>
      </categories>
      <tags>
        <tag>Consensus</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode install(2）endorsor的install流程</title>
    <url>//articles/fabric-source-chaincode-install-endorsor/</url>
    <content><![CDATA[<p>endorsor端流程也一致，入口都是<code>core/endorser/endorser.go#ProcessProposal</code>,具体不再重复展开，可以参看instantiate(3)。主要的区别在于<code>core/endorser/endorser.go#callChaincode</code>里，(“lscc”, “deploy”)的<code>if</code>条件不再满足，不需要进入（回顾一下，这里主要是launch用户application chaincode的容器，执行application chaincode的Init方法等，在install阶段当然不需要）。真正的区别在于<code>lscc.go#Invoke</code>的<code>select-case</code>里，进入的是<code>INSTALL</code>分支（部署chaincode时进入的是<code>DEPLOY</code>分支）。INSTALL首先执行<code>lscc.policyChecker.CheckPolicyNoChannel(mgmt.Admins, sp)</code>检查策略，这部分以后详述。从名字也印证出install是不指定channel的。然后执行lscc的<code>executeInstall</code>方法.</p>
<span id="more"></span>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// executeInstall implements the "install" Invoke transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *lifeCycleSysCC)</span> <span class="title">executeInstall</span><span class="params">(stub shim.ChaincodeStubInterface, ccbytes []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    ccpack, err := ccprovider.GetCCPackage(ccbytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get any statedb artifacts from the chaincode package, e.g. couchdb index definitions</span></span><br><span class="line">    statedbArtifactsTar, err := ccprovider.ExtractStatedbArtifactsFromCCPackage(ccpack)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err = isValidStatedbArtifactsTar(statedbArtifactsTar); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> InvalidStatedbArtifactsErr(err.Error())</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    chaincodeDefinition := &amp;cceventmgmt.ChaincodeDefinition{</span><br><span class="line">        Name:    ccpack.GetChaincodeData().Name,</span><br><span class="line">        Version: ccpack.GetChaincodeData().Version,</span><br><span class="line">        Hash:    ccpack.GetId()} <span class="comment">// Note - The chaincode 'id' is the hash of chaincode's (CodeHash || MetaDataHash), aka fingerprint</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HandleChaincodeInstall will apply any statedb artifacts (e.g. couchdb indexes) to</span></span><br><span class="line">    <span class="comment">// any channel's statedb where the chaincode is already instantiated</span></span><br><span class="line">    <span class="comment">// Note - this step is done prior to PutChaincodeToLocalStorage() since this step is idempotent and harmless until endorsements start,</span></span><br><span class="line">    <span class="comment">// that is, if there are errors deploying the indexes the chaincode install can safely be re-attempted later.</span></span><br><span class="line">    err = cceventmgmt.GetMgr().HandleChaincodeInstall(chaincodeDefinition, statedbArtifactsTar, lscc.sccprovider)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        cceventmgmt.GetMgr().ChaincodeInstallDone(err == <span class="literal">nil</span>)</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, if everything is good above, install the chaincode to local peer file system so that endorsements can start</span></span><br><span class="line">    <span class="keyword">if</span> err = lscc.support.PutChaincodeToLocalStorage(ccpack); err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><code>ccpack, err := ccprovider.GetCCPackage(ccbytes)</code>这里讲传入的<code>ChaincodeDeploymentSpec</code>字节反序列化，抽取信息构建<code>CDSPackage</code>或者<code>SignedCDSPackage</code>，根据是否执行<code>peer chaincode package</code>并签名。</li>
<li><code>ccprovider.ExtractStatedbArtifactsFromCCPackage(ccpack)</code>和<code>cceventmgmt.GetMgr().HandleChaincodeInstall(chaincodeDefinition, statedbArtifactsTar, lscc.sccprovider)</code>涉及couchdb相关，笔者尚未深入分析，以后专题详述。</li>
<li><code>lscc.support.PutChaincodeToLocalStorage(ccpack)</code>将代码package放到本地路径，在instantiate里launch时候取出。这里确定的放置package路径为<code>path := fmt.Sprintf("%s/%s.%s", chaincodeInstallPath, ChaincodeId.Name, ChaincodeId.Version)</code>,这里的path为chaincodeInstallPath<code>(config.GetPath("peer.fileSystemPath") + string(filepath.Separator) + "chaincodes")</code>, 配置项<code>peer.fileSystemPath</code>是peer启动时从配置文件core.yaml里读取的。</li>
</ol>
<p>至此完成了install工作，在endorser节点的chaincodeInstallPath路径下，存在名为ChaincodeName.ChaincodeVersion的源码包，供instantiate（3）中在安装时从该路径取出。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode install(1）peer端的install流程</title>
    <url>//articles/fabric-source-chaincode-install-peer/</url>
    <content><![CDATA[<p><a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/build_network.html">Building Your First Network</a>例子中，命令为</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02/go/</span><br></pre></td></tr></tbody></table></figure>
<p>客户端调用<code>peer chaincode install</code>命令安装chaincode，代码在‘peer/chaincode/install.go’这个文件下，命令关联的方法是<code>chaincodeInstall</code>。<em>[install的流程与前面介绍的instantiate大体相似，重复不再展开，只勾勒差别处]</em></p>
<span id="more"></span>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// chaincodeInstall installs the chaincode. If remoteinstall, does it via a lscc call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chaincodeInstall</span><span class="params">(cmd *cobra.Command, ccpackfile <span class="keyword">string</span>, cf *ChaincodeCmdFactory)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">if</span> cf == <span class="literal">nil</span> {</span><br><span class="line">        cf, err = InitCmdFactory(cmd.Name(), <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ccpackmsg proto.Message</span><br><span class="line">    <span class="comment">// ccpackfile = args[0]</span></span><br><span class="line">    <span class="keyword">if</span> ccpackfile == <span class="string">""</span> {</span><br><span class="line">        <span class="comment">// 检查提供的flag参数, 例如chaincodePath(-p), chaincodeVersion(-v), chaincodeName(-n)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//generate a raw ChaincodeDeploymentSpec</span></span><br><span class="line">        ccpackmsg, err = genChaincodeDeploymentSpec(cmd, chaincodeName, chaincodeVersion)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//read in a package generated by the "package" sub-command (and perhaps signed by multiple owners with the "signpackage" sub-command)</span></span><br><span class="line">        ccpackmsg, cds, err = getPackageFromFile(ccpackfile)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the chaincode details from cds and validate ChaincodeId.Name, ChaincodeId.Version if user provided</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = install(ccpackmsg, cf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//install the depspec to "peer.address"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">install</span><span class="params">(msg proto.Message, cf *ChaincodeCmdFactory)</span> <span class="title">error</span></span> {</span><br><span class="line">    creator, err := cf.Signer.Serialize()</span><br><span class="line">    prop, _, err := utils.CreateInstallProposalFromCDS(msg, creator)</span><br><span class="line">    signedProp, err = utils.GetSignedProposal(prop, cf.Signer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// install is currently only supported for one peer</span></span><br><span class="line">    proposalResponse, err := cf.EndorserClients[<span class="number">0</span>].ProcessProposal(context.Background(), signedProp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>install与instantiate方法类似，首先<code>InitCmdFactory</code>初始化命令工厂辅助，参见instantiate（1）.</li>
<li><p>获取chaincode的文件描述。这里分为两种方式，区别在于是否先使用<code>peer chaincode package</code>命令，得到的package作为<code>chaincode istall</code>参数，通常还经过多个参与者签名。具体可以参看<a href="https://hyperledger-fabric.readthedocs.io/en/latest/chaincode4noah.html">chaincode lifecycle</a>。package命令以后再详述。Tutorial里的例子没有先经过package，参数<code>ccpackfile</code>为空，则进入<code>genChaincodeDeploymentSpec</code>第一种方式产生cds。</p>
<p> <code>genChaincodeDeploymentSpec</code>过程与instantiate大致一致，可以参考instantiate（2），这里不同的是<code>peer/chaincode/common.go:getChaincodeDeploymentSpec</code>里会进入到<code>if</code>条件里，执行到<code>codePackageBytes, err = container.GetChaincodePackageBytes(spec)</code>。这个方法会区分不同的语言平台（这个语言选择是命令行里-l指定的）将代码gzip压缩，tar打包（以golang为例，为了精简包大小，去除golang标准库，fabric框架包等，加入第三方依赖包，META-INF信息等），返回[]byte。后面的流程与instantiate类似，可参考不再详述，可以认真对比下区别在于cis的Input和cds。</p>
</li>
</ol>
<p>产生<code>ccpackmsg</code>(<code>pb.ChaincodeDeploymentSpec</code>结构)执行<code>install</code>。正如源码里的注释和前面instantiate（1）介绍的InitCmdFactory，install方法只能作用于唯一一个endorser（”peer.address”）。注意，这里与instantiate不同，在instantiate里还有第三步<code>cf.BroadcastClient.Send(env)</code>.这里说明，install命令不需要将message发往orderer去排序和产生区块。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// peer.ChaincodeInvokeSpec(cis)</span></span><br><span class="line">{</span><br><span class="line">    <span class="attr">"ChaincodeInvokeSpec"</span> : {</span><br><span class="line">        <span class="attr">"ChaincodeSpec"</span> : { <span class="comment">// pb.ChaincodeSpec</span></span><br><span class="line">            <span class="attr">"Type"</span> : <span class="string">"ChaincodeSpec_GOLANG"</span>,</span><br><span class="line">            <span class="attr">"ChaincodeId"</span> : {</span><br><span class="line">                <span class="attr">"Name"</span> : <span class="string">"lscc"</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">"Input"</span> : {</span><br><span class="line">                <span class="attr">"Args"</span> : [<span class="string">"install"</span>, <span class="string">"${chaincodDeploySpec}"</span>]</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// pb.chaincodDeploySpec(cds)</span></span><br><span class="line">{</span><br><span class="line">    <span class="attr">"ChaincodeSpec"</span>: {</span><br><span class="line">        <span class="attr">"Type"</span> : <span class="string">"ChaincodeSpec_GOLANG"</span>,</span><br><span class="line">        <span class="attr">"ChaincodeId"</span> : {</span><br><span class="line">            <span class="attr">"Path"</span> : <span class="string">"${chaincodePath}"</span>,</span><br><span class="line">            <span class="attr">"Name"</span> : <span class="string">"${chaincodeName}"</span>,</span><br><span class="line">            <span class="attr">"Version"</span> : <span class="string">"${chaincodeVersion}"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">"Input"</span> : <span class="string">"nil"</span>   </span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"CodePackage"</span>: <span class="string">"#{container.GetChaincodePackageBytes(spec)}"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>至此，peer端的install完成，该节点仅仅是作为执行install命令，需要本地拥有install的代码包，install并不是安装到该peer节点而是endorser节点。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(8）orderer的排序过程</title>
    <url>//articles/fabric-source-chaincode-instantiate-orderer-order/</url>
    <content><![CDATA[<p>在instantiate(1)里提到，peer收集完endorsements后创建common.Envelope, 通过grpc发送到<code>/orderer.AtomicBroadcast/Broadcast</code>. common.Envelope的数据结构如下</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// common.Envelope</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Payload"</span>: ${common.Payload}.byte,</span><br><span class="line">  <span class="attr">"Signature"</span>: #signer.Sign(${common.Payload}.byte)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// common.Payload</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Header"</span>: ${proposal.Header},   <span class="comment">// proposal参考instantiate（2）</span></span><br><span class="line">  <span class="attr">"Data"</span>: ${peer.Transaction}.byte</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.Transaction</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Actions"</span>:  taas := make([]*peer.TransactionAction, 1), taas[0] = ${peer.TransactionAction}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.TransactionAction</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Header"</span>: ${proposal.Header.SignatureHeader}, </span><br><span class="line">  <span class="attr">"Payload"</span>: ${peer.ChaincodeActionPayload}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.ChaincodeActionPayload</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"ChaincodeProposalPayload"</span>: ${peer.ChaincodeProposalPayload}.byte, </span><br><span class="line">  <span class="attr">"Action"</span>: ${peer.ChaincodeEndorsedAction}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> <span class="comment">// peer.ChaincodeProposalPayload</span></span><br><span class="line"> {</span><br><span class="line">   <span class="attr">"Input"</span>: ${proposal.Payload.Input}, </span><br><span class="line">   <span class="attr">"TransientMap"</span>: nil</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.ChaincodeEndorsedAction， response结构参考instantiate（7）</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"ProposalResponsePayload"</span>: ${resps[0].Payload},  <span class="comment">// 所有response的payload都应该是一致的，在前面已经校验过 </span></span><br><span class="line">  <span class="attr">"Endorsements"</span>: #endorsements := make([]*peer.Endorsement, len(resps)) <span class="comment">// 所有的endorsement</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<span id="more"></span>
<p>全局搜索，orderer端执行<code>protos/orderer/ab.pb.go#_AtomicBroadcast_Broadcast_Handler</code> -&gt; <code>orderer/common/server/server.go#Broadcast</code> -&gt; <code>orderer/common/broadcast/broadcast.go#Handle</code>.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Handle starts a service thread for a given gRPC connection and services the broadcast connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *handlerImpl)</span> <span class="title">Handle</span><span class="params">(srv ab.AtomicBroadcast_BroadcastServer)</span> <span class="title">error</span></span> {</span><br><span class="line">  <span class="keyword">for</span> {</span><br><span class="line">      msg, err := srv.Recv()</span><br><span class="line"></span><br><span class="line">      chdr, isConfig, processor, err := bh.sm.BroadcastChannelSupport(msg)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">          <span class="keyword">return</span> srv.Send(&amp;ab.BroadcastResponse{Status: cb.Status_BAD_REQUEST, Info: err.Error()})</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err = processor.WaitReady(); err != <span class="literal">nil</span> {</span><br><span class="line">          <span class="keyword">return</span> srv.Send(&amp;ab.BroadcastResponse{Status: cb.Status_SERVICE_UNAVAILABLE, Info: err.Error()})</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> !isConfig {</span><br><span class="line">          configSeq, err := processor.ProcessNormalMsg(msg)</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">              <span class="keyword">return</span> srv.Send(&amp;ab.BroadcastResponse{Status: ClassifyError(err), Info: err.Error()})</span><br><span class="line">          }</span><br><span class="line">          err = processor.Order(msg, configSeq)</span><br><span class="line">      } <span class="keyword">else</span> { <span class="comment">// isConfig</span></span><br><span class="line">          config, configSeq, err := processor.ProcessConfigUpdateMsg(msg)</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">              <span class="keyword">return</span> srv.Send(&amp;ab.BroadcastResponse{Status: ClassifyError(err), Info: err.Error()})</span><br><span class="line">          }</span><br><span class="line">          err = processor.Configure(config, configSeq)</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      err = srv.Send(&amp;ab.BroadcastResponse{Status: cb.Status_SUCCESS})</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><code>for</code>循环里<code>srv.Recv()</code>从grpc stream里接收数据。</li>
<li><code>bh.sm.BroadcastChannelSupport(msg)</code>检查并返回<code>proposal.header.channelHeader.Type</code>,这里的HeaderType为<code>HeaderType_ENDORSER_TRANSACTION</code>(参考instantiate-2)，判断为normalMsg。</li>
<li><code>processor.WaitReady()</code>。这里分三个实现，solo(orderer/consensus/solo/consensus.go), etcdraft(orderer/consensus/etcdraft/chain.go，<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/whatsnew.html">V1.4.1版本</a>引入)和kafka（orderer/consensus/kafka/chain.go）。solo方法是orderer单节点，不存在数据交换汇集，不会阻塞，不做任何操作直接返回。而etcdraft，kafka实现是多节点orderer，节点间需要通信。这个后面详述。</li>
<li><code>configSeq, err := processor.ProcessNormalMsg(msg)</code>，返回当前配置的seq（单增），并且策略检查msg。这些策略可以回溯到<code>fabric/orderer/common/multichannel/chainsupport.go#newChainSupport</code>里创建<code>cs.Processor = msgprocessor.NewStandardChannel(cs, msgprocessor.CreateStandardChannelFilters(cs))</code>时初始化。策略fliter的规则可以通过名称大致猜测。<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ProcessNormalMsg will check the validity of a message based on the current configuration.  It returns the current configuration sequence number and nil on success, or an error if the message is not valid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StandardChannel)</span> <span class="title">ProcessNormalMsg</span><span class="params">(env *cb.Envelope)</span> <span class="params">(configSeq <span class="keyword">uint64</span>, err error)</span></span> {</span><br><span class="line">    configSeq = s.support.Sequence()</span><br><span class="line">    err = s.filters.Apply(env)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;orderer/common/msgprocessor/standardchannel.go&gt;</span></span><br><span class="line"><span class="comment">// CreateStandardChannelFilters creates the set of filters for a normal (non-system) chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateStandardChannelFilters</span><span class="params">(filterSupport channelconfig.Resources)</span> *<span class="title">RuleSet</span></span> {</span><br><span class="line">    ordererConfig, ok := filterSupport.OrdererConfig()</span><br><span class="line">    <span class="keyword">return</span> NewRuleSet([]Rule{</span><br><span class="line">        EmptyRejectRule,  <span class="comment">// 校验envelop的payload不为nil</span></span><br><span class="line">        NewExpirationRejectRule(filterSupport),  <span class="comment">// 校验payload.Header.SignatureHeade.Creator的x509证书未过期</span></span><br><span class="line">        NewSizeFilter(ordererConfig), <span class="comment">// 校验enveloy的size不能超过配置的batch.AbsoluteMaxBytes，对应于configtx.yaml中的Orderer.BatchSize.AbsoluteMaxBytes（10MB）</span></span><br><span class="line">        NewSigFilter(policies.ChannelWriters, filterSupport), <span class="comment">// 检查policy当前请求拥有当前channel的写权限</span></span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>这里简述下solo的方式，kafka后面专题详述。solo把message直接放入<code>ch.sendChan</code>内, solo的相关代码在<code>orderer/consensus/solo/consensus.go</code><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// solo： Order accepts normal messages for ordering</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *chain)</span> <span class="title">Order</span><span class="params">(env *cb.Envelope, configSeq <span class="keyword">uint64</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> ch.sendChan &lt;- &amp;message{</span><br><span class="line">        configSeq: configSeq,</span><br><span class="line">        normalMsg: env,</span><br><span class="line">    }:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-ch.exitChan:</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"Exiting"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<hr>
<p>在<code>orderer/consensus/solo/consensus.go:main</code>内处理channle sendChan里的消息<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ch *chain)</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">var</span> timer &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">        seq := ch.support.Sequence()</span><br><span class="line">        err = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">select</span> {</span><br><span class="line">        <span class="keyword">case</span> msg := &lt;-ch.sendChan:</span><br><span class="line">            <span class="keyword">if</span> msg.configMsg == <span class="literal">nil</span> {</span><br><span class="line">                <span class="comment">// NormalMsg</span></span><br><span class="line">                <span class="keyword">if</span> msg.configSeq &lt; seq {</span><br><span class="line">                    _, err = ch.support.ProcessNormalMsg(msg.normalMsg)</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                batches, _ := ch.support.BlockCutter().Ordered(msg.normalMsg)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> _, batch := <span class="keyword">range</span> batches {</span><br><span class="line">                    block := ch.support.CreateNextBlock(batch)</span><br><span class="line">                    ch.support.WriteBlock(block, <span class="literal">nil</span>)</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// ConfigMsg</span></span><br><span class="line">                ...</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol>
<li><code>msg.configSeq &lt; seq</code>判断配置在写入channel和读出channel过程中是否有更改，如果有，则重新执行<code>ProcessNormalMsg</code>用新的规则校验消息是否合法。</li>
<li><code>batches, _ := ch.support.BlockCutter().Ordered(msg.normalMsg)</code>将消息切片，短小消息合并成一个批次，大消息切分多个批次，使其不超过block规定长度。源码注释有详细介绍。<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// messageBatches length: 0, pending: false</span><br><span class="line">//   - impossible, as we have just received a message</span><br><span class="line">// messageBatches length: 0, pending: true</span><br><span class="line">//   - no batch is cut and there are messages pending.</span><br><span class="line">//   - 没有切分block，并且加上当前envelop后继续等待添加</span><br><span class="line">// messageBatches length: 1, pending: false</span><br><span class="line">//   - the message count reaches BatchSize.MaxMessageCount。 </span><br><span class="line">//   - 切分block，因为加上当前envelop后达到数量限制，对应configtx.yaml中的Orderer.BatchSize.MaxMessageCount(10)</span><br><span class="line">// messageBatches length: 1, pending: true</span><br><span class="line">//   - the current message will cause the pending batch size in bytes to exceed BatchSize.PreferredMaxBytes. </span><br><span class="line">//   - 切分block，因为如果加上当前envelop后，所有的batch大小超过配置的configtx.yaml中的Orderer.BatchSize.PreferredMaxBytes(512KB)，所以将之前的切分block，而当前的envelop继续等待后续添加（当前envelop大小小于PreferredMaxBytes）</span><br><span class="line">// messageBatches length: 2, pending: false</span><br><span class="line">//   - the current message size in bytes exceeds BatchSize.PreferredMaxBytes, therefore isolated in its own batch.</span><br><span class="line">//   - 当前envelop大小大于PreferredMaxBytes，将之前的作为第一个block，将当前的作为第二个block（前面已经校验过，envelop大小不会超过AbsoluteMaxBytes（10MB））</span><br><span class="line">// messageBatches length: 2, pending: true</span><br><span class="line">//   - impossible</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><code>CreateNextBlock</code>创建下一个区块，可以看出，header的number（深度）+1，并且附带上前一个区块的hash，并且计算当前区块data数据的哈希，这些构成区块的信息。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"Header"</span>: ${BlockHeader},</span><br><span class="line">    <span class="attr">"Data"</span>: ${BlockData},</span><br><span class="line">    <span class="attr">"Metadata"</span>: ${BlockMetadata}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockHeader</span></span><br><span class="line">{</span><br><span class="line">    <span class="attr">"Number"</span>: ${lastBlock.Header.Number}+<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"PreviousHash"</span>: #lastBlock.Header.Hash(),</span><br><span class="line">    <span class="attr">"DataHash"</span>: #${BlockData}.Hash()</span><br><span class="line">}</span><br><span class="line"><span class="comment">// BlockData</span></span><br><span class="line">{</span><br><span class="line">    <span class="attr">"Data"</span>: #make([][]byte, len(envelop))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// BlockMetadata</span></span><br><span class="line">{</span><br><span class="line">    <span class="attr">"Metadata"</span>: [][]byte</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>WriteBlock</code>提交区块。这里会加上block的签名，然后提交。 <code>BlockWriter.support</code>主要有三种实现，file，json（一个区块创建一个文件，以深度命名，写入json格式），ram。这里写入orderer本地，后面通过deleiver服务同步到peer节点真正的提交到各自的本地账本db。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// WriteBlock should be invoked for blocks which contain normal transactions.</span></span><br><span class="line"><span class="comment">// It sets the target block as the pending next block, and returns before it is committed.</span></span><br><span class="line"><span class="comment">// Before returning, it acquires the committing lock, and spawns a go routine which will</span></span><br><span class="line"><span class="comment">// annotate the block with metadata and signatures, and write the block to the ledger</span></span><br><span class="line"><span class="comment">// then release the lock.  This allows the calling thread to begin assembling the next block</span></span><br><span class="line"><span class="comment">// before the commit phase is complete.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">WriteBlock</span><span class="params">(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span></span> {</span><br><span class="line">    bw.committingBlock.Lock()</span><br><span class="line">    bw.lastBlock = block</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">      <span class="keyword">defer</span> bw.committingBlock.Unlock()</span><br><span class="line">      bw.commitBlock(encodedMetadataValue)</span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// commitBlock should only ever be invoked with the bw.committingBlock held</span></span><br><span class="line"><span class="comment">// this ensures that the encoded config sequence numbers stay in sync</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BlockWriter)</span> <span class="title">commitBlock</span><span class="params">(encodedMetadataValue []<span class="keyword">byte</span>)</span></span> {</span><br><span class="line">    <span class="comment">// Set the orderer-related metadata field</span></span><br><span class="line">    <span class="comment">// 在BlockMetadata.Metadata内加上key为cb.BlockMetadataIndex_ORDERER的值</span></span><br><span class="line">    <span class="keyword">if</span> encodedMetadataValue != <span class="literal">nil</span> {</span><br><span class="line">        bw.lastBlock.Metadata.Metadata[cb.BlockMetadataIndex_ORDERER] = utils.MarshalOrPanic(&amp;cb.Metadata{Value: encodedMetadataValue})</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在BlockMetadata.Metadata内加上key为cb.BlockMetadataIndex_SIGNATURES的值</span></span><br><span class="line">    bw.addBlockSignature(bw.lastBlock)</span><br><span class="line">    <span class="comment">// 在BlockMetadata.Metadata内加上key为cb.BlockMetadataIndex_LAST_CONFIG的值</span></span><br><span class="line">    bw.addLastConfigSignature(bw.lastBlock)</span><br><span class="line"></span><br><span class="line">    err := bw.support.Append(bw.lastBlock)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>对于configMsg，流程非常相似，<code>processor.ProcessConfigUpdateMsg(msg)</code>相对而言，除了normalMsg的步骤外，还通过提交过来的config和本地存储的现行config比较，计算出readSet和writeSet，校验通过后，签名生成envelope(<code>utils.CreateSignedEnvelope(cb.HeaderType_CONFIG, s.support.ChainID(), s.support.Signer(), configEnvelope, msgVersion, epoch)</code>).而<code>processor.Configure(config, configSeq)</code>则与<code>processor.Order(msg, configSeq)</code>完全一致了，仅是名称不同。</p>
<p>至此，完成了orderer端的工作，这些提交到本地的区块，后续将通过deliver服务同步到peer。具体后面专题介绍。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(7）endoser的endorseProposal过程</title>
    <url>//articles/fabric-source-chaincode-instantiate-endorser-endorse-proposal/</url>
    <content><![CDATA[<p>回顾到<code>endorser.go#SimulateProposal</code>,执行完<code>callChaincode</code>后，回顾前面，在这里有两次调用chaincode，分别是lscc的Inovke和acc的Init，<code>callChaincode</code>这里返回的是第一次调用的lscc的response。调用acc Init的结果只判断调用是否正常完成返回<code>pb.ChaincodeMessage_COMPLETED</code>。这是因为在<code>handleInit</code>里对初始化失败，即<code>pb.Response.status</code>不等于200的统一返回<code>pb.ChaincodeMessage_ERROR</code>，这点与Invoke的处理方式是不一样的。Invoke允许<code>pb.ChaincodeMessage.Type</code>=<code>pb.ChaincodeMessage_COMPLETED</code>,但是内层的<code>pb.Response.status</code>不等于200. 若返回<code>pb.ChaincodeMessage_ERROR</code>，则向上层返回error，最终返回<code>&amp;pb.ProposalResponse{Response: &amp;pb.Response{Status: 500, Message: err.Error()}}</code>到<code>peer chainncode instantiate...</code>这个命令的执行节点peer。</p>
<p>紧接着调用<code>txsim.GetTxSimulationResults()</code>获取上节提到的<code>lockbased_tx_simulator</code>的读写集合。先看下这个<code>txsim</code>是如何传递的。首先初始化后在<code>callChaincode</code>加入context<code>ctxt = context.WithValue(ctxt, chaincode.TXSimulatorKey, txsim)</code>。之后在<code>chaincode/handler</code>里构建<code>TransactionContext</code>实体对象时将txsim从context取出，包裹进这个新建的TransactionContext对象内。这个对象前面有提及，是关联于<code>chainID, txID</code>这两个存放于<code>chaincode/handler.TXContexts.map[string]*TransactionContext</code>里。后面在<code>chaincode/handler.go#handlerTranction</code>里调用<code>txContext, err = h.isValidTxSim(msg.ChannelId, msg.Txid)}</code>也是以此取出该txsim，将读写结果放进读写集readwriteSet。</p>
<p><code>txsim.GetTxSimulationResults()</code>这里在返回前，先对读写集合按照key排序。这里包含pub和pri两部分数据，先关注pub部分。rwset这部分以后展开专题介绍。然后调用<code>txsim.Done()</code>，签名初始化txsim时候提到获取了ledger的读锁，因此这里需要释放<code>h.txmgr.commitRWLock.RUnlock()</code>。返回共有数据的读写集到<code>endorser#ProcessProposal</code>。</p>
<span id="more"></span>
<p>第二步，背书模拟结果。主要是signer对payload进行签名，并且附上自身签名的identityBytes构造成response。然后这个resp就返回方法，通过grpc发送回调用方peer.<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// endorse the proposal by calling the ESCC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">endorseProposal</span><span class="params">(_ context.Context, chainID <span class="keyword">string</span>, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, proposal *pb.Proposal, response *pb.Response, simRes []<span class="keyword">byte</span>, event *pb.ChaincodeEvent, visibility []<span class="keyword">byte</span>, ccid *pb.ChaincodeID, txsim ledger.TxSimulator, cd ccprovider.ChaincodeDefinition)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> {</span><br><span class="line">    isSysCC := cd == <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 1) extract the name of the escc that is requested to endorse this chaincode, ie, "lscc" or system chaincodes</span></span><br><span class="line">    <span class="keyword">if</span> isSysCC {</span><br><span class="line">        escc = <span class="string">"escc"</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        escc = cd.Endorsement()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// marshalling event bytes</span></span><br><span class="line">    <span class="keyword">if</span> event != <span class="literal">nil</span> {</span><br><span class="line">        eventBytes, err = putils.GetBytesChaincodeEvent(event)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ctx := Context{</span><br><span class="line">        PluginName:     escc,</span><br><span class="line">        Channel:        chainID,</span><br><span class="line">        SignedProposal: signedProp,</span><br><span class="line">        ChaincodeID:    ccid,</span><br><span class="line">        Event:          eventBytes,</span><br><span class="line">        SimRes:         simRes,</span><br><span class="line">        Response:       response,</span><br><span class="line">        Visibility:     visibility,</span><br><span class="line">        Proposal:       proposal,</span><br><span class="line">        TxID:           txid,</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> e.s.EndorseWithPlugin(ctx)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndorseWithPlugin endorses the response with a plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pe *PluginEndorser)</span> <span class="title">EndorseWithPlugin</span><span class="params">(ctx Context)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> {</span><br><span class="line">    plugin, err := pe.getOrCreatePlugin(PluginName(ctx.PluginName), ctx.Channel)</span><br><span class="line"></span><br><span class="line">    prpBytes, err := proposalResponsePayloadFromContext(ctx)</span><br><span class="line"></span><br><span class="line">    endorsement, prpBytes, err := plugin.Endorse(prpBytes, ctx.SignedProposal)</span><br><span class="line">      </span><br><span class="line">    resp := &amp;pb.ProposalResponse{</span><br><span class="line">      Version:     <span class="number">1</span>,</span><br><span class="line">      Endorsement: endorsement,</span><br><span class="line">      Payload:     prpBytes,</span><br><span class="line">      Response:    ctx.Response,</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;默认的escc ： github.com/hyperledger/fabric/core/handlers/endorsement/builtin/default_endorsement.go&gt;</span></span><br><span class="line"><span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line"><span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line"><span class="comment">// Or error on failure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DefaultEndorsement)</span> <span class="title">Endorse</span><span class="params">(prpBytes []<span class="keyword">byte</span>, sp *peer.SignedProposal)</span> <span class="params">(*peer.Endorsement, []<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">    signer, err := e.SigningIdentityForRequest(sp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialize the signing identity</span></span><br><span class="line">    identityBytes, err := signer.Serialize()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sign the concatenation of the proposal response and the serialized endorser identity with this endorser's key</span></span><br><span class="line">    signature, err := signer.Sign(<span class="built_in">append</span>(prpBytes, identityBytes...))</span><br><span class="line"></span><br><span class="line">    endorsement := &amp;peer.Endorsement{Signature: signature, Endorser: identityBytes}</span><br><span class="line">    <span class="keyword">return</span> endorsement, prpBytes, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>最后，返回的结构体为<code>pb.ProposalResponse</code><br><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  <span class="attr">"Version"</span>: <span class="number">1</span>, <span class="comment">// 固定值</span></span><br><span class="line">  <span class="attr">"Response"</span>: ${pb.Response}, <span class="comment">// 上节instantiate(6)里从`chaincode/handler`返回的`pb.Response`. A response message indicating whether the endorsement of the action was successful</span></span><br><span class="line">  <span class="attr">"Payload"</span>: ${peer.ProposalResponsePayload},</span><br><span class="line">  <span class="attr">"Endorsement"</span>:  ${peer.Endorsement} <span class="comment">// 来源于`fabric/core/handlers/endorsement/plugin/plugin.go#Endorse`</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.ProposalResponsePayload</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Extension"</span>: ${&amp;peer.ChaincodeAction}.byte[], </span><br><span class="line">  <span class="attr">"ProposalHash"</span>: #putils.GetProposalHash1(proposal.hdr, proposal.Payload, ctx.Visibility)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.ChaincodeAction</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Events"</span>: ${pb.chaincodeEvent}, <span class="comment">// 上节instantiate(6)里从`chaincode/handler`返回的`pb.chaincodeEvent`</span></span><br><span class="line">  <span class="attr">"Results"</span>: ${txSim.PubSimulationResults}, <span class="comment">// 模拟结果，read-write set</span></span><br><span class="line">  <span class="attr">"Response"</span>: ${pb.Response}, <span class="comment">// 上节instantiate(6)里从`chaincode/handler`返回的`pb.Response`, 与外层的Response一致 </span></span><br><span class="line">  <span class="attr">"ChaincodeId"</span>: {<span class="attr">"Name"</span>:<span class="string">"lscc"</span>,<span class="attr">"version"</span>:<span class="string">"latests"</span>}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// peer.Endorsement</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Signature"</span>: #signer.Sign(append(prpBytes, identityBytes...)) <span class="comment">// 将payload和dentity联合起来产生签名</span></span><br><span class="line">  <span class="attr">"Endorser"</span>: #identityBytes = signer.Serialize()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(6）application chaincode的初始化</title>
    <url>//articles/fabric-source-chaincode-instantiate-chaincode-init/</url>
    <content><![CDATA[<p>接着继续分析acc的初始化过程，在instantiate(3)里提到<code>endorser.callChaincode</code>有两次的<code>ChaincodeSupport#Execute</code>调用,由代码分析两次不同的<code>ChaincodeMessage</code>的<code>MessageType</code>分别为<code>MessageType_TRANSACTION</code>（对应cis）和<code>MessageType_INIT</code>（对应cds），相应调用lscc的Invoke和acc的Init。具体过程可以参考上节分析。</p>
<p>先看lscc的<code>Invoke</code>.参考上节提及的<code>execute</code>在两端<code>chaincode/handler.go</code>（peer端）和<code>shim/handler.go</code>（chaincode容器端）的流程，lscc相当于chaincode容器（尽管是inproccontainer），使用<code>shim/handler.go#handleReady</code>里<code>select-case</code>，lscc的<code>ChaincodeMessage_TRANSACTION</code>进入<code>handleTransaction</code>方法。这里的主要流程与上节介绍的<code>handleInit</code>一致，不同的是这里调用的是lscc的<code>Invoke</code>方法。这里需要强调一点，在<code>handleTransaction</code>,<code>handleInit</code>这些<code>handleXXX</code>方法里，进入就是启动goroutinne来运行所有的逻辑，这样可以立刻返回并行来处理下一个请求。</p>
<span id="more"></span>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Invoke implements lifecycle functions "deploy", "start", "stop", "upgrade".</span></span><br><span class="line"><span class="comment">// Deploy's arguments -  {[]byte("deploy"), []byte(&lt;chainname&gt;), &lt;unmarshalled pb.ChaincodeDeploymentSpec&gt;}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invoke also implements some query-like functions</span></span><br><span class="line"><span class="comment">// Get chaincode arguments -  {[]byte("getid"), []byte(&lt;chainname&gt;), []byte(&lt;chaincodename&gt;)}</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *lifeCycleSysCC)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> { </span><br><span class="line"></span><br><span class="line">  function := <span class="keyword">string</span>(args[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">switch</span> function {</span><br><span class="line">  <span class="keyword">case</span> DEPLOY, UPGRADE:</span><br><span class="line">      channel := <span class="keyword">string</span>(args[<span class="number">1</span>])</span><br><span class="line">      <span class="comment">// 获取channel的设置，这个在create channel时传入配置</span></span><br><span class="line">      ac, exists := lscc.sccprovider.GetApplicationConfig(channel)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// the maximum number of arguments depends on the capability of the channel</span></span><br><span class="line">      <span class="comment">// 校验当前传入参数与channel配置（ac）是否冲突，这里校验主要是ac.Capabilities().PrivateChannelData()</span></span><br><span class="line"></span><br><span class="line">      depSpec := args[<span class="number">2</span>]</span><br><span class="line">      cds, err := utils.GetChaincodeDeploymentSpec(depSpec)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// optional arguments here (they can each be nil and may or may not be present)</span></span><br><span class="line">      <span class="comment">// args[3] is a marshalled SignaturePolicyEnvelope representing the endorsement policy</span></span><br><span class="line">      <span class="comment">// args[4] is the name of escc, default "escc"(系统自带)</span></span><br><span class="line">      <span class="comment">// args[5] is the name of vscc, default "vscc"(系统自带）</span></span><br><span class="line">      <span class="comment">// args[6] is a marshalled CollectionConfigPackage struct</span></span><br><span class="line">      <span class="keyword">var</span> EP []<span class="keyword">byte</span></span><br><span class="line">      p := cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))</span><br><span class="line">      EP, err = utils.Marshal(p)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> collectionsConfig []<span class="keyword">byte</span></span><br><span class="line">      <span class="comment">// we proceed with a non-nil collection configuration only if we support the PrivateChannelData capability</span></span><br><span class="line">      <span class="comment">// PrivateChannelData， channel内的私有数据</span></span><br><span class="line">      <span class="keyword">if</span> ac.Capabilities().PrivateChannelData() &amp;&amp; <span class="built_in">len</span>(args) &gt; <span class="number">6</span> {</span><br><span class="line">        collectionsConfig = args[<span class="number">6</span>]</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function)</span><br><span class="line">      cdbytes, err := proto.Marshal(cd)</span><br><span class="line">      <span class="keyword">return</span> shim.Success(cdbytes)</span><br><span class="line">  }</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>进入lscc的<code>Invoke</code>方法。回顾instantiate(2)里cis的数据结构<code>"Args" : ["deploy", "${channelId}", "${chaincodDeploySpec}"]</code>,这里的<code>select-case</code>进入<code>DEPLOY,UPGRADE</code>分支。分支里主要是校验以及处理传入参数，包括指定的scc和private data相关，重要的方法是<code>lscc.executeDeployOrUpgrade</code>，传参就是刚获取和校验过的参数。</p>
<p>进入<code>executeDeployOrUpgrade</code>。首先执行<code>lscc.support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion)</code>，获取<code>ccprovider.CCPackage</code>,这是安装阶段执行<code>peer chaincode install</code>命令时打包并且上传到该节点的chaincode定义，放在peer节点本地目录的（这个在install里具体分析其结构）。然后执行<code>lscc.executeDeploy</code>。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// executeDeploy implements the "instantiate" Invoke transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *lifeCycleSysCC)</span> <span class="title">executeDeploy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="params"><span class="function">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="params"><span class="function">	policy []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	escc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	vscc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	cdfs *ccprovider.ChaincodeData,</span></span></span><br><span class="line"><span class="params"><span class="function">	ccpackfs ccprovider.CCPackage,</span></span></span><br><span class="line"><span class="params"><span class="function">	collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> {</span><br><span class="line">  <span class="comment">//just test for existence of the chaincode in the LSCC</span></span><br><span class="line">  chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">  _, err := lscc.getCCInstance(stub, chaincodeName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//retain chaincode specific data and fill channel specific ones</span></span><br><span class="line">  cdfs.Escc = <span class="keyword">string</span>(escc)</span><br><span class="line">  cdfs.Vscc = <span class="keyword">string</span>(vscc)</span><br><span class="line">  cdfs.Policy = policy</span><br><span class="line"></span><br><span class="line">  <span class="comment">// retrieve and evaluate instantiation policy</span></span><br><span class="line">  cdfs.InstantiationPolicy, err = lscc.support.GetInstantiationPolicy(chainname, ccpackfs)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the signed instantiation proposal</span></span><br><span class="line">  signedProp, err := stub.GetSignedProposal()</span><br><span class="line">  err = lscc.support.CheckInstantiationPolicy(signedProp, chainname, cdfs.InstantiationPolicy)</span><br><span class="line"></span><br><span class="line">  err = lscc.putChaincodeData(stub, cdfs)</span><br><span class="line"></span><br><span class="line">  err = lscc.putChaincodeCollectionData(stub, cdfs, collectionConfigBytes)</span><br><span class="line">  <span class="keyword">return</span> cdfs, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里先检查该chaincode是否已经部署过<code>lscc.getCCInstance(stub, chaincodeName)</code>，实际上是调用<code>stub.GetState(ccname)</code>,构建<code>&amp;pb.ChaincodeMessage{Type: pb.ChaincodeMessage_PUT_STATE, Payload: payloadBytes, Txid: txid, ChannelId: channelId}</code>发送到对端<code>chaincode/handler</code>。这里会执行到<code>handler.callPeerWithChaincodeMsg</code>方法。其实里面就是hanlder本身维护着一个名叫responseChannel的<code>map[string]chan pb.ChaincodeMessage</code>, 先创建一个channel放入map中，key是由channelID和txid构造而成，即关联当前请求，在退出方法时使用defer从map中删除这个channle。而在这个过程中，在<code>handler.sendReceive</code>里使用<code>handler.serialSendAsync</code>发送ChaincodeMessage，然后<code>select-case</code>一直等待从channel里读取消息。</p>
<p>相应的，当对端回复消息<code>pb.ChaincodeMessage_RESPONSE</code>，<code>shim/handler</code>会进入<code>fabric/core/chaincode/shim/handler.go:handleReady</code>-&gt;<code>handler.sendChannel(msg)</code>,这里从responseChannel这个map里拿出相应的channel，放入消息。实际上，通过这个实现了异步通信，结合上面提到的每次进入<code>handlerXXX</code>方法都使用goroutine处理而立刻返回，实现了其并发通信。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// callPeerWithChaincodeMsg sends a chaincode message (for e.g., GetState along with the key) to the peer for a given txid and receives the response.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *Handler)</span> <span class="title">callPeerWithChaincodeMsg</span><span class="params">(msg *pb.ChaincodeMessage, channelID, txid <span class="keyword">string</span>)</span> <span class="params">(pb.ChaincodeMessage, error)</span></span> {</span><br><span class="line">    <span class="comment">// Create the channel on which to communicate the response from the peer</span></span><br><span class="line">    <span class="keyword">var</span> respChan <span class="keyword">chan</span> pb.ChaincodeMessage</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> respChan, err = handler.createChannel(channelID, txid); err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">return</span> pb.ChaincodeMessage{}, err</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> handler.deleteChannel(channelID, txid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handler.sendReceive(msg, respChan)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//sends a message and selects</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *Handler)</span> <span class="title">sendReceive</span><span class="params">(msg *pb.ChaincodeMessage, c <span class="keyword">chan</span> pb.ChaincodeMessage)</span> <span class="params">(pb.ChaincodeMessage, error)</span></span> {</span><br><span class="line">    errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> {</span><br><span class="line">      <span class="keyword">select</span> {</span><br><span class="line">      <span class="keyword">case</span> outmsg, val := &lt;-c:</span><br><span class="line">        <span class="keyword">return</span> outmsg, <span class="literal">nil</span></span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *Handler)</span> <span class="title">sendChannel</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="title">error</span></span> {</span><br><span class="line">    handler.Lock()</span><br><span class="line">    <span class="keyword">defer</span> handler.Unlock()</span><br><span class="line">    txCtxID := handler.getTxCtxId(msg.ChannelId, msg.Txid)</span><br><span class="line">    handler.responseChannel[txCtxID] &lt;- *msg</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>chaincode/handler</code>对该类型请求在<code>hanldeMessage</code>里<code>HandleGetState</code>一路判断最后执行<code>res, err = txContext.TXSimulator.GetState(chaincodeName, getState.Key)</code>,从本地账本db获取namespace为lscc，key为${chaincodeName}的数据（最终执行<code>queryHelper.txmgr.db.GetState(ns, key</code>）。在<code>executeDeploy</code>稍后可以看到，执行<code>lscc.putChaincodeData(stub, cdfs)</code>操作时执行相对应的put state操作，即deploy之后会把该chaincode写入peer本地db的lscc的namespace里。因此，通过校验get回来的数据为空来判断该chaincode没有deploy过。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go:40</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *queryHelper)</span> <span class="title">getState</span><span class="params">(ns <span class="keyword">string</span>, key <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> err := h.checkDone(); err != <span class="literal">nil</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    }</span><br><span class="line">    versionedValue, err := h.txmgr.db.GetState(ns, key)</span><br><span class="line">    val, ver := decomposeVersionedValue(versionedValue)</span><br><span class="line">    <span class="keyword">if</span> h.rwsetBuilder != <span class="literal">nil</span> {</span><br><span class="line">      h.rwsetBuilder.AddToReadSet(ns, key, ver)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> val, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/helper.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decomposeVersionedValue</span><span class="params">(versionedValue *statedb.VersionedValue)</span> <span class="params">([]<span class="keyword">byte</span>, *version.Height)</span></span> {</span><br><span class="line">  <span class="keyword">var</span> value []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">var</span> ver *version.Height</span><br><span class="line">    <span class="keyword">if</span> versionedValue != <span class="literal">nil</span> {</span><br><span class="line">      value = versionedValue.Value</span><br><span class="line">      ver = versionedValue.Version</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> value, ver</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// core/ledger/kvledger/txmgmt/rwsetutil/rwset_builder.go</span></span><br><span class="line"><span class="comment">// AddToReadSet adds a key and corresponding version to the read-set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *RWSetBuilder)</span> <span class="title">AddToReadSet</span><span class="params">(ns <span class="keyword">string</span>, key <span class="keyword">string</span>, version *version.Height)</span></span> {</span><br><span class="line">    nsPubRwBuilder := b.getOrCreateNsPubRwBuilder(ns)</span><br><span class="line">    nsPubRwBuilder.readMap[key] = NewKVRead(key, version)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从上面看出，账本的value是<code>statedb.VersionedValue</code>结构，包含value和version(结构为<code>*version.Height{BlockNum uint64, TxNum uint64}</code>)。获取的结果加入<code>readSet</code>,其中参数（namesapce：lscc，key：${chaincodeName}, ver: 版本）</p>
<p>然后获取并检查部署策略<code>lscc.support.CheckInstantiationPolicy</code>。然后执行<code>lscc.putChaincodeData(stub, cdfs)</code>，调用的是<code>stub.PutState(cd.Name, cdbytes)</code>。入参是chaincode.Name和<code>ccprovider.ChaincodeData</code>序列化字节，这个是通过从本地存储的codepackage和刚刚传入的escc，vscc等参数构建成的。向对端<code>chaincode/handler</code>发送<code>pb.ChaincodeMessage_PUT_STATE</code>。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//-------- ChaincodeData is stored on the LSCC -------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeData defines the datastructure for chaincodes to be serialized by proto</span></span><br><span class="line"><span class="comment">// Type provides an additional check by directing to use a specific package after instantiation</span></span><br><span class="line"><span class="comment">// Data is Type specifc (see CDSPackage and SignedCDSPackage)</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeData <span class="keyword">struct</span> {</span><br><span class="line">    <span class="comment">// Name of the chaincode</span></span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`protobuf:"bytes,1,opt,name=name"`</span></span><br><span class="line">    Version <span class="keyword">string</span> <span class="string">`protobuf:"bytes,2,opt,name=version"`</span></span><br><span class="line">    Escc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,3,opt,name=escc"`</span></span><br><span class="line">    Vscc <span class="keyword">string</span> <span class="string">`protobuf:"bytes,4,opt,name=vscc"`</span></span><br><span class="line">    <span class="comment">// Policy endorsement policy for the chaincode instance</span></span><br><span class="line">    Policy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,5,opt,name=policy,proto3"`</span></span><br><span class="line">    <span class="comment">// Data data specific to the package</span></span><br><span class="line">    Data []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,6,opt,name=data,proto3"`</span></span><br><span class="line">    <span class="comment">// Id of the chaincode that's the unique fingerprint for the CC This is not currently used anywhere but serves as a good eyecatcher </span></span><br><span class="line">    Id []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,7,opt,name=id,proto3"`</span></span><br><span class="line">    <span class="comment">// InstantiationPolicy for the chaincode</span></span><br><span class="line">    InstantiationPolicy []<span class="keyword">byte</span> <span class="string">`protobuf:"bytes,8,opt,name=instantiation_policy,proto3"`</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>数据分为普通channle公开信息和private消息，这里只讨论前者。相应的，对端<code>chaincode/handler</code>在<code>hanldeMessage</code>里<code>HandlePutState</code>一路判断最后执行<code>res, err = txContext.TXSimulator.SetState(chaincodeName, putState.Key, putState.Value)</code>.跟上面区别的是，这里在<code>ockbased_tx_simulator.go</code>文件里，清楚指明这是模拟交易。同时，只把(namespace:lscc, key:${chaincode.Name}, value:${ChaincodeData}序列化字节）的组合加入到writeSet内，然后就返回结果<code>ChaincodeMessage_RESPONSE</code>或者错误消息    <code>ChaincodeMessage_ERROR</code>，并没有真正作用于账本db。同时，没有指定version，这个是在orderer排序打包时添加的。关于这里的read-write set，可以参考官网概念<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/readwrite.html">Read-Write set semantics</a>。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// core/ledger/kvledger/txmgmt/txmgr/lockbasedtxmgr/lockbased_tx_simulator.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *lockBasedTxSimulator)</span> <span class="title">SetState</span><span class="params">(ns <span class="keyword">string</span>, key <span class="keyword">string</span>, value []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">  err := s.helper.checkDone()</span><br><span class="line">  err := s.checkBeforeWrite()</span><br><span class="line">  err := s.helper.txmgr.db.ValidateKeyValue(key, value)</span><br><span class="line">  s.rwsetBuilder.AddToWriteSet(ns, key, value)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后列举下Invoke lscc后从<code>shim/handler</code>返回到<code>chaincode/handler</code>的数据结构<code>pb.ChaincodeMessage</code><br></p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// pb.ChaincodeMessage</span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Type"</span>: pb.ChaincodeMessage_COMPLETED, </span><br><span class="line">  <span class="attr">"Payload"</span>: ${pb.Response}.byte[], </span><br><span class="line">  <span class="attr">"Txid"</span>: ${msg.Txid}, </span><br><span class="line">  <span class="attr">"ChaincodeEvent"</span>: ${pb.chaincodeEvent}, <span class="comment">// nil </span></span><br><span class="line">  <span class="attr">"ChannelId"</span>: ${stub.ChannelId}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pb.Response </span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Status"</span>:  <span class="number">200</span>, <span class="comment">// ok</span></span><br><span class="line">  <span class="attr">"Payload"</span>: ${ChaincodeData}.byte[]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// pb.ChaincodeData </span></span><br><span class="line">{</span><br><span class="line">  <span class="attr">"Name"</span>: ${application chaincode.name}, <span class="comment">// CDSPackage.depSpec.ChaincodeSpec.ChaincodeId.Name, 同“Data”</span></span><br><span class="line">  <span class="attr">"Version"</span>: {application chaincode.version}, <span class="comment">// CDSPackage.depSpec.ChaincodeSpec.ChaincodeId.Version, 同“Data”</span></span><br><span class="line">  <span class="attr">"Escc"</span>: <span class="string">"escc"</span>,</span><br><span class="line">  <span class="attr">"Vscc"</span>: <span class="string">"vscc"</span>,</span><br><span class="line">  <span class="attr">"Policy"</span>: ${cb.SignaturePolicyEnvelope}.byte[], <span class="comment">// endorsement policy, 来源于lscc.go#Invoke, cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))</span></span><br><span class="line">  <span class="attr">"Data"</span>: ,  <span class="comment">// CDSPackage.datab, 执行lscc.support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion).GetChaincodeData()，来源于install chaincode打包构建的fabric/core/common/ccprovider/ccprovider.go:GetCCPackage</span></span><br><span class="line">  <span class="attr">"Id"</span>: , <span class="comment">// CDSPackage.id, 同“Data”</span></span><br><span class="line">  <span class="attr">"InstantiationPolicy"</span>: ${InstantiationPolicy}.byte[] <span class="comment">// 来源于lscc.go#executeDeploy, lscc.support.GetInstantiationPolicy(chainname, ccpackfs)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<hr>
<p>这里继续直接看acc的<code>Init</code>，之前的步骤与lscc完全一致，可以参考上节。Tutorial里的例子的chaincode代码在<code>github.com/hyperledger/fabric/examples/chaincode/go/example02/chaincode.go</code>,里面的Init方法主要是读入参数，然后调用<code>stub.PutState</code>后返回success。细节如上，不再复述。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(5）system chaincode的初始化</title>
    <url>//articles/fabric-source-chaincode-instantiate-system-chaincode/</url>
    <content><![CDATA[<p>接下来分析lscc的执行过程，在这之前，先看下其初始化注册过程。在<code>peer/node/start.go#Serve</code>里<code>registerChaincodeSupport(ccSrv, ccEndpoint, ca, aclProvider)</code>。进入方法，主要是<code>scc.CreateSysCCs(ccp, sccp, aclProvider)</code>，就是引入了<code>scc/importsysccs.go#builtInSystemChaincodes</code>里定义的SCC,即<code>cscc</code>,<code>lscc</code>和<code>gscc</code>（包含chaincode的Name，Path代码地址，Chaincode对象，acl，policy等）。然后逐个执行<code>sccp.RegisterSysCC(cc)</code>注册SCC,实际上就是加入<code>SystemChaincodeProvider.Registrar.typeRegistry</code>（map[string]*inprocContainer）里，key是chaincode的Name，这个后面初始化时候会使用到。</p>
<p>这里完成注册后，在<code>serve()</code>里稍后的位置执行<code>sccp.DeploySysCCs("", ccp)</code>进行部署。第一个参数是channelId为“”，说明这些scc是chainless的，可以供所有的channel使用。进入方法，首先构造cds<code>&amp;pb.ChaincodeDeploymentSpec{ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec}</code>.这里注意到，部署类型是ChaincodeDeploymentSpec_SYSTEM，回顾上节acc类型是ChaincodeDeploymentSpec_DOCKER，说明SCC是部署在peer内的，而acc是部署在另外新的chaincode docker容器里。然后执行<code>ccprov.Execute(ctxt, cccid, chaincodeDeploymentSpec)</code>,最终实际上又回到前面介绍过的<code>ChaincodeSupport.Execute</code>方法上。后面的执行与acc是一致的，所区别的在于launch。区别于acc使用的是<code>dockercontroller/DockerVM#start</code>,scc使用的是<code>inproccontroller.InprocVM#start</code>.首先<code>vm.registry.typeRegistry[path]</code>,这个在前面已经注册了可以获取出来。然后开始真正的launch。</p>
<span id="more"></span>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipc *inprocContainer)</span> <span class="title">launchInProc</span><span class="params">(ctxt context.Context, id <span class="keyword">string</span>, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, ccSupport ccintf.CCSupport)</span> <span class="title">error</span></span> {</span><br><span class="line">    peerRcvCCSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">    ccRcvPeerSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">    ccchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">1</span>)</span><br><span class="line">    ccsupportchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>{}, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(ccchan)</span><br><span class="line">        err := shim.StartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(ccsupportchan)</span><br><span class="line">        inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)</span><br><span class="line">        err := ccSupport.HandleChaincodeStream(ctxt, inprocStream)</span><br><span class="line">    }()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> &lt;-ccchan:</span><br><span class="line">        <span class="built_in">close</span>(peerRcvCCSend)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ccsupportchan:</span><br><span class="line">        <span class="built_in">close</span>(ccRcvPeerSend)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ipc.stopChan:</span><br><span class="line">        <span class="built_in">close</span>(ccRcvPeerSend)</span><br><span class="line">        <span class="built_in">close</span>(peerRcvCCSend)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// StartInProc is an entry point for system chaincodes bootstrap. It is not an API for chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInProc</span><span class="params">(env []<span class="keyword">string</span>, args []<span class="keyword">string</span>, cc Chaincode, recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> <span class="title">error</span></span> {</span><br><span class="line">    stream := newInProcStream(recv, send)</span><br><span class="line">    err := chatWithPeer(chaincodename, stream, cc)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> inProcStream <span class="keyword">struct</span> {</span><br><span class="line">    recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage</span><br><span class="line">    send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里主要有两个goroutine，分别处理chaincode shim和peer的handle stream。同时，有两个channel，<code>peerRcvCCSend</code>,<code>ccRcvPeerSend</code>,可以从名字判断出消息的流向。</p>
<p>启动第一个goroutine<code>shim.StartInProc</code>,向<code>chaincodeSupport</code>发送注册。用于这里的<code>chatWithPeer</code>跟acc介绍的是同一个都在<code>chaincode.go</code>下，在这里面构造了该scc的handler（设置<code>inProcStream</code>这个stream）发送了<code>&amp;pb.ChaincodeMessage{Type: pb.ChaincodeMessage_REGISTER, Payload: payload})</code>这个消息。这个类比于acc里在chaincode容器的handler。</p>
<p>启动第二个goroutine<code>ccSupport.HandleChaincodeStream(ctxt, inprocStream)</code>，用于处理注册请求，这个类比于acc里的peer的handler，所不同的是，acc里的stream是grpc server stream，是由grpc server构建的，而这里则是封装了<code>peerRcvCCSend</code>,<code>ccRcvPeerSend</code>这两个channel。总而言之，在acc内，新chaincode容器内通过grpc方式与peer通信，而scc由于都处在同一个peer容器内，是通过go channel的方法实现。其他的主要流程都是一致的。</p>
<p>第三部分的<code>select-case</code>则是在处理chaincode退出的情况。这个方法在外层<code>InprocVM#Start</code>是go routine启动的，最外层等待的是<code>select-case</code>等待<code>launchState.Done()</code>channel的返回，这个跟acc是一致的。</p>
<p>一路返回到<code>core/chaincode/chaincode_support.go#Invoke</code>方法，在执行完<code>Launch</code>后，最后执行<code>ChaincodeSupport#execute</code>.在前面instantiate（3）里介绍过execute方法，这里直接看发送的<code>ChaincodeMessage</code>。在<code>chaincode_support.go#Invoke</code>里指定部署<code>ChaincodeDeploymentSpec</code>的<code>ChaincodeMessage_Type</code>为<code>pb.ChaincodeMessage_INIT</code>,由<code>chaincode/handler.go#serialSendAsync</code>,对端的<code>shim/handler.go#handleMessage</code>。前面初始化完成后，两端handler状态都为ready，<code>select-case</code>进入<code>hanlder.state=ready</code>,<code>ChaincodeMessageType=ChaincodeMessage_INIT</code>执行到<code>#handleInit</code>.<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler *Handler)</span> <span class="title">handleInit</span><span class="params">(msg *pb.ChaincodeMessage, errc <span class="keyword">chan</span> error)</span></span> {</span><br><span class="line">    <span class="comment">// The defer followed by triggering a go routine dance is needed to ensure that the previous state transition</span></span><br><span class="line">    <span class="comment">// is completed before the next one is triggered. The previous state transition is deemed complete only when</span></span><br><span class="line">    <span class="comment">// the beforeInit function is exited. Interesting bug fix!!</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">var</span> nextStateMsg *pb.ChaincodeMessage</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">            handler.triggerNextState(nextStateMsg, errc)</span><br><span class="line">        }()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Call chaincode's Run</span></span><br><span class="line">        <span class="comment">// Create the ChaincodeStub which the chaincode can use to callback</span></span><br><span class="line">        <span class="comment">// 用传入的数据初始化stub</span></span><br><span class="line">        stub := <span class="built_in">new</span>(ChaincodeStub)</span><br><span class="line">        err := stub.init(handler, msg.ChannelId, msg.Txid, input, msg.Proposal)</span><br><span class="line"></span><br><span class="line">        res := handler.cc.Init(stub)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send COMPLETED message to chaincode support and change state</span></span><br><span class="line">        nextStateMsg = &amp;pb.ChaincodeMessage{Type: pb.ChaincodeMessage_COMPLETED, Payload: resBytes, Txid: msg.Txid, ChaincodeEvent: stub.chaincodeEvent, ChannelId: stub.ChannelId}</span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># github.com/hyperledger/fabric/core/scc/lscc</span><br><span class="line"><span class="comment">//Init is mostly useless for SCC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *lifeCycleSysCC)</span> <span class="title">Init</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> {</span><br><span class="line">	<span class="keyword">return</span> shim.Success(<span class="literal">nil</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>在这里，主要是<code>stub.init</code>构建stub，这个桩的概念在远程调用里常见。然后执行<code>handler.cc.Init(stub)</code>。这里看<code>lscc.go#Init</code>.对于lscc(大多数scc)来说，初始化并不需要进行特殊处理，因此这里只是简单返回<code>shim.Success</code>的resp.在<code>handleInit</code>里，<code>defer func</code>将结果返回，这里如果执行成功，返回<code>pb.ChaincodeMessage_COMPLETED</code>，否则返回<code>pb.ChaincodeMessage_ERROR</code>.同样的，在<code>chaincode/handler.go#handleMessage</code>里对<code>pb.ChaincodeMessage_COMPLETED, pb.ChaincodeMessage_ERROR</code>这两个调用chaincode shim的回复消息调用<code>handler.Notify(msg)</code>，即<code>tctx.ResponseNotifier &lt;- msg</code>.这个在前面的instantiate(3)小节提过，异步调用的错误以及结果都发送到txctx.ResponseNotifie这个chan内再做后续的处理。至此，完成lscc的初始化和注册，后面再介绍acc的初始化的rpc过程。<p></p>
<blockquote>
<p>命名缩写参考<br>cc : chaincode<br>scc : system chaincode<br>ccp, ccprov : chaincode provider<br>sccp : system chaincode provider<br>cccid : ccprovider.CCContext</p>
</blockquote>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(4）chaincode容器启动及注册</title>
    <url>//articles/fabric-source-chaincode-instantiate-chaincode-launch/</url>
    <content><![CDATA[<p>接下来回到容器启动后在容器中初始化和注册chaincode。在上一节构建docker里提到，容器的启动命令（指默认语言或者显式设置语言-l golang）为<code>lc.Args = []string{"chaincode", fmt.Sprintf("-peer.address=%s", c.PeerAddress)}</code>。在构建容器时<code>fabric/core/chaincode/platforms/golang/platform.go#GenerateDockerBuild</code>，指定了构建参数<code>DockerBuildOptions</code></p>
<pre><code class="lang-go">util.DockerBuildOptions{
  Cmd:          fmt.Sprintf("GOPATH=/chaincode/input:$GOPATH go build -tags \"%s\" %s -o /chaincode/output/chaincode %s", gotags, ldflagsOpt, pkgname),
  InputStream:  codepackage,
  OutputStream: binpackage,
}
</code></pre>
<p>这里指的是，将<code>pkgname</code>(spec.ChaincodeId.Path)指定的chaincode代码运行<code>go build -o chaincode</code>打包成名为<code>chaincode</code>的可执行文件。因此容器启动时，实际上调用了install的chaincode代码里的main方法，这也是分析的入口。在<a href="https://hyperledger-fabric.readthedocs.io/en/latest/build_network.html">Building Your First Network</a>官方教程，在fabric-samples/first-network/scripts的<code>scripts.sh</code>和<code>utils.sh</code>里找到install chaincode路径为<code>${CC_SRC_PATH}</code>,在<code>scripts.sh</code>里可以得到<code>CC_SRC_PATH="github.com/chaincode/chaincode_example02/go/"</code>. 该目录下<code>chaincode_example02.go</code>的main方法<code>err := shim.Start(new(SimpleChaincode))</code>启动。进入到<code>chaincode.Start(cc Chaincode)</code>方法</p>
<span id="more"></span>
<ol>
<li><code>SetupChaincodeLogging()</code>设置日志相关</li>
<li>获取变量chaincode名称<code>viper.GetString("chaincode.id.name")</code>。回顾上节在创建chaincode容器时在<code>container_runtime.go</code>设置了变量<code>append(c.CommonEnv, "CORE_CHAINCODE_ID_NAME="+cname)</code>。</li>
<li><code>factory.InitFactories(factory.GetDefaultOpts())</code>初始化BCCSP（blockchain crypto service）服务。待详述。</li>
<li><code>userChaincodeStreamGetter</code>构建与peer节点的grpc client。首先，获取<code>peerAddress</code>,这个在<code>container_runtime.go</code>设置了flag启动参数<code>-peer.address</code>，即endorser的peerAddress。然后，与该peer建立连接，构造<code>/protos.ChaincodeSupport/Register</code>的grpc stream。</li>
<li><code>chatWithPeer(chaincodename string, stream PeerChaincodeStream, cc Chaincode)</code>.新建<code>handler := newChaincodeHandler(stream, cc)</code>，（这里是shim/handler.go），这时候<code>handler.state = created</code>。这是在chaincode容器里的，与之相对的，在peer容器里也有<code>handler</code>，对等处理. 然后<code>handler.serialSend(&amp;pb.ChaincodeMessage{Type: pb.ChaincodeMessage_REGISTER, Payload: payload});</code>这里payload是<code>&amp;pb.ChaincodeID{Name: chaincodename}</code>。将注册信息发送到peer节点后，启动goroutine。这个goroutine里是for循环，每次循环都新启动一个子goroutine，这个子go routine负责从stream里接受一条消息，放到两个channel（msgAvail, errc）里。<code>msgAvail, errc = stream.Recv()</code>，接收完一条即完成子goroutine的生命周期，下次循环再另起一个。父goroutine读取这两个channel，对接收到的消息msgAvail，则调用<code>handler.handleMessage(in, errc)</code>处理。最外层<code>waitC</code>等待终止信号，期间包含定期发送的<code>pb.ChaincodeMessage_KEEPALIVE</code>，直到遇到接收错误等才终止通信stream，返回异常。</li>
</ol>
<p>再看peer端的对等handler注册。（这里是chaincode/handler.go）这部分在<code>peer node start</code>启动时候执行，注册<code>pb.ChaincodeSupportServer(chaincodeSupport)</code>。每次收到shim/handler的register方法意味着新的<code>Register(&amp;chaincodeSupportRegisterServer{stream}</code>,一路下去在<code>fabric/core/chaincode/chaincode_support#HandleChaincodeStream</code>里新建<code>chaincode/handler</code>，handler.state没有显式设置则为0值，即Created。然后进入主要方法<code>chaincode/handler.ProcessStream</code>。这方法流程跟上面的<code>chatWithPeer</code>非常相似，多了主动发起KeepAlive，以及在异常退出时取消注册hanlder。这也就意味着，chaincode容器与peer容器始终建立连接。hanlder从steam里读取message，然后<code>handleMessage</code>。这里实际上也就是在<code>Handler.Registry（即ChaincodeSupport.HandlerRegistry)</code>里注册该hanlder，跟上节从registry里通过chaincode.cname查找hanlder呼应。此外，在这个处理过程中，peer相应的改变registry里handler的状态，给chaincode容器回复<code>&amp;pb.ChaincodeMessage{Type: pb.ChaincodeMessage_REGISTERED}</code>。然后，handler置成established状态，对端的handler收到pb.ChaincodeMessage_REGISTERED，也将状态置为established。</p>
<p>chaincode/handler在置成established状态后马上执行<code>notifyRegistry</code>，这里主要两件事情，1.发送pb.ChaincodeMessage_READY，并且状态改为ready；2. 通知HandlerRegistry已完成注册（即从launching里delete当前chaincodename，关闭LaunchState.done channel可以判断以完成注册，这样，在<code>core/chaincode/runtime_launcher.go#start</code>里的<code>select {case &lt;-launchState.Done():</code>可以继续往下走，因为这里调用的<code>RuntimeLauncher.Runtime.Start</code>是通过goroutine异步启动的），这里与上节介绍启动时注册aunching防止重复部署对应。对端收到通知后，也置状态为ready。至此完成了chaincode的启动工作，后续两端handler进入处理Init／Invoke请求流程。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(3）endorser的propocessProposal主过程</title>
    <url>//articles/fabric-source-chaincode-instantiate-endorser-process-proposal/</url>
    <content><![CDATA[<p>由peer的grpc请求到<code>/protos.Endorser/ProcessProposal</code>，在endorser里对应着<code>protos/peer/peer.pb.go#_Endorser_ProcessProposal_Handler</code>，进入处理方法<code>core/endorser/endorser.go#ProcessProposal</code>。endorser的处理过程主要分为三个阶段，preProcess, simulate和endorse。其中，preProcess主要做校验工作，包括数据结构的完整性(header)，唯一性防止重放攻击，校验签名，对application chaincode（以后简称acc）检查ACL策略等等。这部分校验比较直观和简单，这里不做深入分析。需要注意的是，在这里还获取了TX模拟器<code>txsim, err = e.s.GetTxSimulator(chainID, txid);</code>和历史请求执行器<code>historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID);</code>。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line"><span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line"><span class="comment">// by way of the supplied txid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">GetTxSimulator</span><span class="params">(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> {</span><br><span class="line">    lgr := s.Peer.GetLedger(ledgername)</span><br><span class="line">    <span class="keyword">return</span> lgr.NewTxSimulator(txid)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator implements method in interface `txmgmt.TxMgr`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txmgr *LockBasedTxMgr)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> {</span><br><span class="line">    s, err := newLockBasedTxSimulator(txmgr, txid)</span><br><span class="line">    txmgr.commitRWLock.RLock()</span><br><span class="line">    <span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>这个模拟器和执行器是对应于账本ledger的，也就是channel，入参ledgername就是channelId。chainless的proposals的ledger.TxSimulator和ledger.HistoryQueryExecutor都是nil。模拟器是基于锁的，在生成模拟器时，同时加上了读锁，在下一阶段simulate结束后就立即释放。同时，也生成了历史数据查询器。关于这个锁，代码里有下面一段解释。<p></p>
<blockquote>
<p>txsim acquires a shared lock on the stateDB. As this would impact the block commits (i.e., commit of valid write-sets to the stateDB), we must release the lock as early as possible. Hence, this txsim object is closed in simulateProposal() as soon as the tx is simulated and rwset is collected before gossip dissemination if required for privateData. </p>
</blockquote>
<span id="more"></span>
<p>接下来主要分析simulate过程。在<code>endorser.SimulateProposal</code>这个方法中，可以看到存在多处对当前chaincode是否System chaincode系统链码的判断。（注意，当前请求channel是lscc）在当前篇幅里主要分析instantiate的过程，其他的判断分支以后再详述。在<code>SimulateProposal</code>里，首先判断当前是否是scc，这里是lscc，进入分支获取<code>util.GetSysCCVersion()</code>，scc的版本固定为string常量‘latest’.<br>整个流程方法调用顺序为<code>SimulateProposal</code>-&gt;<code>endorser.callChaincode</code>-&gt;<code>endorser.support.Execute</code>-&gt;<code>endorser.support.ChaincodeSupport.Execute</code>-&gt;<code>ChaincodeSupport.Invoke</code>-&gt;<code>ChaincodeSupport.execute</code>-&gt;<code>cs.HandlerRegistry.Handler(cname).Execute</code><br>在这里，首先关键方法是<code>e.callChaincode</code><br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">/ call specified chaincode (system or user)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">callChaincode</span><span class="params">(ctxt context.Context, chainID <span class="keyword">string</span>, version <span class="keyword">string</span>, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, prop *pb.Proposal, cis *pb.ChaincodeInvocationSpec, cid *pb.ChaincodeID, txsim ledger.TxSimulator)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> {</span><br><span class="line">    ctxt = context.WithValue(ctxt, chaincode.TXSimulatorKey, txsim)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is this a system chaincode</span></span><br><span class="line">    scc := e.s.IsSysCC(cid.Name)</span><br><span class="line">    res, ccevent, err = e.s.Execute(ctxt, chainID, cid.Name, version, txid, scc, signedProp, prop, cis)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----- BEGIN -  SECTION THAT MAY NEED TO BE DONE IN LSCC ------</span></span><br><span class="line">    <span class="comment">// if this a call to deploy a chaincode, We need a mechanism</span></span><br><span class="line">    <span class="comment">// to pass TxSimulator into LSCC. Till that is worked out this</span></span><br><span class="line">    <span class="comment">// special code does the actual deploy, upgrade here so as to collect</span></span><br><span class="line">    <span class="comment">// all state under one TxSimulator</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NOTE that if there's an error all simulation, including the chaincode table changes in lscc will be thrown away</span></span><br><span class="line">    <span class="keyword">if</span> cid.Name == <span class="string">"lscc"</span> &amp;&amp; <span class="built_in">len</span>(cis.ChaincodeSpec.Input.Args) &gt;= <span class="number">3</span> &amp;&amp; (<span class="keyword">string</span>(cis.ChaincodeSpec.Input.Args[<span class="number">0</span>]) == <span class="string">"deploy"</span> || <span class="keyword">string</span>(cis.ChaincodeSpec.Input.Args[<span class="number">0</span>]) == <span class="string">"upgrade"</span>) {</span><br><span class="line">        userCDS, err := putils.GetChaincodeDeploymentSpec(cis.ChaincodeSpec.Input.Args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this should not be a system chaincode</span></span><br><span class="line"></span><br><span class="line">        _, _, err = e.s.Execute(ctxt, chainID, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, txid, <span class="literal">false</span>, signedProp, prop, cds)</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ----- END -------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res, ccevent, err</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>此处将模拟器<code>txsim</code>加入context。此处存在两次调用<code>endorser.support.Execute</code>.第一次调用的是外层的<code>ChaincodeInvokeSpec</code>cis。在<code>endorser.support.Execute</code>里先构建<code>ccprovider.NewCCContext</code>（cccid），这里的<code>cccid.canonicalName</code>设置为<code>name + ":" + version</code>，即lscc:latest。然后获取系统定义的<code>decorator</code>，这个是在node启动时<code>peer/node.go#Serve</code>里初始化的，从配置文件<code>core.yaml</code>里读取配置。配置文件里的定义:”append or mutate the chaincode input passed to the chaincode”. <code>library: /opt/lib/decorator.so</code>。这里将decorator作用于此cis。下一步就是调用<code>ChaincodeSupport.Execute</code>。<br><code>ChaincodeSupport.Execute</code>先执行<code>ChaincodeSupport.Invoke</code>。在invoke方法里，先执行<code>cs.Launch(ctxt, cccid, spec)</code>。这里执行的chaincode是lscc，系统链码已经在启动阶段launch状态为running了，这个在后面会说到，因此直接返回到<code>ChaincodeSupport.Invoke</code>。然后用<code>chaincodeSpec.Input</code>(这里其实是<code>["deploy", "${channelId}", "${chaincodDeploySpec}"]</code>)构建<code>pb.ChaincodeMessage</code>，进入到<code>Chaincode.execute</code>方法执行<code>cs.execute(ctxt, cccid, ccMsg)</code>。这里的<code>pb.ChaincodeMessage</code>类型为<code>pb.ChaincodeMessage_TRANSACTION</code>(cis).<p></p>
<blockquote>
<p>Launch starts executing chaincode if it is not already running. This method blocks until the peer side handler gets into ready state or encounters a fatal error. If the chaincode is already running, it simply returns.  </p>
</blockquote>
<p>下面是三个入参的结构<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line">ctx = context.WithValue(ctx, chaincode.HistoryQueryExecutorKey, historyQueryExecutor)</span><br><span class="line">ctxt = context.WithValue(ctxt, chaincode.TXSimulatorKey, txsim)</span><br><span class="line"></span><br><span class="line">cccid := &amp;CCContext{</span><br><span class="line">    ChainID:             cname,		<span class="comment">// channelID</span></span><br><span class="line">    Name:                name,		<span class="comment">// ChaincodeID.name (lscc)</span></span><br><span class="line">    Version:             version,	<span class="comment">// metadata.Version (latest)</span></span><br><span class="line">    TxID:                txid,	</span><br><span class="line">    Syscc:               syscc,		<span class="comment">// is this a system chaincode (true)</span></span><br><span class="line">    SignedProposal:      signedProp,	</span><br><span class="line">    Proposal:            prop,		</span><br><span class="line">    canonicalName:       name + <span class="string">":"</span> + version,</span><br><span class="line">    ProposalDecorations: <span class="literal">nil</span>,		</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ccmsg := &amp;pb.ChaincodeMessage{</span><br><span class="line">    Type:      messageType,		<span class="comment">// pb.ChaincodeMessage_TRANSACTION</span></span><br><span class="line">    Payload:   payload,		<span class="comment">// chaincodeSpec.Input (cis.cs.Input)</span></span><br><span class="line">    Txid:      txid,</span><br><span class="line">    ChannelId: cid,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>在<code>ChaincodeSupport.execute</code>先判断处理当前chaincode（根据canonicalName区分,lscc:latest）的handler是否已经注册，这个handler注册的过程后面介绍。然后获取这个handler执行。<br><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Execute</span><span class="params">(ctxt context.Context, cccid *ccprovider.CCContext, msg *pb.ChaincodeMessage, timeout time.Duration)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> {</span><br><span class="line">    txctx, err := h.TXContexts.Create(ctxt, msg.ChannelId, msg.Txid, cccid.SignedProposal, cccid.Proposal)</span><br><span class="line">    <span class="keyword">defer</span> h.TXContexts.Delete(msg.ChannelId, msg.Txid)</span><br><span class="line"></span><br><span class="line">    h.setChaincodeProposal(cccid.SignedProposal, cccid.Proposal, msg)</span><br><span class="line"></span><br><span class="line">    h.serialSendAsync(msg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> ccresp *pb.ChaincodeMessage</span><br><span class="line">    <span class="keyword">select</span> {</span><br><span class="line">    <span class="keyword">case</span> ccresp = &lt;-txctx.ResponseNotifier:</span><br><span class="line">        <span class="comment">// response is sent to user or calling chaincode. ChaincodeMessage_ERROR are typically treated as error</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">        err = errors.New(<span class="string">"timeout expired while executing transaction"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ccresp, err</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// serialSendAsync serves the same purpose as serialSend (serialize msgs so gRPC will be happy). In addition, it is also asynchronous so send-remoterecv--localrecv loop can be nonblocking. Only errors need to be handled and these are handled by communication on supplied error channel. A typical use will be a non-blocking or nil channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">serialSendAsync</span><span class="params">(msg *pb.ChaincodeMessage, sendErr <span class="keyword">bool</span>)</span></span> {</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">if</span> err := h.serialSend(msg); err != <span class="literal">nil</span> {</span><br><span class="line">            <span class="keyword">if</span> sendErr {</span><br><span class="line">                <span class="comment">// provide an error response to the caller</span></span><br><span class="line">                h.Notify(resp)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Notify</span><span class="params">(msg *pb.ChaincodeMessage)</span></span> {</span><br><span class="line">	tctx := h.TXContexts.Get(msg.ChannelId, msg.Txid)</span><br><span class="line">	tctx.ResponseNotifier &lt;- msg</span><br><span class="line">	tctx.CloseQueryIterators()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// serialSend serializes msgs so gRPC will be happy</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">serialSend</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="title">error</span></span> {</span><br><span class="line">	h.serialLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> h.serialLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := h.chatStream.Send(msg); err != <span class="literal">nil</span> {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<ol>
<li>构造<code>TransactionContext</code>,其中有个参数为<code>ResponseNotifier: make(chan *pb.ChaincodeMessage, 1),</code>用以异步执行时接收结果。构造前先判断channelID和txId的组合是否已存在，构造过程加锁，避免重复处理。</li>
<li><code>core/chaincode/handler.go#serialSendAsync</code>异步处理，实际上即启用go routine调用<code>handler#serialSend</code>，使用handler.chatStream发送，此处也是grpc调用。错误以及结果都发送到<code>txctx.ResponseNotifie</code>这个chan内(rpc结果通过调用<code>handler#Notify</code>)。由于是异步调用，函数立即返回，处理结果在外层<code>handler.Execute</code>等待从这个chan读取数据，这里也加上了超时的机制。这里的lscc的调用后面再分析。</li>
</ol>
<p>如果这里调用一切正常，流程将退回到<code>callChaincode</code>继续往下走,然后满足“lscc”，参数为“deploy”的条件，所以从cis里的Input参数获取cds并反序列化成<code>ChaincodeDeploymentSpec</code>对象，重复刚才的步骤。这里稍微有些不同的是，这里的<code>pb.ChaincodeMessage</code>类型为<code>pb.ChaincodeMessage_INIT</code>(cds)，并且这个用户自定义的application chaincode需要launch。<br></p><figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Launch starts executing chaincode if it is not already running. This method</span></span><br><span class="line"><span class="comment">// blocks until the peer side handler gets into ready state or encounters a fatal</span></span><br><span class="line"><span class="comment">// error. If the chaincode is already running, it simply returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Launch</span><span class="params">(ctx context.Context, cccid *ccprovider.CCContext, spec ccprovider.ChaincodeSpecGetter)</span> <span class="title">error</span></span> {</span><br><span class="line">    cname := cccid.GetCanonicalName()</span><br><span class="line">    <span class="keyword">if</span> cs.HandlerRegistry.Handler(cname) != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// UserRunsCC值一直回溯到 node.start#registerChaincodeSupport 里的 userRunsCC := chaincode.IsDevMode()</span></span><br><span class="line">    <span class="comment">// 这个值实际上是配置文件 core.yaml 里的 peer.mode : net，配置文件的描述如下</span></span><br><span class="line">    <span class="comment">//  # In dev mode, user runs the chaincode after starting peer from command line on local machine.</span></span><br><span class="line">    <span class="comment">//  # In net mode, peer will run chaincode in a docker container.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cs.UserRunsCC &amp;&amp; !cccid.Syscc {</span><br><span class="line">        chaincodeLogger.Error(</span><br><span class="line">            <span class="string">"You are attempting to perform an action other than Deploy on Chaincode that is not ready and you are in developer mode."</span>,</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The only user of this context value is the in-process controller used to support system chaincode. </span></span><br><span class="line">    <span class="comment">// context加入“CCHANDLER” : ChaincodeSupport</span></span><br><span class="line">    ctx = context.WithValue(ctx, ccintf.GetCCHandlerKey(), cs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cs.Launcher.Launch(ctx, cccid, spec)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// core/chaincode/runtime_launcher.go</span></span><br><span class="line"><span class="comment">// Launch chaincode with the appropriate runtime.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RuntimeLauncher)</span> <span class="title">Launch</span><span class="params">(ctx context.Context, cccid *ccprovider.CCContext, spec ccprovider.ChaincodeSpecGetter)</span> <span class="title">error</span></span> {</span><br><span class="line">    chaincodeID := spec.GetChaincodeSpec().ChaincodeId</span><br><span class="line">    cds, _ := spec.(*pb.ChaincodeDeploymentSpec)</span><br><span class="line">    <span class="keyword">if</span> cds == <span class="literal">nil</span> {</span><br><span class="line">        cds, err = r.getDeploymentSpec(ctx, cccid, chaincodeID)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cds.CodePackage == <span class="literal">nil</span> &amp;&amp; cds.ExecEnv != pb.ChaincodeDeploymentSpec_SYSTEM {</span><br><span class="line">        ccpack, err := r.PackageProvider.GetChaincode(chaincodeID.Name, chaincodeID.Version)</span><br><span class="line">        cds = ccpack.GetDepSpec()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err := r.start(ctx, cccid, cds)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><br>这里需要部署chaincode需要代码code，在instantiate的cds里参数<code>CodePackage</code>为nil,同时<code>ExecEnv</code>=<code>pb.ChaincodeDeploymentSpec_DOCKER</code>。这里是通过<code>r.PackageProvider.GetChaincode(chaincodeID.Name, chaincodeID.Version)</code>获取具体的代码，实际上是<code>core/common/ccprovider/ccprovider.go#GetChaincodeFromPath</code>从本地路径获取，而这些code是在<code>peer chaincode install</code>时由lscc放到本地目录下，在<code>instantiate</code>时按照chaincodeName和chaincodeVersion取出。这里的path为<code>chaincodeInstallPath</code>,这个是peer启动时从配置文件<code>core.yaml</code>里读取的，配置项为<code>peer.fileSystemPath</code>.<p></p>
<p>然后执行<code>r.start(ctx, cccid, cds)</code>用这部分代码启动。<code>HandlerRegistry.Launching(cname)</code>先注册launching状态，防止被重复部署。接着启动go routine执行<code>r.Runtime.Start(ctx, cccid, cds)</code>。这里首先获取容器启动参数设置，环境变量等配置，这些配置将作用于后续启动的容器。这里需要留意的是，设置了<code>lc.Args = []string{"chaincode", fmt.Sprintf("-peer.address=%s", c.PeerAddress)}</code>，这里是chaincode容器启动的执行命令。然后根据cds的ExecEnv设置选择容器类型，这里共有两种类型，SYSTEM和DOCKER，用户定义的chaincode是启动在docker容器里的。然后开始启动容器的步骤<code>c.Processor.Process(ctxt, vmtype, scr);</code>。先对容器名加锁<code>vmc.lockContainer(ccid.GetName())</code>防止同时执行创建容器操作，然后执行<code>container.StartContainerReq</code>的<code>Do</code>方法。这里的<code>dockercontroller.Start</code>方法是真正创建容器的地方。</p>
<ol>
<li>构造镜像名（需要保证唯一性）和容器名，停止重名的容器（如果存在，stop,kill,remove），然后使用该镜像创建容器。创建过程遇到<code>err == docker.ErrNoSuchImage</code>，事实上这是必须的，因为要保证是第一次部署，当前环境没有该镜像。入参提供了<code>container.Builder</code>，此处尝试重新构建和部署镜像，然后重新创建容器。如果还是失败，则排除了镜像不存在的错误原因，直接返回错误结果。</li>
<li>这里，存在<code>attachStdout := viper.GetBool("vm.docker.attachStdout")</code>这个配置，将容器的输出直接到控制台，方便开发调试。</li>
<li>将需要上传的文件传到容器里，这里的文件是各种配置，例如TLS的key和cert。</li>
<li>使用第三方库fsouza/go-dockerclient来启动docker容器<code>err = client.StartContainer(containerName, nil)</code>.</li>
<li>由于启动容器是异步操作，马上返回到<code>runtime_launcher.start</code>，这里是<code>select-cast</code>,等待启动完成的chan信号，或者异常，或者超时。如果启动失败，则停止容器，取消注册<code>RuntimeLauncher.Registry</code>里到handler以及launchState状态。</li>
</ol>
<p>在<code>core/container/dockercontroller/dockercontroller.go:preFormatImageName</code>定义了docker镜像和容器名，其中，镜像名为<code>${NetworkID}-${PeerId}-${ChaincodeName}-${Version}-${Hash}</code>，容器名为<code>${NetworkID}-${PeerId}-${ChaincodeName}-${Version}</code>，其中NetworkID从配置文件core.yml里的<code>peer.NetworkId</code>配置项。</p>
<p><em>这部分docker相关比较繁琐，暂时没有时间精力深入学习和分析源码，可以参考<a href="https://blog.csdn.net/idsuf698987/article/details/78353481">fabric源码解析20——ACC的部署</a></em></p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(2) peer端的调用流程</title>
    <url>//articles/fabric-source-chaincode-instantiate-peer/</url>
    <content><![CDATA[<p>接下来具体执行<code>env, err := instantiate(cmd, cf)</code>，这里可以看到入参是<code>cobra.Command</code>和刚刚初始化的<code>ChaincodeCmdFactory</code>,结果是提交给Orderer的Envelope message<code>protos/common.Envelope</code>.</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//instantiate the command via Endorser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">instantiate</span><span class="params">(cmd *cobra.Command, cf *ChaincodeCmdFactory)</span> <span class="params">(*protcommon.Envelope, error)</span></span> {</span><br><span class="line"></span><br><span class="line">    spec, err := getChaincodeSpec(cmd)</span><br><span class="line">    cds, err := getChaincodeDeploymentSpec(spec, <span class="literal">false</span>)</span><br><span class="line">    creator, err := cf.Signer.Serialize()   </span><br><span class="line">    prop, _, err := utils.CreateDeployProposalFromCDS(channelID, cds, creator, policyMarshalled, []<span class="keyword">byte</span>(escc), []<span class="keyword">byte</span>(vscc), collectionConfigBytes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> signedProp *pb.SignedProposal</span><br><span class="line">    signedProp, err = utils.GetSignedProposal(prop, cf.Signer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate is currently only supported for one peer</span></span><br><span class="line">    proposalResponse, err := cf.EndorserClients[<span class="number">0</span>].ProcessProposal(context.Background(), signedProp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proposalResponse != <span class="literal">nil</span> {</span><br><span class="line">        <span class="comment">// assemble a signed transaction (it's an Envelope message)</span></span><br><span class="line">        env, err := utils.CreateSignedTx(prop, cf.Signer, proposalResponse)</span><br><span class="line">        <span class="keyword">return</span> env, <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><code>getChaincodeSpec</code>和<code>getChaincodeDeploymentSpec</code>从提交的command里获取相应的参数，检查以及设置参数（例如是否指定escc(endorsement system chaincode), vscc(verification system chaincode), ConstructorJSON 构造参数），进而构造chaincode描述结构体<code>pb.ChaincodeSpec</code>和部署结构体<code>pb.ChaincodeDeploymentSpec</code>。<br><code>pb.ChaincodeSpec</code>(cs)里指定了<code>ChaincodeSpec_Type</code>语言类型，默认为go，<code>ChaincodeID</code>，chaincode的标识（包括路径Path，名称Name，版本Version），以及Input（即ConstructorJSON 构造参数，初始化的值，命令行里-c参数值，例子里的’{“Args”:[“init”,”a”, “100”, “b”,”200”]}’）。<br><code>pb.ChaincodeDeploymentSpec</code>(cds)里包裹<code>ChaincodeSpec</code>，以及<code>CodePackage</code>，打包后用于安装部署的代码，<code>ExecEnv</code>，指定运行于同一系统中或者docker容器。<code>getChaincodeDeploymentSpec</code>入参区分是否当前是dev开发模式，而且是否需要构造CodePackage。构造打包是在install安装时进行的，后面分析install时详述。</li>
</ol>
<span id="more"></span>
<ol>
<li><p><code>CreateDeployProposalFromCDS</code>从上面构造的部署结构体得到<code>peer.ChaincodeInvocationSpec</code>(cis),进而得到<code>peer.Proposal</code>,然后使用初始化时候得到的signer对这个提案进行签名，这个步骤与初始化时候非常相似。</p>
<blockquote>
<p>Transaction的结构可以参看总结<a href="https://blockchain-fabric.blogspot.com/2017/04/hyperledger-fabric-v10-block-structure.html">Hyperledger Fabric V1.0: Block Structure</a> </p>
</blockquote>
<p><code>pb.ChaincodeInvokeSpec</code>(cis)里指定<code>Type</code>为golang，<code>ChaincodeID</code>指定为lscc（lifecycle system chaincode），然后将上面构造的cds序列化在[]byte作为<code>Input</code>字段。<br><code>CreateDeployProposalFromCDS</code>这个方法从部署结构体cds出发，生成随机字符串<code>NONCE</code>，使用签名生成<code>ProposalTxID</code>; 指定类型<code>Type</code>为<code>HeaderType_ENDORSER_TRANSACTION</code>(此处多补充一句，初始化时获取配置的类型为<code>HeaderType_CONFIG</code>),指定<code>channelId</code>，<code>chaincodeID</code>(包括chaincode的version，path，name)。这里的<code>chaincodeID</code>是构造的<code>peer.ChaincodeInvocationSpec</code>的参数，指定了Name为lscc，lifecycle systme chaincode。此外，还有初始化过程MSP获取的<code>creator</code>(即序列化后的signer)表明身份以及创建时间<code>Timestamp</code>等。这些构成了transaction的header,连同序列化后的<code>ChaincodeInvocationSpec</code>对象作为payload,共同组成了<code>peer.Proposal{Header: hdrBytes, Payload: ccPropPayloadBytes}</code>.最后使用signer进行签名。</p>
</li>
<li><p>rpc调用。初始化时候构建了endorser client组（实际上instantiate只允许有一个）。使用该client发送请求<code>grpc.Invoke(ctx, "/protos.Endorser/ProcessProposal", in, out, c.cc, opts...)</code>，这里ctx传入了golang的<code>context.Background()</code>，后面的rpc调用派生自该顶层context。服务端的处理后面再详述。注意这里是同步调用。endorser rpc的数据结构<code>SignedProposal</code>如下</p>
</li>
</ol>
<pre><code class="lang-json">// peer.SignedProposal:
{
    "ProposalBytes": "${propBytes}", 
    "Signature": "${signature}" // signature, err := signer.Sign(propBytes)
}

// peer.Proposal : 
{
    "Header": "${hdrBytes}", 
    "Payload": "${ccPropPayloadBytes}"
}

// common.Header(hdrBytes) :
{
    "ChannelHeader" : { // common.ChannelHeader
        "Type" : "HeaderType_ENDORSER_TRANSACTION", // common.HeaderType
        "TxId" : "#ComputeProposalTxID(nonce, creator)",
        "Timestamp": "timestamp",   // util.CreateUtcTimestamp()
        "ChannelId": "${chainID}", 
        "Extension": "${ccHdrExtBytes}",
        "Epoch":     "epoch" // always 0
    },
    "SignatureHeader" : {   // common.SignatureHeader
        "Nonce": "nonce",   // nonce, err := crypto.GetRandomNonce()
        "Creator": "creator"  // creator, err := cf.Signer.Serialize()
    }
}
// peer.ChaincodeProposalPayload(ccPropPayload)
{
    "Input": "cisBytes",
    "TransientMap": nil
}

// peer.ChaincodeHeaderExtension(ccHdrExtBytes) :
{
    "ChaincodeId" : "${cis.ChaincodeSpec.ChaincodeId}"
}

// peer.ChaincodeInvokeSpec(cis)
{
    "ChaincodeInvokeSpec" : {
        "ChaincodeSpec" : { // pb.ChaincodeSpec
            "Type" : "ChaincodeSpec_GOLANG",
            "ChaincodeId" : {
                "Name" : "lscc"
            },
            "Input" : {
                "Args" : ["deploy", "${channelId}", "${chaincodDeploySpec}"]
            }    
        }
    }
}

// pb.chaincodDeploySpec(cds)
{
    "ChaincodeSpec": {
        "Type" : "ChaincodeSpec_GOLANG",
        "ChaincodeId" : {
            "Path" : "${chaincodePath}",
            "Name" : "${chaincodeName}",
            "Version" : "${chaincodeVersion}"
        },
        "Input" : {
            "Args" : ["init","a", "100", "b","200"]
        }   
    },
    "CodePackage": nil
}
</code></pre>
<ol>
<li>收集endorser的response，然后构建签名后的transaction。下面的方法是普适的。</li>
</ol>
<pre><code class="lang-go">// CreateSignedTx assembles an Envelope message from proposal, endorsements, and a signer.
// This function should be called by a client when it has collected enough endorsements
// for a proposal to create a transaction and submit it to peers for ordering
func CreateSignedTx(proposal *peer.Proposal, signer msp.SigningIdentity, resps ...*peer.ProposalResponse) (*common.Envelope, error) {
    // the original header
    hdr, err := GetHeader(proposal.Header)
    // the original payload
    pPayl, err := GetChaincodeProposalPayload(proposal.Payload)
    shdr, err := GetSignatureHeader(hdr.SignatureHeader)
    // get header extensions so we have the visibility field
    hdrExt, err := GetChaincodeHeaderExtension(hdr)

    // ensure that all actions are bitwise equal and that they are successful 
    // 比较所有的response返回的结果是一致的
    var a1 []byte
    for n, r := range resps {
        if n == 0 {
            a1 = r.Payload
            if r.Response.Status != 200 {
                return nil, fmt.Errorf("Proposal response was not successful, error code %d, msg %s", r.Response.Status, r.Response.Message)
            }
            continue
        }

        if bytes.Compare(a1, r.Payload) != 0 {
            return nil, fmt.Errorf("ProposalResponsePayloads do not match")
        }
    }

    // fill endorsements
    endorsements := make([]*peer.Endorsement, len(resps))
    for n, r := range resps {
        endorsements[n] = r.Endorsement
    }

    // 构造各级数据结构并序列化，包含原始的proposal的payload，header等信息，
    // 以及repsponse的payload，各个resp相应的endorsement，
    // 构造了新的peer.Transaction，然后使用signer进行签名。
    // 最后将序列化后的transaction和签名组装成common.Envelope并返回。 
}
</code></pre>
<p>最后，初始化时候得到的<code>cf.BroadcastClient.Send(env)</code>.至此，完成了chaincode instantiate在peer端的所有操作。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>Fabric 1.4源码分析 - chaincode instantiate(1）peer端的初始化过程</title>
    <url>//articles/fabric-source-chaincode-instantiate-initcmdfactory/</url>
    <content><![CDATA[<p>推荐参考两个博客：  </p>
<ul>
<li><a href="https://blog.csdn.net/idsuf698987/article/details/74907281">fabric源码解析——序</a> : 国内同道的源码分析系列，模块化  </li>
<li><a href="https://www.chaindesk.cn/witbook/30/467">Hyperledger Fabric源码深度解析</a> : 对MSP，BCCSP的介绍到位 </li>
<li><a href="https://blockchain-fabric.blogspot.com/">To know the internals of certain permissioned blockchain platform</a> : IBM员工，参与HF项目的概念总结文章系列</li>
</ul>
<p><em>选择peer chaincode instantiate作为开篇，是因为笔者学习官网过程中没有完全理解install与instantiate的区别，所以选择深入源码学习来加深理解</em></p>
<p>官网<a href="https://hyperledger-fabric.readthedocs.io/en/release-1.4/build_network.html">Building Your First Network</a>例子中，命令为  </p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mycc -v 1.0 -c '{"Args":["init","a", "100", "b","200"]}' -P "AND ('Org1MSP.peer','Org2MSP.peer')"</span><br></pre></td></tr></tbody></table></figure>
<p>此前，需要先设置环境变量</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line">CORE_PEER_ADDRESS=peer0.org2.example.com:7051</span><br><span class="line">CORE_PEER_LOCALMSPID="Org2MSP"</span><br><span class="line">CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br></pre></td></tr></tbody></table></figure>
<p>客户端调用<code>peer chaincode instatiate</code>命令部署chaincode，代码在‘peer/chaincode/instantiate.go’这个文件下，命令关联的方法是<code>chaincodeDeploy</code>(使用了流行的第三方命令行cobra库，具体可自行学习)。</p>
<span id="more"></span>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chaincodeDeploy</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>, cf *ChaincodeCmdFactory)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="keyword">if</span> cf == <span class="literal">nil</span> {</span><br><span class="line">        cf, err = InitCmdFactory(cmd.Name(), <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">defer</span> cf.BroadcastClient.Close()</span><br><span class="line"></span><br><span class="line">    env, err := instantiate(cmd, cf)</span><br><span class="line"></span><br><span class="line">    err = cf.BroadcastClient.Send(env)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法主要分为3个步骤（源码只列出关键步骤，省略判断逻辑及错误处理等，下同）。  </p>
<ol>
<li>入参<code>cf *ChaincodeCmdFactory</code>为nil，未初始化。（可回溯到peer启动<code>peer/main.go#main</code>时看到<code>mainCmd.AddCommand(chaincode.Cmd(nil))</code>）。初始化chaincode命令工厂，包含客户端及辅助类。这个方法在所有的chaincode命令前都先执行，入参有所不同。<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ChaincodeCmdFactory holds the clients used by ChaincodeCmd</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeCmdFactory <span class="keyword">struct</span> {</span><br><span class="line">    EndorserClients []pb.EndorserClient     <span class="comment">// 与endorser交互的客户端</span></span><br><span class="line">    DeliverClients  []api.PeerDeliverClient     <span class="comment">// </span></span><br><span class="line">    Certificate     tls.Certificate     <span class="comment">//</span></span><br><span class="line">    Signer          msp.SigningIdentity        </span><br><span class="line">    BroadcastClient common.BroadcastClient      <span class="comment">// 与orderer交互的客户端</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
下面关注下初始化的过程<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// peer/chaincode/common.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitCmdFactory</span><span class="params">(cmdName <span class="keyword">string</span>, isEndorserRequired, isOrdererRequired <span class="keyword">bool</span>)</span> <span class="params">(*ChaincodeCmdFactory, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> isEndorserRequired {</span><br><span class="line">        <span class="keyword">if</span> err = validatePeerConnectionParameters(cmdName); err != <span class="literal">nil</span> {} </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, address := <span class="keyword">range</span> peerAddresses {</span><br><span class="line">            endorserClient, err := common.GetEndorserClientFnc(address, tlsRootCertFile)</span><br><span class="line">            endorserClients = <span class="built_in">append</span>(endorserClients, endorserClient)</span><br><span class="line">            </span><br><span class="line">            deliverClient, err := common.GetPeerDeliverClientFnc(address, tlsRootCertFile)</span><br><span class="line">            deliverClients = <span class="built_in">append</span>(deliverClients, deliverClient)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    certificate, err := common.GetCertificateFnc()</span><br><span class="line"></span><br><span class="line">    signer, err := common.GetDefaultSignerFnc()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> broadcastClient common.BroadcastClient</span><br><span class="line">    <span class="keyword">if</span> isOrdererRequired {</span><br><span class="line">        endorserClient := endorserClients[<span class="number">0</span>]</span><br><span class="line">        orderingEndpoints, err := common.GetOrdererEndpointOfChainFnc(channelID, signer, endorserClient)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// override viper env</span></span><br><span class="line">        viper.Set(<span class="string">"orderer.address"</span>, orderingEndpoints[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        broadcastClient, err = common.GetBroadcastClientFnc()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ChaincodeCmdFactory{</span><br><span class="line">        EndorserClients: endorserClients,</span><br><span class="line">        DeliverClients:  deliverClients,</span><br><span class="line">        Signer:          signer,</span><br><span class="line">        BroadcastClient: broadcastClient,</span><br><span class="line">        Certificate:     certificate,</span><br><span class="line">    }, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li>入参为<code>cmdName(命令名) string(命令名), isEndorserRequired（是否需要初始化endorser client）, isOrdererRequired（是否需要初始化orderer broadcast client） bool</code>。这个是根据命令传参，例如instantiate部署chaincode既需要endorser背书，也需要orderer排序打包并且扩散全网，而install安装则只需要背书。</li>
<li>instantiate需要背书，<code>isEndorserRequired=true</code>。<code>validatePeerConnectionParameters</code>校验命令参数。例如，校验peerAddresses个数及相应的tlsRootCertFiles匹配。注意，这里有<code>// currently only support multiple peer addresses for invoke</code>注释，对非invoke方法只能传入一个peerAddress，如install，instantiate。这也说明，这些操作只能作用于单个节点，而且下面也可以看到只需要单个节点的背书。</li>
<li><p><code>GetEndorserClientFnc</code>和<code>GetPeerDeliverClientFnc</code>方法非常类似。都是构造以下这个client(主要是grpc client, hyperledger fabric使用grpc作为rpc方案)，数据结构完全一致，只是后续的用途有所不同。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// GetEndorserClient returns a new endorser client. If the both the address and</span></span><br><span class="line"><span class="comment">// tlsRootCertFile are not provided, the target values for the client are taken</span></span><br><span class="line"><span class="comment">// from the configuration settings for "peer.address" and</span></span><br><span class="line"><span class="comment">// "peer.tls.rootcert.file"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEndorserClient</span><span class="params">(address, tlsRootCertFile <span class="keyword">string</span>)</span> <span class="params">(pb.EndorserClient, error)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> address != <span class="string">""</span> {</span><br><span class="line">        <span class="comment">// 从命令行传入peer address, --peerAddresses, --tlsRootCertFiles</span></span><br><span class="line">        peerClient, err = NewPeerClientForAddress(address, tlsRootCertFile)</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 从环境变量读取peer address</span></span><br><span class="line">        peerClient, err = NewPeerClientFromEnv()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> peerClient.Endorser()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&amp;PeerClient{</span><br><span class="line">    commonClient: commonClient{</span><br><span class="line">        GRPCClient: gClient,    <span class="comment">// grpc client. 工程使用grpc作为节点间的远程调用方案</span></span><br><span class="line">        address:    address,    <span class="comment">// “peer.address”</span></span><br><span class="line">        sn:         override   <span class="comment">// "peer.tls.serverhostoverride"</span></span><br></pre></td></tr></tbody></table></figure>
<p>在上面的例子中，命令里并没有提供<code>peerAddress</code>和<code>tlsRootCertFile</code>这两个参数，因此从环境变量里读取。在源码中，使用了流行的第三方库viper来进行配置加载和管理。也就是我们要先设置的变量<code>CORE_PEER_ADDRESS</code>和<code>CORE_PEER_TLS_ROOTCERT_FILE</code>。</p>
</li>
<li><p>生成客户端X509证书<code>GetCertificateFnc</code>。客户端通信时是否需要校验X509证书是由环境变量<code>peer.tls.enabled</code>和<code>peer.tls.clientAuthRequired</code>这两个参数决定的。在该tutorial例子中并没有设置。如果需要校验，则另外需要提供两个参数<code>peer.tls.clientKey.file</code>和<code>peer.tls.clientCert.file</code>，分别对应节点的public/private key文件。需要说明的是，在前面构造的endorseClient和peerDeliverClient过程中，也已经读取这两个参数和文件，生成X509 key pair，可以进行tls通信。这里的方法也是构建peerClient，获取该key pair。（TODO：以后专题分析加密）</p>
</li>
<li><p><code>GetDefaultSignerFnc</code>调用本地MSP<code>mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()</code>获取signer，后续用于发送的proposal进行签名，构造signedProposal。（TODO：以后专题分析msp成员管理服务）</p>
</li>
<li><p><code>isOrdererRequired</code>这个参数初始化时候传入，根据后续操作是否需要与orderer交互乃至全网同步而是否选择初始化。chaincode instantiate需要全网同步，因此需要初始化。命令行<code>-o</code>参数指定orderer地址，如果没有指定，则通过<code>GetOrdererEndpointOfChainFnc</code>获取orderer地址。这个是通过调用cscc（configuration system chaincode，配置系统链码）的GetConfigBlock方法（参数为channelId）实现的。流程与一般的chaincode调用相似。</p>
<figure class="highlight go"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetOrdererEndpointOfChain</span><span class="params">(chainID <span class="keyword">string</span>, signer msp.SigningIdentity, endorserClient pb.EndorserClient)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span> {</span><br><span class="line">	<span class="comment">// query cscc for chain config block</span></span><br><span class="line">	invocation := &amp;pb.ChaincodeInvocationSpec{</span><br><span class="line">		ChaincodeSpec: &amp;pb.ChaincodeSpec{</span><br><span class="line">			Type:        pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">"GOLANG"</span>]),</span><br><span class="line">			ChaincodeId: &amp;pb.ChaincodeID{Name: <span class="string">"cscc"</span>},</span><br><span class="line">			Input:       &amp;pb.ChaincodeInput{Args: [][]<span class="keyword">byte</span>{[]<span class="keyword">byte</span>(cscc.GetConfigBlock), []<span class="keyword">byte</span>(chainID)}},</span><br><span class="line">		},</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	creator, err := signer.Serialize()</span><br><span class="line">	prop, _, err := putils.CreateProposalFromCIS(pcommon.HeaderType_CONFIG, <span class="string">""</span>, invocation, creator)</span><br><span class="line">	signedProp, err := putils.GetSignedProposal(prop, signer)</span><br><span class="line"></span><br><span class="line">	proposalResp, err := endorserClient.ProcessProposal(context.Background(), signedProp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parse config block</span></span><br><span class="line">	block, err := putils.GetBlockFromBlockBytes(proposalResp.Response.Payload)</span><br><span class="line">	envelopeConfig, err := putils.ExtractEnvelope(block, <span class="number">0</span>)</span><br><span class="line">	bundle, err := channelconfig.NewBundleFromEnvelope(envelopeConfig)</span><br><span class="line">	<span class="keyword">return</span> bundle.ChannelConfig().OrdererAddresses(), <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<ul>
<li>构造<code>ChaincodeInvocationSpec</code>cis描述该chaincode请求，包含请求的语言（GOLAND），chaincodeId（“cscc”），具体请求Input（cscc.GetConfigBlock）等。这个请求体格式通用于所有的系统及普通chaincode。然后，构造proplsal，并通过上面MSP获取的signer进行签名，在被调用方需要依次判断该节点是否有权限调用chaincode。  </li>
<li>接着，通过上面构建等endorserClient进行grpc调用<code>grpc.Invoke(ctx, "/protos.Endorser/ProcessProposal", in, out, c.cc, opts...)</code>，简单介绍下参数(ctx context.Context，in *SignedProposal, opts …grpc.CallOption, out ProposalResponse, c.cc endorser.grpc.ClientConn)。此处grpc调用的方法是<code>/protos.Endorser/ProcessProposal</code>，endorser端校验，调用cscc，得到结果ProposalResponse返回。这个后面详述。  </li>
<li>最后，从rpc调用的结果bytes依次反序列化成block，获取并反序列化block中第一个envelope，把envelope的payload反序列化成configtx，并且获取相应的信息channelConfig，最后从channelConfig中获取到OrdererAddresses。（这里的结构处理是根据cscc的GetConfigBlock调用结果）选择第一个orderer的地址重写为系统变量<code>orderer.address</code>。(TODO：这里是否会把所有的请求都集中到第一个orderer有待研究cscc的方法)  </li>
</ul>
<ol>
<li><code>GetBroadcastClientFnc</code>与上面的<code>GetEndorserClient</code>主要流程非常相似，主要区别有两点。第一，<code>GetEndorserClient</code>构建的client，使用的是peer的设置，而<code>GetBroadcastClientFnc</code>获取的是orderer的设置，从环境变量里获取构造参数，<code>configFromEnv("orderer")</code>，这里<code>orderer.address</code>这个参数正是上面的方法从chaincode config block里获取并设置为环境变量的。第二，调用了<code>orderClient.Broadcast()</code>，这里<code>grpc.NewClientStream(ctx, &amp;_AtomicBroadcast_serviceDesc.Streams[0], c.cc, "/orderer.AtomicBroadcast/Broadcast", opts...)</code>直接指明了grpc的远程调用方法为<code>"/orderer.AtomicBroadcast/Broadcast"</code>.</li>
</ol>
<p>至此，完成了chaincode调用的初始化构造过程。后续的chaincode调用就可以直接使用此过程中构建的client及signer等执行不同的操作。</p>
]]></content>
      <categories>
        <category>Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>起手式</title>
    <url>//articles/foreword/</url>
    <content><![CDATA[<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>创建这个博客的缘由是今年在学习区块链的知识，想记录和分享下学习和进步的过程，为了随时可以翻看和补充修正。此外，记录下平时工作（大数据开发）过程中遇到的问题，踩过的坑。如果在这个基础上还能做到知识输出，或者能做到分享让大家互相学习和指正，那就算喜出望外了。</p>
<h3 id="关于区块链"><a href="#关于区块链" class="headerlink" title="关于区块链"></a>关于区块链</h3><p>浪潮过去后才能看出谁在裸泳。区块链的热度去年随着韭菜风波过去后，进入技术的沉淀期。始终认为区块链只是一门技术，而且还是没有杀手级应用，还不成熟的技术，更不应该上升到信仰的高度。一项新技术在短期内会被高估，在长期则被低估。选择这个人少的方向，也意味着冒更大的风险，无从估计三年后的发展，也意味着可能会一直碌碌无为。我希望像竹子一样，用三年时间好好扎根沉淀，静待破土。<br><span id="more"></span></p>
<h3 id="关于Hyperledger-Fabric学习"><a href="#关于Hyperledger-Fabric学习" class="headerlink" title="关于Hyperledger Fabric学习"></a>关于Hyperledger Fabric学习</h3><p>我从未从事过区块链相关开发工作，甚至也未曾工作中使用过go语言。学习区块链纯属出于个人兴趣，而选择Hyperledger Fabric则是选择联盟链里最火热的框架。题外话，我目前还不了解看不清公有链DAPP的发展，还是专注于联盟链的学习。Fabric的学习，主要是从官网获得概念，以源码分析来补充和加深理解细节。 因为缺乏项目经验，尚且无法高屋建瓴的去模块化分析和概括整个框架，而更多的选择从点及面的延伸性学习。因此，你可能无法从我的博客里获得非常系统的学习，甚至于也无法保证博客内容的完整性和百分百的准确性，我只是记录着自己学习Hyperledger Fabric（基于v1.4）的历程，以及与同道交流。希望以此督促自己坚持下去，工作业余时间能深入去学习和分享，定期来更新。</p>
]]></content>
  </entry>
</search>
