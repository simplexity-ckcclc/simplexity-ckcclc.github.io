<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"simplexity.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文为Why and How zk-SNARK Works: Definitive Explanation论文学习心得，纯粹个人在阅读过程中的疑问和思考，详细的理解请阅读附录引用的文章。 2. The Medium of a Proof 多项式是zk-snark的核心   基本流程1234• Verifier chooses a random value for x and evaluates h">
<meta property="og:type" content="article">
<meta property="og:title" content="零知识证明： Why and How zk-SNARK Works：Definitive Explanation论文学习">
<meta property="og:url" content="https://simplexity.cn/2020/08/12/zk-snark-paper/index.html">
<meta property="og:site_name" content="Simplexity">
<meta property="og:description" content="本文为Why and How zk-SNARK Works: Definitive Explanation论文学习心得，纯粹个人在阅读过程中的疑问和思考，详细的理解请阅读附录引用的文章。 2. The Medium of a Proof 多项式是zk-snark的核心   基本流程1234• Verifier chooses a random value for x and evaluates h">
<meta property="og:locale">
<meta property="og:image" content="https://simplexity.cn/images/zk-snarks/zk-snarks-encrypted-polynomial.jpeg">
<meta property="og:image" content="https://simplexity.cn/images/zk-snarks/zk-snarks-encrypted-polynomial-derivation.jpeg">
<meta property="og:image" content="https://simplexity.cn/images/zk-snarks/zk-snarks-restricting-polynomial-derivation.jpeg">
<meta property="og:image" content="https://simplexity.cn/images/zk-snarks/zk-snark-non-interactivity.jpg">
<meta property="og:image" content="https://simplexity.cn/images/zk-snarks/zk-snark-example.jpg">
<meta property="article:published_time" content="2020-08-12T13:26:30.000Z">
<meta property="article:modified_time" content="2020-11-20T16:31:40.527Z">
<meta property="article:author" content="Travis Wong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://simplexity.cn/images/zk-snarks/zk-snarks-encrypted-polynomial.jpeg">

<link rel="canonical" href="https://simplexity.cn/2020/08/12/zk-snark-paper/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>零知识证明： Why and How zk-SNARK Works：Definitive Explanation论文学习 | Simplexity</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Simplexity</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">50</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://simplexity.cn/2020/08/12/zk-snark-paper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Travis Wong">
      <meta itemprop="description" content="Simple is Complex">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simplexity">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          零知识证明： Why and How zk-SNARK Works：Definitive Explanation论文学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-12 21:26:30" itemprop="dateCreated datePublished" datetime="2020-08-12T21:26:30+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-21 00:31:40" itemprop="dateModified" datetime="2020-11-21T00:31:40+08:00">2020-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Consensus-Cryptography/" itemprop="url" rel="index"><span itemprop="name">Consensus & Cryptography</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文为<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1906.07221">Why and How zk-SNARK Works: Definitive Explanation</a>论文学习心得，纯粹个人在阅读过程中的疑问和思考，详细的理解请阅读附录引用的文章。</p>
<h3 id="2-The-Medium-of-a-Proof"><a href="#2-The-Medium-of-a-Proof" class="headerlink" title="2. The Medium of a Proof"></a>2. The Medium of a Proof</h3><ul>
<li><strong>多项式是zk-snark的核心</strong></li>
</ul>
<ol>
<li>基本流程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• Verifier chooses a random value for x and evaluates his polynomial locally</span><br><span class="line">• Verifier gives x to the prover and asks to evaluate the polynomial in question</span><br><span class="line">• Prover evaluates his polynomial at x and gives the result to the verifier</span><br><span class="line">• Verifier checks if the local result is equal to the prover’s result, and if so then the statement is proven with a high confidence</span><br></pre></td></tr></table></figure></li>
<li>存在问题<ul>
<li>prover可以通过其他方式得到多项式结果，没有方法确保该结果是经过多项式计算得来</li>
<li>多项式的阶数需要足够高</li>
</ul>
</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a><span id="more"></span></h2><h3 id="3-Non-Interactive-Zero-Knowledge-of-a-Polynomial"><a href="#3-Non-Interactive-Zero-Knowledge-of-a-Polynomial" class="headerlink" title="3 Non-Interactive Zero-Knowledge of a Polynomial"></a>3 Non-Interactive Zero-Knowledge of a Polynomial</h3><p>这一章是zk-snark的理论基础。</p>
<h3 id="3-1-Proving-Knowledge-of-a-Polynomial"><a href="#3-1-Proving-Knowledge-of-a-Polynomial" class="headerlink" title="3.1 Proving Knowledge of a Polynomial"></a>3.1 Proving Knowledge of a Polynomial</h3><ol>
<li><p>流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">• Verifier samples a random value r, calculates t = t(r) (i.e., evaluates) and gives r to the prover</span><br><span class="line">• Prover calculates h(x) = p(x) and evaluates p(r) and h(r); the resulting values p,h are t(x) provided to the verifier</span><br><span class="line">• Verifier then checks that p = t · h, if so those polynomials are equal, meaning that p(x) has t(x) as a cofactor.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Q1： 为什么prover不直接传递t ?<br>A1： 需要证明的是 prover知道t，即其中的两个根。下文有说明，prover可能通过别的方式恰好知道t(s)的值，协议不安全。而zk-snark里是将要证明的表达成多项式，然后由verifier构造基础多项式，让prover来赋值输入/输出，通过证明t的根是verifier的目标多项式的根，从而证明其输出的正确性。</p>
</li>
<li><p>Q2: 如果试验次数足够多，例如h的阶数，是否可能推算出h，从而推算出p ?<br>A2: 下文引入零知识证明，通过3.3的同态加密的模运算实现。</p>
</li>
</ul>
</li>
<li><p>存在问题</p>
<ul>
<li>prover计算得到t后，可以随意选择h，计算p=h*t，verifier无法验证prover是否知道p。</li>
<li>prover恰好知道x=r处的值t(r)，可以构造任何的多项式</li>
</ul>
</li>
</ol>
<h3 id="3-3-Obscure-Evaluation"><a href="#3-3-Obscure-Evaluation" class="headerlink" title="3.3 Obscure Evaluation"></a>3.3 Obscure Evaluation</h3><h3 id="3-3-1-Homomorphic-Encryption（同态加密）"><a href="#3-3-1-Homomorphic-Encryption（同态加密）" class="headerlink" title="3.3.1 Homomorphic Encryption（同态加密）"></a>3.3.1 Homomorphic Encryption（同态加密）</h3><p>The general idea is that we choose a base natural number g (say 5) and to encrypt a value we exponentiate g to the power of that value.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5^3 = 125, Where 125 is the encryption of 3.</span><br></pre></td></tr></table></figure></p>
<ol>
<li>存在问题<br>将125持续的除以5，直到结果为1，此时的step就是加密的3</li>
</ol>
<h3 id="3-3-3-Strong-Homomorphic-Encryption"><a href="#3-3-3-Strong-Homomorphic-Encryption" class="headerlink" title="3.3.3 Strong Homomorphic Encryption"></a>3.3.3 Strong Homomorphic Encryption</h3><p>模运算。基本流程如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">encryption :  5^3 = 6 (mod 7)</span><br><span class="line">multiplication :  6^2 = (5^3)^2 = 5^6 = 1 (mod 7)</span><br><span class="line">addition:   5^3·5^2 =5^5 =3 (mod7)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>局限性<br>while we can multiply an encrypted value by an unencrypted value, we cannot multiply (and divide) two encrypted values, as well as we cannot exponentiate an encrypted value.<br>两个加密结果间无法直接进行乘法运算。（下文引入pairing配对函数，解决乘法运算）</li>
</ol>
<h3 id="3-3-4-Encrypted-Polynomial"><a href="#3-3-4-Encrypted-Polynomial" class="headerlink" title="3.3.4 Encrypted Polynomial"></a>3.3.4 Encrypted Polynomial</h3><p><img src="/images/zk-snarks/zk-snarks-encrypted-polynomial.jpeg" alt=""><br><img src="/images/zk-snarks/zk-snarks-encrypted-polynomial-derivation.jpeg" alt=""></p>
<ul>
<li><em>(说明：图中r即论文中的s)</em></li>
</ul>
<ol>
<li>能解决<code>prover恰好知道x=s的值t(s)，可以构造任何的多项式</code>这个问题，因为已经prover已经无法得知<code>s</code>以及<code>t(s)</code>。</li>
<li><strong><em>不能</em></strong> 解决<code>prover计算得到t后，可以随意选择h，计算p=h*t，verifier无法验证prover是否知道p</code>，例如，可以随意选择r的值，构造 z<sub>h</sub> = g<sup>r</sup> 和 z<sub>p</sub> = (g<sup>t(s)</sup>)<sup>r</sup></li>
</ol>
<h3 id="3-4-Restricting-a-Polynomial"><a href="#3-4-Restricting-a-Polynomial" class="headerlink" title="3.4 Restricting a Polynomial"></a>3.4 Restricting a Polynomial</h3><p><img src="/images/zk-snarks/zk-snarks-restricting-polynomial-derivation.jpeg" alt=""></p>
<ul>
<li><em>(说明：图中r即论文中的s)</em></li>
</ul>
<ol>
<li><p>结论：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">– Bob has applied the same exponent (i.e., c) to both values of the tuple</span><br><span class="line">– Bob could only use the original Alice’s tuple to maintain the α relationship</span><br><span class="line">– Bob knows the applied exponent c, because the only way to produce valid (b,b′) is to use the same exponent</span><br><span class="line">– Alice has not learned c for the same reason Bob cannot learn α</span><br></pre></td></tr></table></figure>
<p>即Prover必须使用verifier提供的基于s<sup>i</sup>计算出来的值进行计算，verifier可以通过验证(g<sup>p</sup>, g<sup>p’</sup>)间仍然保持 α 的指数偏移量关系。同时verifier无法得知prover使用的参数c的值。</p>
</li>
<li><p>存在问题：</p>
</li>
</ol>
<ul>
<li>Q1: 如果原始的<code>p=(x+1)*(x+2)</code>，其中<code>t=x+1</code>,<code>h=x+2</code>。但是prover捏造<code>h&#39;=x+3</code>，即<code>p&#39;=(x+1)*(x+3)</code>，verifier是否无法验证？<br>A1: 在zk-snark实际应用中看4.8小节</li>
</ul>
<h3 id="3-5-Zero-Knowledge"><a href="#3-5-Zero-Knowledge" class="headerlink" title="3.5 Zero-Knowledge"></a>3.5 Zero-Knowledge</h3><p>verifier可以从E（p）知道关于p的多项式的具体参数。例如上面的例子对E（p）因式分解？<br>解决方案：类似verifier引入 α 保证prover使用其提供的值进行运算，相应的prover也映入 δ 指数偏移量。例如验证 g<sup>δ·p</sup> = g<sup>δ·t(s)h</sup></p>
<h3 id="3-6-Non-Interactivity"><a href="#3-6-Non-Interactivity" class="headerlink" title="3.6 Non-Interactivity"></a>3.6 Non-Interactivity</h3><p>非交互式。多方各自验证，防止verifier和prover联合作假或者泄漏，proof可以重用提高效率，并且prover无需时刻在线响应。核心是Cryptographic pairings(配对函数)，即找到算法可以支持加密后数值的<strong>同态乘法</strong>运算，即e(g<sup>a</sup>, g<sup>b</sup>) = e(g, g)<sup>ab</sup>（小节3.3.3中不支持）。这样在setup阶段可以构造composite CRS（common reference string）（小节3.6.3）<br><img src="/images/zk-snarks/zk-snark-non-interactivity.jpg" alt=""></p>
<p>小节3.6.2中，由于引入了<strong>配对函数</strong>，验证加密方法是 e(g<sup>p</sup>, g<sup>1</sup>)=e(g<sup>t</sup>, g<sup>h</sup>)，而3.3.4同态加法加密小节里，则是验证g<sup>p</sup>=g<sup>t(s)·h</sup>。</p>
<h3 id="3-7-Succinct-Non-Interactive-Argument-of-Knowledge-of-Polynomial"><a href="#3-7-Succinct-Non-Interactive-Argument-of-Knowledge-of-Polynomial" class="headerlink" title="3.7 Succinct Non-Interactive Argument of Knowledge of Polynomial"></a>3.7 Succinct Non-Interactive Argument of Knowledge of Polynomial</h3><p>重要，基础。<strong>Setup-Proving-Verification</strong> 三步骤，详见文章。</p>
<ul>
<li><strong>Setup</strong>  <ul>
<li>proving key: { g<sup>s<sup>i</sup>&lt;/sup&gt; } <sub> i∈[d] </sub> , { g<sup>αs<sup>i</sup>&lt;/sup&gt; }<sub> i∈[d] </sub>   (提供给prover)</li>
<li>verification key: g<sup>α</sup>, g<sup>t(s)</sup> （自留，后续在Verification阶段使用）</li>
</ul>
</li>
<li><strong>Proving</strong><ul>
<li>set the randomized proof π = （g<sup>δp(s)</sup>, g<sup>δh(s)</sup>, g<sup>δαp(s)</sup>)，即（g<sup>p</sup>, g<sup>h</sup>, g<sup>p′</sup>)</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>check polynomial restriction : e(g<sup>p′</sup> , g) = e(g<sup>p</sup>, g<sup>α</sup>)  </li>
<li>check polynomial cofactors : e(g<sup>p</sup>, g) = e(g<sup>t(s)</sup>, g<sup>h</sup>)  </li>
</ul>
</li>
</ul>
<p>证明了p(x)的根，即p(x）因式分解后含有多项式 t(x)。</p>
<hr>
<h3 id="4-General-Purpose-Zero-Knowledge-Proofs"><a href="#4-General-Purpose-Zero-Knowledge-Proofs" class="headerlink" title="4 General-Purpose Zero-Knowledge Proofs"></a>4 General-Purpose Zero-Knowledge Proofs</h3><p>上面一章铺垫基础知识，这一章节拓展到实际的应用场景。</p>
<h3 id="4-1-Computation"><a href="#4-1-Computation" class="headerlink" title="4.1 Computation"></a>4.1 Computation</h3><p>需要证明的是 <code>for the input (1,4,2) of expression f(w,a,b) the output is 8, in other words, we check the equality: w(a × b) + (1 − w)(a + b) = 8</code><br>根据输入，证明计算的输出结果。将计算逻辑转化成多项式运算。</p>
<h3 id="4-3-Enforcing-Operation"><a href="#4-3-Enforcing-Operation" class="headerlink" title="4.3 Enforcing Operation"></a>4.3 Enforcing Operation</h3><p>简化多项式 <code>l(x) operator r(x) = o(x)</code></p>
<ul>
<li>Q1: 这里证明3·2=6,如果构造时候输入为4·3=12，verifier验证的等式同样成立。如何校验输入的正确性？</li>
<li>A1: 4.8小节的例子</li>
</ul>
<h3 id="4-4-Proof-of-Operation"><a href="#4-4-Proof-of-Operation" class="headerlink" title="4.4 Proof of Operation"></a>4.4 Proof of Operation</h3><p><code>p(x) = l(x) · r(x) − o(x)</code>， 并且拥有已知的根。（假如只有一个根a, 则此处<code>t(x)=x-a</code> ）</p>
<ul>
<li><strong>Proving</strong><ul>
<li>proof π = (g<sup>l</sup>, g<sup>r</sup>,g<sup>o</sup>, …)</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>valid operation check: e(g<sup>l</sup>,g<sup>r</sup>) = e(g<sup>t(s)</sup>,g<sup>h</sup>)·e(g<sup>o</sup>,g)</li>
</ul>
</li>
</ul>
<p>关键在与Proving环节，构造这个p(x)，使用了Pairing函数实现加密的乘法运算。<br>存在4.3上面提到的问题，因为计算这个l,g,o时候使用的是需要证明的输入输出来计算系数。<strong>需要保证此l(x),g(x),o(x)能反映需要证明的输入operand和输出output</strong></p>
<h3 id="4-6-Variable-Polynomials"><a href="#4-6-Variable-Polynomials" class="headerlink" title="4.6 Variable Polynomials"></a>4.6 Variable Polynomials</h3><ul>
<li><strong>Setup</strong>  <ul>
<li>construct l<sub>a</sub>(x), l<sub>d</sub>(x)  : 在小节4.5的例子中，满足<code>For our example la(x) must conform to evaluations la(1) = 1, la(2) = 1 and la(3) = 0 and ld(x) is zero at 1 and 2 but 1 at x = 3</code>。也就是满足这个特性。</li>
<li>proving key: ( g<sup>l<sub>a</sub>(x)</sup>, g<sup>l<sub>d</sub>(x)</sup>, g<sup>αl<sub>a</sub>(x)</sup>, g<sup>αl<sub>d</sub>(x)</sup>) </li>
</ul>
</li>
<li><strong>Proving</strong><ul>
<li>assign values a and d and add and provide proof π = （g<sup>L(s)</sup> = g<sup>al<sub>a</sub>(x)</sup> · g<sup>dl<sub>d</sub>(x)</sup> = g<sup>al<sub>a</sub>(x) + dl<sub>d</sub>(x)</sup>)，g<sup>αL(s)</sup>) :  然后Prover再来构造 L(x) = a·l<sub>a</sub>(x) + d·l<sub>d</sub>(x)，具体的赋值，也就是输入值。在4.5的例子中，a=2,d=6。也就是限定了，prover必须使用指定的输入。</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>check polynomial restriction : e(g<sup>p′</sup> , g) = e(g<sup>p</sup>, g<sup>α</sup>)  </li>
<li>check polynomial cofactors : e(g<sup>p</sup>, g) = e(g<sup>t(s)</sup>, g<sup>h</sup>) </li>
</ul>
</li>
</ul>
<ul>
<li><p>Q1: 这里证明3X2=6,如果构造时候输入为4X3=12，verifier验证的等式同样成立。如何校验输入的正确性？</p>
<p>A1: 这里verifier可以检查 g<sup>L(s)</sup> = g<sup>al<sub>a</sub>(s)</sup> · g<sup>dl<sub>d</sub>(s)</sup> = g<sup>al<sub>a</sub>(s) + dl<sub>d</sub>(s)</sup>，即可判断输入参数是否相符。<strong><em>verifie是否知道a,d的取值？</em></strong></p>
</li>
<li>Q2: 提供的是l(x)的阶数为多阶的，verifier提供是以{ g<sup>s<sup>i</sup>&lt;/sup&gt; }i∈[d]的方式提供的，在Proving阶段prover赋值时，如何保证对于每一阶都赋予相同的值？<br>A2: </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">As a consequence the prover:</span><br><span class="line">• is not able to modify provided variable polynomials by changing their coefficients, except “assigning” values, because prover is presented only with encrypted evaluations of these polynomials, and because necessary encrypted powers of s are unavailable separately with their α-shifts</span><br><span class="line">• is not able to add another polynomial to the provided ones because the α-ratio will be broken</span><br><span class="line">• is not able to modify operand polynomials through multiplication by some other polyno- mial u(x), which could disproportionately modify the values because encrypted multipli- cation is not possible in pre-pairings space</span><br></pre></td></tr></table></figure>
<h3 id="4-7-Construction-Properties"><a href="#4-7-Construction-Properties" class="headerlink" title="4.7 Construction Properties"></a>4.7 Construction Properties</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note the operation’s construction is also called “constraint” because the operation represented by polynomial construction does not compute results per se, but rather checks that the prover already knows variables (including result), and they are valid for the operation, i.e., the prover is constrained to provide consistent values no matter what they are.</span><br></pre></td></tr></table></figure>
<p>也就是说，验证的是输入/输出计算结果，即代入上面构造的L(x),R(x),O(x)，需要证明其中的根，即t(x)。通过验证约束的方式取代直接提供输出结果的方式。</p>
<h3 id="4-8-Example-Computation"><a href="#4-8-Example-Computation" class="headerlink" title="4.8 Example Computation"></a>4.8 Example Computation</h3><p>l(x),r(x),o(x)系列子函数的这些都是已知的，也是verifier加密后传递到prover。prover使用输入w=1,a=3,b=2,计算出结果v=6，并且代入计算得到L(x),R(x),O(x),然后即传统的p(x)=L(x)·R(x)-O(x)，其中t(x)已知，因为这个是verifier用来计算l(x),r(x),o(x)的根。也就是，<strong>需要证明的是v=6</strong>。这个是通过将v=6代入不等式证明的。</p>
<p><img src="/images/zk-snarks/zk-snark-example.jpg" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m=a·b</span><br><span class="line">w·(m-a-b)=v-a-b</span><br></pre></td></tr></table></figure></p>
<p>即图中在x=1,2,3三个点处都满足<code>L(x)·R(x)-O(x)=0</code>，如果改变v的值使其不等于6，则<code>L(x)·R(x)-O(x)</code>该等式在x=2处<code>w·（m-a-b）!= v-a-b</code>，即x=2不是其中一个根，verifier验证失败。</p>
<h3 id="4-9-Verifiable-Computation-Protocol"><a href="#4-9-Verifiable-Computation-Protocol" class="headerlink" title="4.9 Verifiable Computation Protocol"></a>4.9 Verifiable Computation Protocol</h3><h4 id="4-9-1-限定L-x-只由-li-x-构成，并且证明的等式必须是L-x-·-R（x）-O-x-。-防止左操作数，右操作数，输出在证明中混用。"><a href="#4-9-1-限定L-x-只由-li-x-构成，并且证明的等式必须是L-x-·-R（x）-O-x-。-防止左操作数，右操作数，输出在证明中混用。" class="headerlink" title="4.9.1 - 限定L(x)只由 li(x) 构成，并且证明的等式必须是L(x) · R（x）= O(x)。 防止左操作数，右操作数，输出在证明中混用。"></a>4.9.1 - 限定<code>L(x)</code>只由 l<sub>i</sub>(x) 构成，并且证明的等式必须是<code>L(x) · R（x）= O(x)</code>。 防止左操作数，右操作数，输出在证明中混用。</h4><p><strong>Solution</strong>: <code>l(x),r(x),o(x)</code>分别使用不同的α<sub>l</sub>, α<sub>r</sub>, α<sub>o</sub>。</p>
<h4 id="4-9-2-限定在L-x-R-x-O-x-使用的参数vi-即4-8例子中的a-b-w等）是一致的。"><a href="#4-9-2-限定在L-x-R-x-O-x-使用的参数vi-即4-8例子中的a-b-w等）是一致的。" class="headerlink" title="4.9.2 - 限定在L(x),R(x),O(x)使用的参数vi(即4.8例子中的a,b,w等）是一致的。"></a>4.9.2 - 限定在<code>L(x),R(x),O(x)</code>使用的参数v<sub>i</sub>(即4.8例子中的a,b,w等）是一致的。</h4><p><strong>Solution</strong>:  为校验校验 v<sub>l,i</sub> = v<sub>r,i</sub> = v<sub>o,i</sub> = v<sub>β,i</sub>，关键是通过以下等式<br>e(g<sup>v<sub>l,i</sub> ·l<sub>i</sub>(s)</sup> · g<sup>v<sub>r,i</sub> ·r<sub>i</sub>(s)</sup> · g<sup>v<sub>o,i</sub> ·o<sub>i</sub>(s)</sup>, g<sup>β</sup>) = e(g<sup>v<sub>β,i</sub> ·β·(l<sub>i</sub>(s)+r<sub>i</sub>(s)+o<sub>i</sub>(s))</sup>, g)。 进一步为防止如<code>l(x) = r(x)</code>的情况，选择各自不等的β<sub>l</sub>, β<sub>r</sub>, β<sub>o</sub></p>
<ul>
<li><strong>Setup</strong>  <ul>
<li>proving key the variable consistency polynomials:<br>g<sup>β<sub>z</sub></sup>={g<sup>β<sub>l</sub>l<sub>i</sub>(s)+&gt;β<sub>r</sub>r<sub>i</sub>(s)+&gt;β<sub>o</sub>o<sub>i</sub>(s)</sup>}<sub>i∈{1,…,n}</sub></li>
<li>verification key: (g<sup>β<sub>l</sub></sup> , g<sup>β<sub>r</sub></sup> , g<sup>β<sub>o</sub></sup>, g<sup>β<sub>z</sub></sup>)</li>
</ul>
</li>
<li><strong>Proving</strong><ul>
<li>赋值计算，g<sup>z<sub>i</sub>(s)</sup>=(g<sup>β<sub>z</sub></sup>)<sup>v<sub>i</sub></sup> for i ∈ {1,…,n}，并且相乘得到proof: g<sup>Z(s)</sup></li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>e(g<sup>L</sup>, g<sup>β<sub>l</sub></sup>) · e(g<sup>R</sup>, g<sup>β<sub>r</sub></sup>) · e(g<sup>O</sup>, g<sup>β<sub>o</sub></sup>) = e(g<sup>Z</sup> , g)</li>
</ul>
</li>
</ul>
<h4 id="4-9-3-Non-malleability-of-Variable-and-Variable-Consistency-Polynomials"><a href="#4-9-3-Non-malleability-of-Variable-and-Variable-Consistency-Polynomials" class="headerlink" title="4.9.3 Non-malleability of Variable and Variable Consistency Polynomials"></a>4.9.3 Non-malleability of Variable and Variable Consistency Polynomials</h4><p><strong>Q1</strong>:（Malleability of Variable Polynomials） g<sup>α<sub>l</sub></sup> 和 g<sup>β<sub>l</sub></sup>是在verification key里的，为什么prover能拿得到？<br><strong>Q2</strong>：（Non-Malleability） 作为verification key，这里的g<sup>γ</sup>是否就是类似与Q1里的g ? 这样的区别在哪里？</p>
<h4 id="4-10-Constraints"><a href="#4-10-Constraints" class="headerlink" title="4.10 Constraints"></a>4.10 Constraints</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">However, the protocol is not actually “computing” but rather is checking that the output value is the correct result of an operation for the operand’s values. That is why it is called a constraint, i.e., a verifier is constraining a prover to provide valid values for the predefined “program” no matter what are they. </span><br></pre></td></tr></table></figure>
<h3 id="4-11-Public-Inputs-and-One-限定常量的值。"><a href="#4-11-Public-Inputs-and-One-限定常量的值。" class="headerlink" title="4.11 Public Inputs and One 限定常量的值。"></a>4.11 Public Inputs and One 限定常量的值。</h3><p><strong>Solution</strong>:<br>L(x)=L<sub>v</sub>(x)+L<sub>p</sub>(x)，其中verifier提供L<sub>v</sub>(x) = l<sub>0</sub>(x) + l<sub>1</sub>(x) + . . . + l<sub>m</sub>(x)。限定了0阶（即常量）的值v<sub>one</sub></p>
<ul>
<li><strong>Setup</strong>  <ul>
<li>. . . separate all n variable polynomials into two groups:<ul>
<li>verifier’s m + 1:<br>L<sub>v</sub>(x) = l<sub>0</sub>(x) + l<sub>1</sub>(x) + . . . + l<sub>m</sub>, and alike for R<sub>v</sub>(x) and O<sub>v</sub>(x), where index 0 is reserved for the value of v<sub>one</sub> = 1</li>
<li>prover’s n − m:<br>L<sub>p</sub>(x) = l<sub>m+1</sub>(x) + . . . + l<sub>n</sub>(x), and alike for R<sub>p</sub>(x) and O<sub>p</sub>(x)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Effectively this is taking some variables from the prover into the hands of verifier while still preserving the balance of the equation. Therefore the valid operations check should still hold, but only if the prover has used the same values that the verifier used for his input.</span><br></pre></td></tr></table></figure>
<h3 id="4-12-Zero-Knowledge-Proof-of-Computation"><a href="#4-12-Zero-Knowledge-Proof-of-Computation" class="headerlink" title="4.12 Zero-Knowledge Proof of Computation"></a>4.12 Zero-Knowledge Proof of Computation</h3><p>零知识证明，各自加上变换值。 δ<sub>l</sub>, δ<sub>r</sub>,  δ<sub>o</sub>。通过加法实现同态加密。<br>L(s) + δ<sub>l</sub>t(s)) · (R(s) + δ<sub>r</sub>t(s)) − (O(s) + δ<sub>o</sub>t(s)) = t(s) · (∆ + h(s))<br>∆ = δ<sub>r</sub>L(s) + δ<sub>l</sub>R(s) + δ<sub>l</sub>δ<sub>r</sub>t(s) − δ<sub>o</sub></p>
<p>只要满足以上关系，可以推导，在verification阶段可以就可以验证<br>L · R − O + t · ∆  = t(s)h + t(s) · ∆ </p>
<hr>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h3><ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIxNjkwODE5NQ==&amp;action=getalbum&amp;album_id=1432629901374636033&amp;subscene=159&amp;subscene=158&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxNjkwODE5NQ%3D%3D%26mid%3D2247484357%26idx%3D1%26sn%3Dc07ab2eab9fc81122f4788418eba2af1%26chksm%3D9780ab09a0f7221f0eb5049da5056bdbe9702a6fc03e3d053ad18ea60e9d75c2037ad545e1a0%26scene%3D158%23rd#wechat_redirect">从零开始学习 zk-SNARK</a> : 来自 安比实验室，翻译原文，并且加入理解和拓展，推荐</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sec-bit/learning-zkp/blob/master/zkp-resource-list.md">零知识证明学习资源汇总</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/25/bigdata-and-blockchain/" rel="prev" title="大数据与区块链">
      <i class="fa fa-chevron-left"></i> 大数据与区块链
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/20/mpc-terminology/" rel="next" title="安全多方计算MPC的若干个概念">
      安全多方计算MPC的若干个概念 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-The-Medium-of-a-Proof"><span class="nav-number">1.</span> <span class="nav-text">2. The Medium of a Proof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Non-Interactive-Zero-Knowledge-of-a-Polynomial"><span class="nav-number">1.</span> <span class="nav-text">3 Non-Interactive Zero-Knowledge of a Polynomial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Proving-Knowledge-of-a-Polynomial"><span class="nav-number">2.</span> <span class="nav-text">3.1 Proving Knowledge of a Polynomial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Obscure-Evaluation"><span class="nav-number">3.</span> <span class="nav-text">3.3 Obscure Evaluation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-Homomorphic-Encryption%EF%BC%88%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">3.3.1 Homomorphic Encryption（同态加密）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-Strong-Homomorphic-Encryption"><span class="nav-number">5.</span> <span class="nav-text">3.3.3 Strong Homomorphic Encryption</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-Encrypted-Polynomial"><span class="nav-number">6.</span> <span class="nav-text">3.3.4 Encrypted Polynomial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Restricting-a-Polynomial"><span class="nav-number">7.</span> <span class="nav-text">3.4 Restricting a Polynomial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Zero-Knowledge"><span class="nav-number">8.</span> <span class="nav-text">3.5 Zero-Knowledge</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Non-Interactivity"><span class="nav-number">9.</span> <span class="nav-text">3.6 Non-Interactivity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-Succinct-Non-Interactive-Argument-of-Knowledge-of-Polynomial"><span class="nav-number">10.</span> <span class="nav-text">3.7 Succinct Non-Interactive Argument of Knowledge of Polynomial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-General-Purpose-Zero-Knowledge-Proofs"><span class="nav-number">11.</span> <span class="nav-text">4 General-Purpose Zero-Knowledge Proofs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Computation"><span class="nav-number">12.</span> <span class="nav-text">4.1 Computation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Enforcing-Operation"><span class="nav-number">13.</span> <span class="nav-text">4.3 Enforcing Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Proof-of-Operation"><span class="nav-number">14.</span> <span class="nav-text">4.4 Proof of Operation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-Variable-Polynomials"><span class="nav-number">15.</span> <span class="nav-text">4.6 Variable Polynomials</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-Construction-Properties"><span class="nav-number">16.</span> <span class="nav-text">4.7 Construction Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-Example-Computation"><span class="nav-number">17.</span> <span class="nav-text">4.8 Example Computation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-Verifiable-Computation-Protocol"><span class="nav-number">18.</span> <span class="nav-text">4.9 Verifiable Computation Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-1-%E9%99%90%E5%AE%9AL-x-%E5%8F%AA%E7%94%B1-li-x-%E6%9E%84%E6%88%90%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AF%81%E6%98%8E%E7%9A%84%E7%AD%89%E5%BC%8F%E5%BF%85%E9%A1%BB%E6%98%AFL-x-%C2%B7-R%EF%BC%88x%EF%BC%89-O-x-%E3%80%82-%E9%98%B2%E6%AD%A2%E5%B7%A6%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%8C%E5%8F%B3%E6%93%8D%E4%BD%9C%E6%95%B0%EF%BC%8C%E8%BE%93%E5%87%BA%E5%9C%A8%E8%AF%81%E6%98%8E%E4%B8%AD%E6%B7%B7%E7%94%A8%E3%80%82"><span class="nav-number">18.1.</span> <span class="nav-text">4.9.1 - 限定L(x)只由 li(x) 构成，并且证明的等式必须是L(x) · R（x）&#x3D; O(x)。 防止左操作数，右操作数，输出在证明中混用。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-2-%E9%99%90%E5%AE%9A%E5%9C%A8L-x-R-x-O-x-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%82%E6%95%B0vi-%E5%8D%B34-8%E4%BE%8B%E5%AD%90%E4%B8%AD%E7%9A%84a-b-w%E7%AD%89%EF%BC%89%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%E3%80%82"><span class="nav-number">18.2.</span> <span class="nav-text">4.9.2 - 限定在L(x),R(x),O(x)使用的参数vi(即4.8例子中的a,b,w等）是一致的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-9-3-Non-malleability-of-Variable-and-Variable-Consistency-Polynomials"><span class="nav-number">18.3.</span> <span class="nav-text">4.9.3 Non-malleability of Variable and Variable Consistency Polynomials</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-Constraints"><span class="nav-number">18.4.</span> <span class="nav-text">4.10 Constraints</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-11-Public-Inputs-and-One-%E9%99%90%E5%AE%9A%E5%B8%B8%E9%87%8F%E7%9A%84%E5%80%BC%E3%80%82"><span class="nav-number">19.</span> <span class="nav-text">4.11 Public Inputs and One 限定常量的值。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-12-Zero-Knowledge-Proof-of-Computation"><span class="nav-number">20.</span> <span class="nav-text">4.12 Zero-Knowledge Proof of Computation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ref"><span class="nav-number">21.</span> <span class="nav-text">Ref:</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Travis Wong"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Travis Wong</p>
  <div class="site-description" itemprop="description">Simple is Complex</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/simplexity-ckcclc" title="GitHub → https://github.com/simplexity-ckcclc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wchuang5900@gmail.com" title="E-Mail → mailto:wchuang5900@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-anchor"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Travis Wong</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '12eedb094a3054014378',
      clientSecret: 'a18108e1702f3c382aa9b2b6edd4c77336791528',
      repo        : 'simplexity-gitalk',
      owner       : 'simplexity-ckcclc',
      admin       : ['simplexity-ckcclc'],
      id          : '7a749231380e29af69f74358b5c835e9',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
